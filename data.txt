Tarun didnt asnwer, following questions
1)
class Parent {
static void print() {
System.out.println("Parent");
}
}
class Child extends Parent {
static void print() {
System.out.println("Child");
}
public static void main(String[] args) {
Parent obj = new Child();
obj.print();
}
}

Answer:

Parent

- Static methods are not overridden, they are hidden.

2)
public class Test5 {
public static void main(String[] args) {
int i = 0;
i = i++ + ++i;
System.out.println(i);
}
}

Answer:

2

- Post-increment uses `0`, pre-increment becomes `2`: `i = 0 + 2`.

3)

public class MapTest {
public static void main(String[] args) {
Map<String, String> map = new HashMap<>();
map.put(null, "One");
map.put(null, "Two");
System.out.println(map.size());
System.out.println(map.get(null));
}
}

Answer:

1
Two

- `HashMap` allows one `null` key, and the second `put` replaces the first.


4)
public class StringTest {
public static void main(String[] args) {
String s = "abc";
s.concat("def");
System.out.println(s);
}
}

Answer:

abc

- Strings are immutable. `concat` returns a new string, which is not used.


5)
@RestController
public class HelloController {

@GetMapping("/hello")
public String hello() {
return null;
}
}

Answer:
- Returns HTTP 204 No Content. Spring handles `null` as no content for `@RestController`.

6)
What happens if `@Entity` class has no `@Id`?

@Entity
public class Product {
private String name;
}

Answer:
- Runtime exception: `org.hibernate.AnnotationException: No identifier specified for entity`


He didnt answer questions related to transaction management
he is partiall correct on sql side indexing and having clause.