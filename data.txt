// 1) Build DISTINCT key sets (one per combination) – order preserved
java.util.LinkedHashSet<String> pceKeys = pceRecords.stream()
        .filter(r -> r.getOfficeCode()!=null && !r.getOfficeCode().trim().isEmpty()
                  && r.getCaseLoadId()!=null && !r.getCaseLoadId().trim().isEmpty())
        .map(r -> keyTriplet(r.getOfficeCode(), r.getCaseLoadId(), r.getAidCode()))
        .collect(java.util.stream.Collectors.toCollection(java.util.LinkedHashSet::new));

java.util.LinkedHashSet<String> famKeys = famCaseStatsOfcRecord.stream()
        .filter(f -> f.getOfcCd()!=null && !f.getOfcCd().trim().isEmpty()
                  && f.getCasldId()!=null && !f.getCasldId().trim().isEmpty())
        .map(f -> keyTriplet(f.getOfcCd(), f.getCasldId(), f.getAidCd()))
        .collect(java.util.stream.Collectors.toCollection(java.util.LinkedHashSet::new));

// 2) What’s missing = Fam − PCE (exactly one per combo)
java.util.LinkedHashSet<String> missing = new java.util.LinkedHashSet<>(famKeys);
missing.removeAll(pceKeys);

LOG.info("SANITY >>> famDistinct={}, pceDistinct={}, missing(fam-pce)={}",
        famKeys.size(), pceKeys.size(), missing.size());

// 3) Create one new row per missing key, in Fam order (first occurrence only)
java.util.HashSet<String> emitted = new java.util.HashSet<>();
for (FamCaseStatsOfficeRecord fam : famCaseStatsOfcRecord) {
    if (fam.getOfcCd()==null || fam.getOfcCd().trim().isEmpty()
     || fam.getCasldId()==null || fam.getCasldId().trim().isEmpty()) {
        continue;
    }
    String k = keyTriplet(fam.getOfcCd(), fam.getCasldId(), fam.getAidCd());
    if (missing.contains(k) && emitted.add(k)) {
        newPceRecords.add(mapToNewPceRecord(fam)); // your method already hard-sets ProgramCaseType(MA)
    }
}

logNewProgramCaseHistories(newPceRecords);
performDatabaseOperations(newPceRecords);
