 /**
     * This method returns a vector of parameters of the record with Global
     * JobID as Job Id and a specific Functional Area Id, Job Id and Program
     * Name.
     * @param aJobId The identifier for the job
     * @param aProgramName 
     * @return Vector returns a vector of parameters
     * @throws TIERSBatchException
     */
    public Vector getParameters(String aJobId, String aProgramName)
            throws TIERSBatchException {

        jobId = aJobId;
        StringTokenizer stk = new StringTokenizer(jobId, "-");
        StringBuffer sbf = new StringBuffer();
        while (stk.hasMoreTokens()) {
            sbf.append(stk.nextToken());
        }
        createUpdateUserId = sbf.toString();
        programName = aProgramName;

        try {
            parms = bpcDAO.findParameters(getTIERSBatchControllerConnection(),
                    jobId);

        } catch (Exception ex) {
            throw new TIERSBatchException("Error in finding the parameter: "+ex.getMessage(), ex);
        }

        if (parms == null) {
            throw new TIERSBatchException("Parameter vector is NULL");
        } else {
            return parms;
        }
    }

    /**
     * This method returns a ArrayList of parameters of the record with Gloabla
     * JobID as Job Id and a specific Functional Area Id, Job Id and Program
     * Name 
     * @param aJobId The identifier for the job
     * @param aProgramName 
     * @return ArrayList returns a arrayList of parameters
     * @throws TIERSBatchException
     */
    public ArrayList getParameter(String aJobId, String aProgramName)
            throws TIERSBatchException {
        jobId = aJobId;
        StringTokenizer stk = new StringTokenizer(jobId, "-");
        StringBuffer sbf = new StringBuffer();
        ArrayList lParms = null;
        while (stk.hasMoreTokens()) {
            sbf.append(stk.nextToken());
        }
        createUpdateUserId = sbf.toString();
        programName = aProgramName;
        try {
            lParms = bpcDAO.findParameter(getTIERSBatchControllerConnection(),
                    jobId);
        } catch (Exception ex) {
            throw new TIERSBatchException("Error in finding the parameter: "+ex.getMessage(), ex);
        }
        if (lParms == null) {
            throw new TIERSBatchException("Parameter vector is NULL");
        } else {
            return lParms;
        }
    }

    /**
     * This method returns the Run No of a given file.
     * @param aJobId The identifier for the job
     * @param aLogicalFileName
     * @param aFileMode
     * @return int
     * @throws TIERSBatchException
     */
    public int getRunNo(String aJobId, String aLogicalFileName, String aFileMode)
            throws TIERSBatchException {
        int runNo = 0;
        try {
            runNo = bfcDAO.getRunNo(getTIERSBatchControllerConnection(),
                    aJobId, aLogicalFileName, getAsOfDate(), aFileMode);
        } catch (Exception ex) {
            throw new TIERSBatchException("Error in getting the Run Number: "+ex.getMessage(), ex);
        } finally {
            
        }
        return runNo;
    }

    /**
     * This method returns the Start Date and Time of the program (recorded when
     * a record is inserted into FW_BATCH_RUN_CONTROL Table.
     * @return String
     * @throws TIERSBatchException  
     */
    public String getStartDateTime() throws TIERSBatchException {
        if (startDateTime == null) {
            throw new TIERSBatchException("Start Date Time is NULL");
        } else {
            return startDateTime;
        }
    }

    /**
     * This method returns Properties object.
     * @deprecated since <unknown>
     * @return Properties
     * @throws TIERSBatchException
     */
    public Properties getTIERSProperties() throws TIERSBatchException {
        try {
            if (batchProperty == null) {
                if (propsFileName == null) {
                    //Assign the argument aPath to path to use while invoking
                    // getRunNo from getOutputFileNames of File Assembler
                    //InputStream is =
                    // Class.forName("gov.illinois.fw.batch.Controller.TIERSBatchController").getResourceAsStream(BatchConstants.PROPERTIES_FILE);
                    //props.load(is);
                    batchProperty = FwPropertyLoader
                            .getProperties(BatchConstants.PROPERTIES_FILE);
                } else {
                    batchProperty.load(new FileInputStream(new File(
                    		FilenameUtils.normalize(propsFileName))));
                }
            }
        } catch (Exception ex) {
            throw new TIERSBatchException("Error in loading the error file: "+ex.getMessage(), ex);
        }
        if (batchProperty == null) {
            throw new TIERSBatchException("Property is NULL");
        } else {
            return batchProperty;
        }
    }

    /**
     * This method returns Properties object. Code added for Reports informatica enhancement
     * @deprecated since <unknown>
     * @return Properties
     * @throws TIERSBatchException
     */
    public Properties getInformaticaProperties() throws TIERSBatchException {
        try {
        	informaticaProperties = FwPropertyLoader.getProperties(BatchConstants.INFORMATICA_PROPERTIES_FILE);
        } catch (Exception ex) {
            throw new TIERSBatchException("Error in loading the error file: "+ex.getMessage(), ex);
        }
        if (informaticaProperties == null) {
            throw new TIERSBatchException("Informatica Property is NULL");
        } else {
            return informaticaProperties;
        }
    }
    
    
    /**
     * This method returns the System Time Stamp in the format MM-DD-YY
     * HH:MM:SS.
     * @return String 
     * @throws TIERSBatchException  
     */
    public static String getTimeStamp() throws TIERSBatchException {
        String ts = null;
        try {
            GregorianCalendar gc = new GregorianCalendar();
            int month = gc.get(GregorianCalendar.MONTH);
            String year = "" + gc.get(GregorianCalendar.YEAR);
            int day = gc.get(GregorianCalendar.DAY_OF_MONTH);
            int hour = gc.get(GregorianCalendar.HOUR_OF_DAY);
            int minute = gc.get(GregorianCalendar.MINUTE);
            int second = gc.get(GregorianCalendar.SECOND);
            ts = (month + 1) + "-" + day + "-" + year + " " + hour + ":"
                    + minute + ":" + second;
        } catch (Exception ex) {
            throw new TIERSBatchException("Error in formatting the TimeStamp: "+ex.getMessage(), ex);
        }

        if (ts == null) {
            throw new TIERSBatchException("Time Stamp is NULL");
        } else {
            return ts;
        }

    }
    
    /**
     * This method inserts into File Control for Parallel run
     * @return String returns true or false
     * @throws TIERSBatchException  
     */
    public boolean insertFileControlRecordForParllelRun(String ajobId,
            String aLogicalFileName) throws TIERSBatchException {
        int runNo = 0;

        try {
            if (isParallelRunProgram() && !getParallelStream()) {
               // runNo = getParallelRunNum();
                runNo = Integer.parseInt(brcDAO.getParallelRunNum());
            } else {
                long run = 0;
                runNo = getAdjustedMaximumRunNo();
                runNo = brcDAO.getMaximumRunNoParallelJobInt(
                        getTIERSBatchControllerConnection(), ajobId, getAsOfDate());
                runNo++;

            }
          //  System.err.println("Run Number :" + runNo);
            return bfcDAO.insertFileControlRecord(
                    getTIERSBatchControllerConnection(), ajobId,
                    aLogicalFileName, getAsOfDate(), runNo, createUpdateUserId);
        } catch (Exception ex) {
            throw new TIERSBatchException(
                    "Error in inserting the insertFileControlRecord "
                            + ex.getMessage(), ex);
        }
    }

    /**
     * This method returns boolean status of insertion of a record into
     * FW_BATCH_FILE_CONTROL table.
     * @param ajobId The identifier for the job
     * @param aLogicalFileName file name from the external source
     * @return boolean returns true or false
     * @throws TIERSBatchException
     */
    public boolean insertFileControlRecord(String ajobId,
            String aLogicalFileName) throws TIERSBatchException {
        int runNo = 0;

        try {
            if (isParallelRunProgram() && !getParallelStream()) {
                runNo = getParallelRunNum();
            } else {
                long run = 0;
                runNo = getAdjustedMaximumRunNo();

            }
        //    System.err.println("Run Number :" + runNo);
            return bfcDAO.insertFileControlRecord(
                    getTIERSBatchControllerConnection(), ajobId,
                    aLogicalFileName, getAsOfDate(), runNo, createUpdateUserId);
        } catch (Exception ex) {
            throw new TIERSBatchException(
                    "Error in inserting the insertFileControlRecord "
                            + ex.getMessage(), ex);
        }
    }

    /**
     * This method returns boolean status of insertion of a record into
     * FW_BATCH_RUN_CONTROL table.
     * @deprecated since <unknown>
     * @return boolean
     * @throws RunningProcessException
     * @throws TIERSBatchException
     */
    public boolean insertRunControlRecord() throws RunningProcessException,
            TIERSBatchException {
        boolean insertSuccessful = false;
        String timeStamp = null;
        try {
            if (asOfDate == null) {
                asOfDate = bpcDAO.findAsOfDate(
                        getTIERSBatchControllerConnection(), jobId);
            }
        } catch (Exception ex) {
            throw new TIERSBatchException("Error in finding AsOfDate "
                    + ex.getMessage(), ex);
        }
        try {
            timeStamp = getTimeStamp();
        } catch (Exception ex) {
            throw new TIERSBatchException("Error in finding TimeStamp "
                    + ex.getMessage(), ex);
        }
        startDateTime = timeStamp;

        try {
            if (isParallelRunProgram()) {
            	if (isLoadUtility){
            		
            		insertSuccessful = brcDAO.insertRunControlRecord(
                            getTIERSBatchControllerConnection(), jobId.substring(0,9)+"LDU",
                            getParallelRunId(), getAsOfDate(), BatchConstants.START,
                            overWriteFlag, isRestartProgram(), createUpdateUserId,errorLogContext);
            	}
            	else
            	{
            		insertSuccessful = brcDAO.insertRunControlRecord(
                            getTIERSBatchControllerConnection(), jobId,
                            getParallelRunId(), getAsOfDate(), BatchConstants.START,
                            overWriteFlag, isRestartProgram(), createUpdateUserId,errorLogContext);
            	}
                
            } else {
            	if (isLoadUtility){
            		
            		insertSuccessful = brcDAO.insertRunControlRecord(
                            getTIERSBatchControllerConnection(), jobId.substring(0,9)+"LDU", getAsOfDate(),
                            BatchConstants.START, overWriteFlag,
                            isRestartProgram(), createUpdateUserId,errorLogContext);
            	}
            	else
            	{
            		insertSuccessful = brcDAO.insertRunControlRecord(
                            getTIERSBatchControllerConnection(), jobId, getAsOfDate(),
                            BatchConstants.START, overWriteFlag,
                            isRestartProgram(), createUpdateUserId,errorLogContext);
            	}
                
            }
          
        } catch (RunningProcessException rpex) {
            throw new TIERSBatchException("Process already running "
                    + rpex.getMessage(), rpex);
        } catch (Exception ex) {
            throw new TIERSBatchException("Error in inserting RunControl "
                    + ex.getMessage(), ex);
        }
        return insertSuccessful;
    }
    
    /**
     * This method returns boolean status of insertion of a record into
     * FW_BATCH_RUN_CONTROL table.
     * @deprecated since <unknown>
     * @return boolean
     * @throws RunningProcessException
     * @throws TIERSBatchException
     */
    public boolean insertRunControlRecord(Connection con) throws RunningProcessException,
            TIERSBatchException {
        boolean insertSuccessful = false;
        String timeStamp = null;
        try {
            if (asOfDate == null) {
                asOfDate = bpcDAO.findAsOfDate(
                        con, jobId);
            }
        } catch (Exception ex) {
            throw new TIERSBatchException("Error in finding AsOfDate "
                    + ex.getMessage(), ex);
        }
        try {
            timeStamp = getTimeStamp();
        } catch (Exception ex) {
            throw new TIERSBatchException("Error in finding TimeStamp "
                    + ex.getMessage(), ex);
        }
        startDateTime = timeStamp;

        try {
            if (isParallelRunProgram()) {
            	if (isLoadUtility){
            		
            		insertSuccessful = brcDAO.insertRunControlRecord(
                            con, jobId.substring(0,9)+"LDU",
                            getParallelRunId(), getAsOfDate(), BatchConstants.START,
                            overWriteFlag, isRestartProgram(), createUpdateUserId,errorLogContext);
            	}
            	else
            	{
            		insertSuccessful = brcDAO.insertRunControlRecord(
                            con, jobId,
                            getParallelRunId(), getAsOfDate(), BatchConstants.START,
                            overWriteFlag, isRestartProgram(), createUpdateUserId,errorLogContext);
            	}
                
            } else {
            	if (isLoadUtility){
            		
            		insertSuccessful = brcDAO.insertRunControlRecord(
                            con, jobId.substring(0,9)+"LDU", getAsOfDate(),
                            BatchConstants.START, overWriteFlag,
                            isRestartProgram(), createUpdateUserId,errorLogContext);
            	}
            	else
            	{
            		insertSuccessful = brcDAO.insertRunControlRecord(
                            con, jobId, getAsOfDate(),
                            BatchConstants.START, overWriteFlag,
                            isRestartProgram(), createUpdateUserId,errorLogContext);
            	}
               
            }
          
        } catch (RunningProcessException rpex) {
            throw new TIERSBatchException("Process already running "
                    + rpex.getMessage(), rpex);
        } catch (Exception ex) {
            throw new TIERSBatchException("Error in inserting RunControl "
                    + ex.getMessage(), ex);
        }
        return insertSuccessful;
    }
    
    /**
     * This method returns HashMap populated with logical file name and a vector
     * containing physical file name, record count and buffered writer/reader
     * @param aJobIds The identifier for the job
     * @param aInpLogicalFileNamesAndDates 
     * @param aInputFileNames 
     * @param aRunNos 
     * @param aOutLogicalFileNames 
     * @param aOutputFileNames 
     * @return HashMap 
     * @throws TIERSBatchException  
     */
    public HashMap openFiles(String[] aJobIds,
            String[][] aInpLogicalFileNamesAndDates, String[] aInputFileNames,
            int[] aRunNos, String[] aOutLogicalFileNames,
            String[] aOutputFileNames) throws TIERSBatchException {

        long[] recordCounts = new long[aInputFileNames.length];
        HashMap lookupTableLocal = null;
        try {
            int recordCountsLength = recordCounts.length;
            for (int i = 0; i < recordCountsLength; i++) {
                recordCounts[i] = bfcDAO.getRecordCount(
                        getTIERSBatchControllerConnection(), aJobIds[i],
                        aInpLogicalFileNamesAndDates[i][0], getAsOfDate(),
                        aRunNos[i]);
            }
        } catch (Exception ex) {
            throw new TIERSBatchException(
                    "Error getting the record for record count: "
                            + ex.getMessage(), ex);
        }

        try {
            lookupTableLocal = exp.openFiles(aInpLogicalFileNamesAndDates,
                    aInputFileNames, recordCounts, aOutLogicalFileNames,
                    aOutputFileNames, overWriteFlag);
        } catch (Exception ex) {
            throw new TIERSBatchException("Error getting the physical Files "
                    + ex.getMessage(), ex);
        }

        if (lookupTableLocal == null) {
            throw new TIERSBatchException("Lookup Table is NULL");
        } else {
            return lookupTableLocal;
        }
    }

    /**
     * This method returns HashMap populated with logical file name and a vector
     * containing physical file name, record count and buffered writer/reader.
     * @param aOutLogicalFileNames
     * @param aOutputFileNames
     * @return HashMap 
     * @throws TIERSBatchException  
     */
    public HashMap openFiles(String[] aOutLogicalFileNames,
            String[] aOutputFileNames) throws TIERSBatchException {
        HashMap lookupTableLocal = null;

        try {
            lookupTableLocal = exp.openFiles(aOutLogicalFileNames,
                    aOutputFileNames, overWriteFlag);
        } catch (Exception ex) {
            throw new TIERSBatchException("Error in Opening Files "
                    + ex.getMessage(), ex);
        }
        if (lookupTableLocal == null) {
            throw new TIERSBatchException("Lookup Table is NULL");
        } else {
            return lookupTableLocal;
        }
    }

    /**
     * This method builds a HashMap containing logical file (input and output)
     * name as key and a vector containing physical file name, record count and
     * the corresponding buffered writer/reader.
     * @param aInputJobIds jobIds to be processed
     * @param aInpLogicalFileNamesAndDates
     * @param aOutLogicalFileNames
     * @return HashMap
     * @throws TIERSBatchException  
     */
    public HashMap processRequest(String[] aInputJobIds,
            String[][] aInpLogicalFileNamesAndDates,
            String[] aOutLogicalFileNames) throws TIERSBatchException {

        try {
            inputFileNames = getInputFileNames(aInputJobIds,
                    aInpLogicalFileNamesAndDates);
            outputFileNames = getOutputFileNames(aOutLogicalFileNames);
        } catch (Exception ex) {
            throw new TIERSBatchException("Error in getting FileNames "
                    + ex.getMessage(), ex);
        }

        try {
            lookupTable = openFiles(aInputJobIds, aInpLogicalFileNamesAndDates,
                    inputFileNames, runNos, aOutLogicalFileNames,
                    outputFileNames);
            if (lookupTable == null) {
                throw new TIERSBatchException("Lookup Table is NULL");
            } else {
                return lookupTable;
            }
        } catch (Exception ex) {
            throw new TIERSBatchException("Error in Opening Files "
                    + ex.getMessage(), ex);
        }
    }

    /**
     * This method builds a HashMap containing logical file (only output) name
     * as key and a vector containing physical file name, record count and the
     * corresponding buffered writer/reader. This method is to be invoked by the
     * programs that deal with only output files
     * @param aOutLogicalFileNames
     * @return HashMap
     * @throws TIERSBatchException  
     */
    public HashMap processRequest(String[] aOutLogicalFileNames)
            throws TIERSBatchException {

        try {
            outputFileNames = getOutputFileNames(aOutLogicalFileNames);
        } catch (Exception ex) {
            throw new TIERSBatchException("Error in getting output File Names "
                    + ex.getMessage(), ex);
        }
        //Invoking openFiles method
        try {
            lookupTable = openFiles(aOutLogicalFileNames, outputFileNames);
            if (lookupTable == null) {
                throw new TIERSBatchException("Lookup Table is NULL");
            } else {
                return lookupTable;
            }
        } catch (Exception ex) {
            throw new TIERSBatchException("Error in opening in Files "
                    + ex.getMessage(), ex);
        }
    }

    /**
     * This method returns a record read from a given file. 
     * @param buffReader 
     * @return String
     * @throws TIERSBatchException  
     */
    public String readFromFile(java.io.BufferedReader buffReader)
            throws TIERSBatchException {
        try {
            String recordRead = exp.readFromFile(buffReader);
            return recordRead;
        } catch (Exception ex) {
            throw new TIERSBatchException("Error while reading from files "
                    + ex.getMessage(), ex);
        }

    }

    /**
     * This method updates the Discrepancy Quantity for a given file.
     * @param aJobId 
     * @param aLogicalFileName
     * @param aAsOfDate
     * @param aDiscrepancyQty
     * @return boolean
     * @throws TIERSBatchException  
     */
    public boolean setDiscrepancyQty(String aJobId, String aLogicalFileName,
            String aAsOfDate, long aDiscrepancyQty) throws TIERSBatchException {
        int runNo = 0;
        try {
            runNo = getAdjustedMaximumRunNo();
            if (isParallelRunProgram()) {
                bfcDAO.lockOutputFiles(getTIERSBatchControllerConnection(),
                        getJobId(), getAsOfDate());
            }
            bfcDAO.updateDiscrepancyQtyOfFileControlRecord(
                    getTIERSBatchControllerConnection(), aJobId,
                    aLogicalFileName, aAsOfDate, runNo, aDiscrepancyQty,
                    createUpdateUserId);
            if (isParallelRunProgram()) {
                bfcDAO.unlockOutputFiles(getTIERSBatchControllerConnection(),
                        getJobId(), getAsOfDate());
            }
            return true;
        } catch (Exception ex) {
            throw new TIERSBatchException(
                    "Error while setting Discrepancy Qty " + ex.getMessage(), ex);
        }
    }

    /**
     * This method updates the Discrepancy Quantity for a given file.
     * @param aJobId The identifier for the job
     * @param aLogicalFileName file name from the external source
     * @param aRunNum Has the run number of the particular run
     * @param aAsOfDate Has the as of date of the job
     * @param aDiscrepancyQty quantity
     * @return boolean returns true or false
     * @throws TIERSBatchException
     */
    public boolean setDiscrepancyQty(String aJobId, String aLogicalFileName,
            int aRunNum, String aAsOfDate, long aDiscrepancyQty)
            throws TIERSBatchException {
        try {
            if (isParallelRunProgram()) {
                bfcDAO.lockOutputFiles(getTIERSBatchControllerConnection(),
                        getJobId(), getAsOfDate());
            }
            bfcDAO.updateDiscrepancyQtyOfFileControlRecord(
                    getTIERSBatchControllerConnection(), aJobId,
                    aLogicalFileName, aAsOfDate, aRunNum, aDiscrepancyQty,
                    createUpdateUserId);
            if (isParallelRunProgram()) {
                bfcDAO.unlockOutputFiles(getTIERSBatchControllerConnection(),
                        getJobId(), getAsOfDate());
            }
            return true;
        } catch (Exception ex) {
            throw new TIERSBatchException("Error in updating Discrepancy Qty "
                    + ex.getMessage(), ex);
        }
    }

    /**
     * This method sets the Specific Header of the Exception Report.
     * @param aSpecificHeader spec. header 
     * @throws TIERSBatchException
     */
    public void setExceptionSpecificHeader(String aSpecificHeader)
            throws TIERSBatchException {
        try {
            crg.setExceptionSpecificHeader(aSpecificHeader);
        } catch (Exception ex) {
            throw new TIERSBatchException(
                    "Error in setting Exception specific Header "
                            + ex.getMessage(), ex);
        }
    }

    /**
     * This method updates the Record Count of a given file.
     * @param aLogicalFileName file name from the external source
     * @param aAsOfDate Has the as of date of the job
     * @param aRecordCount Has the record count of the particular run
     * @return boolean returns true or false
     * @throws TIERSBatchException
     */
    public boolean setOutputFileRecordCount(String aLogicalFileName,
            String aAsOfDate, long aRecordCount) throws TIERSBatchException {
        int runNo = 0;
        try {
            runNo = getAdjustedMaximumRunNo();
            if (isParallelRunProgram()) {
                bfcDAO.lockOutputFiles(getTIERSBatchControllerConnection(),
                        getJobId(), getAsOfDate());
            }
            bfcDAO.updateFileControlRecordCount(
                    getTIERSBatchControllerConnection(), jobId,
                    aLogicalFileName, aAsOfDate, runNo, aRecordCount,
                    createUpdateUserId);
            if (isParallelRunProgram()) {
                bfcDAO.unlockOutputFiles(getTIERSBatchControllerConnection(),
                        getJobId(), getAsOfDate());
            }
            return true;
        } catch (Exception ex) {
            throw new TIERSBatchException(
                    "Error in Updating File Control Record Count "
                            + ex.getMessage(), ex);
        }
    }

    /**
     *This method updates the Record Count of a given file.
     * @param aLogicalFileName file name from the external source
     * @param aRunNum Has the run number of the particular run
     * @param aAsOfDate Has the as of date of the job
     * @param aRecordCount Has the record count of the particular run
     * @return boolean returns true or false
     * @throws TIERSBatchException
     */
    public boolean setOutputFileRecordCount(String aLogicalFileName,
            int aRunNum, String aAsOfDate, long aRecordCount)
            throws TIERSBatchException {
        try {
            if (isParallelRunProgram()) {
                bfcDAO.lockOutputFiles(getTIERSBatchControllerConnection(),
                        getJobId(), getAsOfDate());
            }
            bfcDAO.updateFileControlRecordCount(
                    getTIERSBatchControllerConnection(), jobId,
                    aLogicalFileName, aAsOfDate, aRunNum, aRecordCount,
                    createUpdateUserId);
            if (isParallelRunProgram()) {
                bfcDAO.unlockOutputFiles(getTIERSBatchControllerConnection(),
                        getJobId(), getAsOfDate());
            }
            return true;
        } catch (Exception ex) {
            throw new TIERSBatchException(ex.getMessage(), ex);
        }
    }

    /**
     * This method updates the record of FW_BATCH_RUN_CONTROL Table
     * @param aStatus 
     * @return boolean
     * @throws TIERSBatchException
     */
    public boolean updateRunControlRecord(String aStatus)
            throws TIERSBatchException {
        try {
            if (isParallelRunProgram()) {
            	if (isLoadUtility){
            		return brcDAO.updateRunControlRecord(
                            getTIERSBatchControllerConnection(), jobId.substring(0,9)+"LDU",
                            getParallelRunId(), getAsOfDate(), aStatus,
                            createUpdateUserId);
            	}
            	else
            	{
                return brcDAO.updateRunControlRecord(
                        getTIERSBatchControllerConnection(), jobId,
                        getParallelRunId(), getAsOfDate(), aStatus,
                        createUpdateUserId);
            	}
            } else {
            	
            	if (isLoadUtility){
            		return brcDAO.updateRunControlRecord(
                            getTIERSBatchControllerConnection(), jobId.substring(0,9)+"LDU", getAsOfDate(),
                            aStatus, createUpdateUserId);
            	}
            	else
            	{
            		return brcDAO.updateRunControlRecord(
                            getTIERSBatchControllerConnection(), jobId, getAsOfDate(),
                            aStatus, createUpdateUserId);
            	}                
            }
        } catch (Exception ex) {
            throw new TIERSBatchException(
                    "Error in updating run control record to " + aStatus
                            + " : " + ex.getMessage(), ex);
        }
    }

    /**
     *This method writes the String to a specified file
     * @param aBuffWriter  
     * @param aStr 
     * @return boolean
     * @throws TIERSBatchException     
     */
    public boolean writeToFile(BufferedWriter aBuffWriter, String aStr)
            throws TIERSBatchException {
        try {
            return exp.writeToFile(aBuffWriter, aStr);
        } catch (Exception ex) {
            throw new TIERSBatchException("Error in writing into File "
                    + ex.getMessage(), ex);
        }

    }

    /**
     * This method returns the Vector conatining the details of the file
     * (Physiacl File Name, Record Count and Buffered Writer/Reader)
     * @param aLogicalFileName file name from the external source
     * @param aLookupTable 
     * @return Vector
     * @throws TIERSBatchException
     */
    public Vector getFileDetails(String aLogicalFileName, HashMap aLookupTable)
            throws TIERSBatchException {
        Vector fileDetails = null;
        try {
            fileDetails = (Vector) aLookupTable.get(aLogicalFileName);
        } catch (Exception ex) {
            throw new TIERSBatchException(
                    "Error in getting file details from HashMap"
                            + ex.getMessage(), ex);
        }

        return fileDetails;
    }

    /**
     * This method returns the Vector conatining the details of the file
     * (Physiacl File Name, Record Count and Buffered Writer/Reader)
     * @param aLogicalFileName file name from the external source
     * @param aLookupTable HashMap
     * @return ArrayList
     * @throws TIERSBatchException
     */
    public ArrayList getFileDetail(String aLogicalFileName, HashMap aLookupTable)
            throws TIERSBatchException {
        ArrayList fileDetails = null;
        try {
            fileDetails = (ArrayList) aLookupTable.get(aLogicalFileName);
        } catch (Exception ex) {
            throw new TIERSBatchException(
                    "Error in getting file details from HashMap"
                            + ex.getMessage(), ex);
        }

        return fileDetails;
    }

    /**
     * This method formats the date from a particular format 
     * to a particular format.
     * If target mask is NULL, date will be formatted 
     * using the default mask "MM/DD/YYYY".
     * @param aDateToFormat String
     * @param aFromDateMask String
     * @param aToDateMask String
     * @return String
     * @throws TIERSBatchException
     */
    public String formatDate(String aDateToFormat, String aFromDateMask,
            String aToDateMask) throws TIERSBatchException {
        try {
            return DataFormatter.formatDate(
                    getTIERSBatchControllerConnection(), aDateToFormat,
                    aFromDateMask, aToDateMask);
        } catch (Exception ex) {
            throw new TIERSBatchException("Error in formatting Date: "
                    + ex.getMessage(), ex);
        }
    }

    /**
     * This method returns the Run No of a given Job Id.
     * @return int 
     * @throws TIERSBatchException
     */
    public int getAdjustedMaximumRunNo() throws TIERSBatchException {

        try {
            if (!this.adjustedrunNoSet) {
                this.adjustedrunNo = brcDAO.getAdjustedMaximumRunNoInt(getTIERSBatchControllerConnection(), jobId, asOfDate,
                        overWriteFlag);
                this.adjustedrunNoSet = true;
            }
        } catch (Exception ex) {
            throw new TIERSBatchException(
                    "Error in getting Adjusted Maximum RunNum "
                            + ex.getMessage(), ex);
        } finally {
           
        }
        return this.adjustedrunNo;
    }

    /**
     * Gets maximum Run Num
     * @return int returns max. number
     * @throws TIERSBatchException
     */
	public int getMaximumRunNo() throws TIERSBatchException {
		int runNo = 0;
		try {
			runNo = brcDAO.getMaximumRunNoInt(
					getTIERSBatchControllerConnection(), jobId, getAsOfDate());
		} catch (Exception ex) {
			getLogger().log(
					FwConstants.LOGGING_CATEGORY_FRAMEWORK,
					ILog.ERROR,
					"Error in getting Maximum Run Num. Message: "
							+ ex.getMessage(), ex);
			throw new TIERSBatchException(
					"Error in getting Maximum Run Num. Message: "
							+ ex.getMessage(), ex);

		}

		return runNo;
	}
	
	public int writeExceptionRecord(String aExceptionCode, String aExceptionSummary, String aExceptionDetail, String aColumnType, boolean businessException, String errorCode, 
			String columnName, String columnValue, String definerCd, String recType, String legacyCaseValue, String segmentName, String tableName, 
			String triggerReasonCd, String triggerTypeCd, String fwRin)
				throws TIERSBatchException {
		int statusCode = 0;
		try {
			// Inserting into Batch Exceptions
			if (batchExcController == null) {
				batchExcController = new BatchExceptionController(getJobId(), getConnectionForWriteException(), thresholdValue);
			}
			recordNum = recordNum + 1;
			// This temp_JobID was created to handle the Load utility issue with
			// Run_Control table entry
			String finalJobId = jobId;
			if (isLoadUtility) {
				finalJobId = jobId.substring(0, 9) + "LDU";
			}
			int finalParallelRunNum = getCurrentRunNum();
			if(isParallelRunProgram()){
				finalParallelRunNum = getParallelRunNum();
			}
			
			statusCode = batchExcController.insertExceptionRecord(
					getConnectionForWriteException(), finalJobId, getAsOfDate(), getCurrentRunNum(), finalParallelRunNum, programName, aExceptionCode,
					aExceptionSummary, aExceptionDetail, createUpdateUserId, aColumnType, recordNum, businessException, errorCode, columnName,
					columnValue, definerCd, recType, legacyCaseValue, segmentName, tableName, triggerReasonCd, triggerTypeCd, fwRin);
			
			checkStatusException(statusCode, aExceptionCode);
		} catch (Exception ex) {
			getLogger().log(FwConstants.LOGGING_CATEGORY_FRAMEWORK,ILog.ERROR,"Error writing exception record. Message: "+ ex.getMessage(), ex);
			throw new TIERSBatchException("Error writing exception record. Message: "+ ex.getMessage(), ex);
		}
		return statusCode;
	}
	

    public int writeExceptionRecord(String aExceptionCode, String aExceptionSummary, String aExceptionDetail, String aColumnType, 
    	boolean aCountBusinessException, String errorCode, String columnName, String columnValue)
			throws TIERSBatchException {
		return writeExceptionRecord(aExceptionCode, aExceptionSummary, aExceptionDetail, aColumnType, aCountBusinessException, errorCode, columnName, columnValue,null, null, null, null, null, null, null, null);
	}
    
    /**
     * @param aExceptionCode exceptionCode to be processed
     * @param aExceptionSummary Has the summary of Exception
     * @param aExceptionDetail Has the the details of particular Exception
     * @param aCountBusinessException passes true or false
     * @return int returns count of number of records
     * @throws TIERSBatchException 
     **/
	public int writeExceptionRecord(String aExceptionCode,
			String aExceptionSummary, String aExceptionDetail,
			boolean aCountBusinessException) throws TIERSBatchException {
			return writeExceptionRecord(aExceptionCode, aExceptionSummary, aExceptionDetail, null, aCountBusinessException);
	}

	/**
	 * Writes Exception Record.
	 * 
	 * @param aExceptionCode
	 *            exceptionCode to be processed
	 * @param aExceptionSummary
	 *            Has the summary of Exception
	 * @param aExceptionDetail
	 *            Has the the details of particular Exception
	 * @param aColumnType
	 *            type to be processed
	 * @param aCountBusinessException
	 *            passes true or false
	 * @return int returns count of number of records
	 * @throws TIERSBatchException
	 */
	public int writeExceptionRecord(String aExceptionCode,
			String aExceptionSummary, String aExceptionDetail,
			String aColumnType, boolean aCountBusinessException)
			throws TIERSBatchException {
		return writeExceptionRecord(aExceptionCode, aExceptionSummary, aExceptionDetail, aColumnType, aCountBusinessException, null, null, null);

	}

    /**
     * New Write exception for Error Log Context. This method will also 
     * log exceptions in error log table.
     * @param aExceptionCode exceptionCode to be processed
     * @param aExceptionSummary Has the summary of Exception
     * @param aExceptionDetail Has the the details of particular Exception
     * @param aColumnType type to be processed
     * @param aCountBusinessException passes true or false 
     * @param context context to be processed
     * @param contextValue value of context to be processed
     * @return int returns count of number of records
     * @throws TIERSBatchException
     */
    public int writeExceptionRecord(String aExceptionCode,
            String aExceptionSummary, String aExceptionDetail,
            String aColumnType, boolean aCountBusinessException,String context,String contextValue)  throws TIERSBatchException {
    	String[] newContext = new String[1];
    	String[] newContextVal = new String[1];
    	newContext[0] = context;
    	newContextVal[0] = contextValue;
    	return writeExceptionRecord(aExceptionCode,aExceptionSummary,aExceptionDetail,aColumnType,aCountBusinessException,newContext,newContextVal);    
    }
    
    /**
     * New Write exception for Error Log Context. This method will 
     * also log exceptions in error log table with multiple contexts
     * @param aExceptionCode exceptionCode to be processed
     * @param aExceptionSummary Has the summary of Exception
     * @param aExceptionDetail Has the the details of particular Exception
     * @param aColumnType type to be processed
     * @param aCountBusinessException passes true or false
     * @param context context to be processed
     * @param contextValue value of context to be processed
     * @return int returns count of number of records
     * @throws TIERSBatchException
     */
    
    public int writeExceptionRecord(String aExceptionCode,
            String aExceptionSummary, String aExceptionDetail,
			String aColumnType, boolean aCountBusinessException,
			String[] context, String[] contextValue) throws TIERSBatchException {
		try {
			createErrorLogBean(aExceptionCode, aExceptionSummary, aExceptionDetail);
			createErrorLogDetailsBeans(context, contextValue);
			persistErrorLog();
		} catch (Exception ex) {
			getLogger().log(FwConstants.LOGGING_CATEGORY_FRAMEWORK, ILog.ERROR, "Error writing exception record. Message: " + ex.getMessage(), ex);
			throw new TIERSBatchException("Error writing exception record. Message: " + ex.getMessage(), ex);
		}
		return writeExceptionRecord(aExceptionCode, aExceptionSummary, aExceptionDetail, aColumnType, aCountBusinessException);
	}
    
    
    /**
     * THE METHOD BELOW IS USED BY DATASYNC TEAM
     * Writes Exception Record
     * @param aCountBusinessException passes true or false
     * @param fwBatchExceptionsCargo : holds additional values for the new columns added to FW_BATCH_EXCEPTION 
	 * New columns: COLUMN_NAME,COLUMN_VALUE,DEFINER_CD,ERROR_CD,REC_TYPE ,LEGACY_CASE_VALUE,SEGMENT_NAME,TABLE_NAME,TRIGGER_REASON_CD,TRIGGER_TYPE_CD
     * @return int returns count of number of records
     * @throws TIERSBatchException
     */
    public int writeExceptionRecord(boolean aCountBusinessException, FwBatchExceptionsCargo fwBatchExceptionsCargo) throws TIERSBatchException {
		return writeExceptionRecord(fwBatchExceptionsCargo.getExceptionCd(), fwBatchExceptionsCargo.getExceptionSummary(), fwBatchExceptionsCargo.getExceptionDetail(), fwBatchExceptionsCargo.getColumnType(), 
					aCountBusinessException, fwBatchExceptionsCargo.getErrorCode(), fwBatchExceptionsCargo.getColumnName(), fwBatchExceptionsCargo.getColumnValue(),
					fwBatchExceptionsCargo.getDefinerCd(), fwBatchExceptionsCargo.getRecType(),
					fwBatchExceptionsCargo.getLegacyCaseValue(), fwBatchExceptionsCargo.getSegmentName(), fwBatchExceptionsCargo.getTableName(), fwBatchExceptionsCargo.getTriggerReasonCd(),
					fwBatchExceptionsCargo.getTriggerTypeCd(), fwBatchExceptionsCargo.getFwRin());
	}
    
    /**
     * This method creates Error Log Bean
     * @param aExceptionCode exceptionCode to be processed
     * @param aExceptionSummary Has the summary of Exception
     * @param aExceptionDetail Has the the details of particular Exception
     */
    
    private void createErrorLogBean(String aExceptionCode,
            String aExceptionSummary, String aExceptionDetail) {
    	String refId = errorLogContext.getReferenceId();  	
    	errorLogBean.setReferenceId(refId);
    	errorLogBean.setExceptionNum(Long.toString(recordNum));
    	errorLogBean.setExceptionDate(FwCalendar.getInstance().getDate().getTime());
    	errorLogBean.setExceptionSeverity(aExceptionCode.substring(0,1));
    	errorLogBean.setExceptionSummary(aExceptionSummary);
    	errorLogBean.setExceptionDetails(aExceptionDetail);  
    }
    
    /**
     * This method creates Error Log Details for each and every contexts
     * @param context context to be processed
     * @param contextValue value of context to be processed
     */
    private void createErrorLogDetailsBeans(String[] context,String[] contextValue) {
    	int contextSize = context.length;
    	String refId = errorLogContext.getReferenceId();
    	String exNum = errorLogBean.getExceptionNum();
    	String contId = null;
    	String value = null;
    	for (int i=0;i<contextSize;i++) {
    		FwErrorLogDetailsBean eldb = new FwErrorLogDetailsBean();
    		contId = context[i];
    		value = contextValue[i];
    		if (contId != null && value != null) {
    			eldb.setReferenceId(refId);
    			eldb.setExceptionNum(Integer.parseInt(exNum));
    			eldb.setContextNum(i);
    			eldb.setContextType(contId);
    			eldb.setContextId(value);
    		}
    		errorLogDetailsBeanArr.add(eldb);
    	}    	
    }
    
    /**
     * This method persists error Logs.
     * @throws EJBException
     * @throws Exception
     */
    
    private void persistErrorLog() throws EJBException, Exception {/*
      
    	FwErrorLogBean[] logBean = {errorLogBean};
    	FwErrorLogDetailsBean[] logDetails = new FwErrorLogDetailsBean[errorLogDetailsBeanArr.size()];
    	errorLogDetailsBeanArr.toArray(logDetails);	
		
		try {
			FwErrorLogContextBO errorBO = new FwErrorLogContextBO(errorLogConnection);
			if (errorLogContextId != 0) {
				errorBO.persistErrorLog(logBean,logDetails,errorLogContextId);
			} else {
				errorLogContextId =  errorBO.persistErrorLog(errorLogContext,logBean,logDetails);			    
			}
			errorLogConnection.commit();
		} catch (Exception e) {
			errorLogConnection.rollback();			
		    System.out.println("Error while Persisting Error Log "+e);
		    e.printStackTrace();
		}
	*/}

    /**
     * Set Exception CommitSize: Please do not use this method 
     * until absolutely necessary. By default commitSize = 1
     * @param acommitSize int
     * @throws TIERSBatchException
     */
    public void setExceptionCommitSize(int acommitSize)
            throws TIERSBatchException {
        batchExcController.setExceptionCommitSize(acommitSize);
    }

    /**
     *This method returns the Run No of a given Job Id.
     * @param aJobId The identifier for the job
     * @return String returns the userid
     * @throws TIERSBatchException 
     */
    public static String getCreateUpdateUserId(String aJobId)
            throws TIERSBatchException {

        String createUpdateUserIdLocal = null;
        StringTokenizer stk = new StringTokenizer(aJobId, "-");
        StringBuffer sbf = new StringBuffer();
        while (stk.hasMoreTokens()) {
            sbf.append(stk.nextToken());
        }
        createUpdateUserIdLocal = sbf.toString();

        if (createUpdateUserIdLocal == null) {
            throw new TIERSBatchException("createUpdateUserId is NULL");
        }
        return createUpdateUserIdLocal;
    }

    /**
     * This method returns instance of batchFileController
     * @return BatchFileController returns instance of batchFileController
     * @throws TIERSBatchException
     */
    public BatchFileController getBatchFileControlHandle()
            throws TIERSBatchException {
        return bfcDAO;
    }

    /**
     * This method returns instance of fileAssember
     * @return FileAssembler returns instance of fileAssember
     * @throws TIERSBatchException
     */
    public FileAssembler getFileAssemblerHandle() throws TIERSBatchException {
        return fa;
    }

    /**
     * This method sort the files 
     * @param inputJobIds The identifiers for the jobIds
     * @param inpLogicalNamesDates input logicalNamesDates
     * @param outLogicalNames output LogicalNames
     * @return boolean returns true or false
     * @throws TIERSBatchException 
     */
    public boolean sortFiles(String[] inputJobIds,
            String[][] inpLogicalNamesDates, String[] outLogicalNames)
            throws TIERSBatchException {
        FileSorter fSorter = new FileSorter();
        boolean sortSuccessful = false;
        try {
            sortSuccessful = fSorter.sortFiles(jobId, inputJobIds,
                    inpLogicalNamesDates, outLogicalNames, env, this);

            return sortSuccessful;
        } catch (Exception ex) {
            throw new TIERSBatchException(ex.getMessage(), ex);
        }
    }

    /**
     * This method sort the files
     * @param aInputJobIds The identifiers for the jobIds
     * @param aInpLogicalNames input logical file Name
     * @param aOutLogicalNames output logical file Name
     * @return boolean returns true or false
     * @throws TIERSBatchException
     */
    public boolean sortFiles(String[] aInputJobIds, String[] aInpLogicalNames,
            String[] aOutLogicalNames) throws TIERSBatchException {
        FileSorter fSorter = new FileSorter();
        boolean sortSuccessful = false;
        String[][] inpLogicalFileNamesDates = new String[aInpLogicalNames.length][2];
        int inpLogicalFileNamesDatesLength = inpLogicalFileNamesDates.length;
        for (int i = 0; i < inpLogicalFileNamesDatesLength; i++) {
            inpLogicalFileNamesDates[i][0] = aInpLogicalNames[i];
            inpLogicalFileNamesDates[i][1] = formatDate(getAsOfDate(), "mm/dd/yyyy",
                    "mm-dd-yyyy");
        }

        try {
            sortSuccessful = fSorter.sortFiles(jobId, aInputJobIds,
                    inpLogicalFileNamesDates, aOutLogicalNames, env, this);
            return sortSuccessful;
        } catch (Exception ex) {
            throw new TIERSBatchException(ex.getMessage(), ex);
        }
    }

    /**
     * Schedule Jobs
     * @throws TIERSBatchException 
     */
    public void schedule() throws TIERSBatchException {
        bdsDAO.schedule(getTIERSBatchControllerConnection(), getAsOfDate());
    }

    /**
     * Schedule Jobs
     * @param eventID Id to be processed
     * @throws TIERSBatchException 
     */
    public void schedule(String eventID) throws TIERSBatchException {
        bdsDAO.schedule(getTIERSBatchControllerConnection(), getAsOfDate(),
                eventID, getChunkFactor());
    }

    /**
     * Get chunk factor
     * @return int
     */
	public int getChunkFactor() {
		try {
			if (chunkFactor == 1) {
				String depJobID = getDependentJobId();
				if (depJobID != null && !depJobID.trim().isEmpty()) {
					chunkFactor = getChunkFactor(depJobID); // chunk factor
															// should be kept on
															// the job that will
															// be chunked and
															// not on the pilot
															// job
				} else {
					return 1;
				}
			}
		} catch (Exception e) {
			throw new FwException(FwConstants.LOGGING_CATEGORY_FRAMEWORK,
					ILog.ERROR, e);
		}
		return chunkFactor;
	}

    /**
     * Get chunk factor
     * @param ajobId The identifier for the job
     * @return int returns count of records
     */
	public int getChunkFactor(String ajobId) {
		int lchunkFactor = 1;// chunk factor is 1 means that number of instances
								// will correspond to 1 workload
		String refValue = null;
		try {
			ReferenceTableReader refTableRead = ReferenceTableReader
					.getInstance();
			refValue = refTableRead.readReferenceTable(
					BatchConstants.RT_BATCH_JOB_CONTROL, ajobId,
					BatchConstants.RF_CHUNKFACTOR);
		} catch (Exception e) {
			throw new FwException(FwConstants.LOGGING_CATEGORY_FRAMEWORK,
					ILog.ERROR, e);
		}
		if (refValue != null && !refValue.trim().isEmpty()) {
			lchunkFactor = Integer.valueOf(refValue);
		} 
		return lchunkFactor;
	}

    /**
     * Gets the batchControllers
     * @return ITIERSBatchController
     */
    public static ITIERSBatchController getBatchControllers() {
        return batchController;
    }

    /**
     * This method gets the Processor Job Id
     * @return String returns dependent Job id
     * @throws TIERSBatchException 
     */
    public String getDependentJobId() throws TIERSBatchException {

        if (dependentJobId == null) {
            try {
                ReferenceTableReader refTableRead = ReferenceTableReader.getInstance();
                dependentJobId = refTableRead.readReferenceTable(BatchConstants.RT_BATCH_JOB_CONTROL, getJobId(),BatchConstants.RF_DEPENDENT_JOB);
            } catch (Exception e) {
                throw new TIERSBatchException(
                        "Error in getting dependent job Id from reference table: "+e.getMessage(), e);
            }
        }

        if (dependentJobId.trim().length() == 0) {

            FwBatchContextCargo params = new FwBatchContextCargo();
            int contextCommitSize = 0;
            params.setJobId(getJobId());
            params.setKeyColumn(BatchConstants.RF_DEPENDENT_JOB);

            FwBatchContextCargo[] fwBatchContextCargo = null;

            FwBatchContextCollection contextCollection = new FwBatchContextCollection(
                    getConnection());
            contextCollection.setCargo(params);
            try {
                fwBatchContextCargo = (FwBatchContextCargo[]) contextCollection
                        .select("findByCommitKey");
            } catch (Exception e) {
                throw new TIERSBatchException(
                        "Error While getting the Records from FW_batch_context Table"
                                + e.getMessage(), e);
            }

            if (fwBatchContextCargo != null && fwBatchContextCargo.length > 0)

                dependentJobId = fwBatchContextCargo[0].getJobKeyValue();

        }

        return dependentJobId;
    }

    /**
     * This method decides whether it needs to be a single FTP for the files
     * @return boolean returns true or false
     * @throws TIERSBatchException 
     */
  private boolean isSingleFTP(){
        if (gsingleFTP == BatchConstants.NOTAPPLICABLE) {
        	String refValue = null;
            try {
                ReferenceTableReader refTableRead = ReferenceTableReader
                        .getInstance();
                refValue = refTableRead.readReferenceTable(
                        BatchConstants.RT_BATCH_JOB_CONTROL, getJobId(),
                        BatchConstants.RF_SINGLE_FTP);
            } catch (Exception e) {
            	throw new FwException(FwConstants.LOGGING_CATEGORY_FRAMEWORK, ILog.ERROR, e);
            }
			if (refValue != null && !refValue.trim().isEmpty()) {
				gsingleFTP = refValue.toCharArray()[0];
			} else {
				return true;
			}
        }
        return (gsingleFTP == BatchConstants.YES);
    }

    /**
     * This method decides whether it needs to isLastParallelInstance
     * @return boolean returns true or false
     * @throws TIERSBatchException 
     */
    boolean isLastParallelInstance() throws TIERSBatchException {
        if (!glastInstance) {
            glastInstance = brcDAO.isLastParallelInstance(
                    getTIERSBatchControllerConnection(), getJobId(),
                    getAsOfDate(), getParallelRunNum());
        }
        return glastInstance;
    }

    /**
     * This method validates the MQ environment
     * @throws TIERSBatchException
     */
    private void validateMQManager() throws TIERSBatchException {
        try {
            FwMessageQueueValidator.validateBatchMQ();
        } catch (Exception e) {
            /*if the message is JMS exceptions, then skip it. If the batch job does not
             * need messaging, it can continue to run. If it needs, messaging, the job
             * will get authentication exception when it tries to send/receive messages, 
             * from FwMessageManager. If the exception is due to message authentication 
             * failure, throw TIERSBatchException and stop the job.
             */
            String message = e.getMessage();
            if (message.indexOf("Messaging environment authentication failed") > 0) {
                throw new TIERSBatchException(e.getMessage(), e);
            }
        }
    }
    
    /**
     * This method gets Max run num.
     * @param conn Batch Connection
     * @param ajobId The identifier for the job
     * @param asofDt Has the as of date of the job
     * @return long returns max. runNum
     * @throws TIERSBatchException
     */
    public long getMaxRunningNum(Connection conn, String jobId, String asOfDt)
            throws RecordNotExistsException, TIERSBatchException {

        long runNum = 0;
        runNum = brcDAO.getMaxRunningNum(conn, jobId, asOfDt);
        return runNum;

    }
    
    
    /**
     * This Method gets Max. RunNum from File Control 
     * @param conn Batch Connection
     * @param ajobId The identifier for the job
     * @param asofDt Has the as of date of the job
     * @return long returns max. runNum
     * @throws RecordNotExistsException 
     * @throws TIERSBatchException  
     */
    public long getMaxFileControlRunNum(Connection conn, String jobId, String asOfDt)
    throws RecordNotExistsException, TIERSBatchException {

        long runNum = 0;

    //    runNum = bfcDAO.getMaxRunNumOfAsOfDate(conn,jobId,"filename",asOfDt);

        //findByMaxRunNumOfAsOfDate

        return runNum;

    }
    
    // Added BY Gopi Gunda

    // Method add to insert a record into file control table used by RP and FM track 
    // Once PDF is created using JRC this table will be populated so that PDF will be sent to CPC only once 
    // by updating status cd after sending to CPC
    /**
     * This Method gets Max. RunNum from File Control 
     * @param reportId Id to be processed
     * @param runNum Has the run number of the particular run
     * @param fileId Id to be processed
     * @return boolean returns true or false 
     * @throws TIERSBatchException
     */
    public boolean insertIntoFileControl(String reportId, int runNum,
            long fileId) throws TIERSBatchException {

        boolean insertSuccessful = false;

        try {
            if (asOfDate == null) {
                asOfDate = bpcDAO.findAsOfDate(
                        getTIERSBatchControllerConnection(), jobId);
            }
        } catch (Exception ex) {
            throw new TIERSBatchException("Error in finding AsOfDate "
                    + ex.getMessage(), ex);
        }

        insertSuccessful = bfcDAO.insertIntoFileControlForRP(
                getTIERSBatchControllerConnection(), jobId, reportId, getAsOfDate(),
                runNum, createUpdateUserId, fileId);

        return insertSuccessful;

    }

    /**
     * This Method gets file
     * @param conn Batch Connection
     * @return long returns fileId
     * @throws TIERSBatchException
     */
    public long getFileId(Connection conn) throws TIERSBatchException{
    	

    	FwBatchFtpRunControlCargo[] params = { new FwBatchFtpRunControlCargo()};
    	FwBatchFtpRunControlCollection fwbftprCollection=null;
    	FwBatchFtpRunControlCargo[] retCargos = null;
    	try {
    		if (fwbftprCollection == null) {
    			fwbftprCollection = new FwBatchFtpRunControlCollection(conn);
    			fwbftprCollection.setEJBSupported(false);
    		}
    	
    		retCargos =
    			(FwBatchFtpRunControlCargo[]) fwbftprCollection.select(
    					"findByFileId",
    					params);

    				
    	}catch (Exception e) {
    		throw new TIERSBatchException(
    					"Error while getting FileID Information from FW_BATCH_FILE. " + e.getMessage(), e);		
    	}

    	
    	return retCargos[0].getFileId();
    	
    }
    
    /**
     * This Method inserts into ftp Run Control 
     * @param  fileId Id to be processed
     * @param  fileName name of the File to be processed
     * @param  CreateUserId userid to be processed
     * @return boolean returns fileId 
     * @throws TIERSBatchException
     * @throws ApplicationException
     * @throws FrameworkException  
     */
    public boolean insertIntoFtpRunControl( long fileId,String fileName, String CreateUserId) throws TIERSBatchException, ApplicationException, FrameworkException{
 		
 	boolean insertSuccessful = false;
 	bfcDAO.insertIntoFtpRunControl(getTIERSBatchControllerConnection(), fileName, CreateUserId, fileId);	
 	return insertSuccessful;
 	
 }
    
	/**
	 * This Method gets file
	 * 
	 * @param conn
	 *            Batch Connection
	 * @param jobId
	 *            The identifier for the job
	 * @param start
	 *            starttime for job
	 * @param end
	 *            endtime for job
	 * @return boolean returns true or false
	 * @throws ApplicationException
	 */
	public boolean ranSuccessfullyForGivenRange(Connection conn, String jobId,
			Timestamp start, Timestamp end) throws ApplicationException {

		boolean result = false;

		Object[] params = { jobId, start, end };

		FwBatchRunControlCollection batchRunControlCollection = new FwBatchRunControlCollection(
				conn);
		FwBatchRunControlCargo[] returnRunControlCargos;

		try {
			returnRunControlCargos = (FwBatchRunControlCargo[]) batchRunControlCollection
					.select("findBySuccessDateRange", params);

		} catch (Exception ex) {
			getLogger()
					.log(FwConstants.LOGGING_CATEGORY_FRAMEWORK,
							ILog.ERROR,
							"Error while reading from FW_BATCH_RUN_CONTROL with finder findBySuccessDateRange. Message: "
									+ ex.getMessage(), ex);
			throw new TIERSBatchException(
					"Error while reading from FW_BATCH_RUN_CONTROL with finder findBySuccessDateRange. Message: "
							+ ex.getMessage(), ex);
		}

		if (returnRunControlCargos != null && returnRunControlCargos.length > 0) {
			result = true;
		}

		return result;
	}
    

    /**
     * @return Returns the gsingleFTP.
     */
    public char getGsingleFTP() {
        return gsingleFTP;
    }
    /**
     * @param gsingleFTP The gsingleFTP to set.
     */
    public void setGsingleFTP(boolean flag) {
        if (flag == true){
        this.gsingleFTP = BatchConstants.YES;
    }else{
        this.gsingleFTP = BatchConstants.NO;
    }
  }

	/**
	 * This Method gets file Record Count
	 * 
	 * @param AbsFileName
	 *            absolute file name
	 * @return long returns record count of file
	 * @throws TIERSBatchException
	 */
	public long getFileRecordCount(String AbsFileName) throws TIERSBatchException {

		Process p = null;
		Runtime rt = null;
		int waitWC = -1;
		boolean wcSuccessful = false;
		StringBuffer sbf = new StringBuffer();
		String str1 = null;
		StringTokenizer stk = null;
		long recordCount = 0L;
		int count = 0;
		BufferedReader stdError = null;
		BufferedReader stdOut = null;
		
		try {
			
			while (count <= 5 && !wcSuccessful) {
				
				rt = Runtime.getRuntime();
				p = rt.exec("wc -l " + StringEscapeUtils.escapeSql(AbsFileName));
				waitWC = p.waitFor();
				
				if (waitWC != 0) {
				
					try {
						 stdError = new BufferedReader(new InputStreamReader(p.getErrorStream()));
						while ((stdError.readLine()) != null) {
							sbf.append(stdError.readLine());
							wcSuccessful = false;
						}
					} catch (IOException e) {
						throw new FwException(FwConstants.LOGGING_CATEGORY_FRAMEWORK, ILog.ERROR, e);
					}finally{
						stdError.close();
					}
					
				} else {
					stdOut = new BufferedReader(new InputStreamReader(p.getInputStream()));
					while ((str1 = stdOut.readLine()) != null) {
						stk = new StringTokenizer(str1);
					}					
				}
				String str = new String();

				Long longObject = null;
				if (stk != null) {
					while (stk.hasMoreTokens()) {
						str = stk.nextToken();
						break;
					}
				}
				longObject = new Long(str);
				recordCount = longObject.longValue();

				if (waitWC == 0) {
					wcSuccessful = true;
				}
				count++;
				Thread.sleep(1000);
			}
		} catch (Exception ex) {
			getLogger().log(FwConstants.LOGGING_CATEGORY_FRAMEWORK, ILog.ERROR,
					"Error in getFileRecordCount. Message: " + ex.getMessage(),	ex);
			throw new TIERSBatchException("Error in getFileRecordCount. Message: " + ex.getMessage(), ex);
		} finally {
			try {
				if(stdOut != null)
					stdOut.close();
			} catch (IOException ioe) {
				throw new TIERSBatchException(ioe);
			}
		}
		return recordCount;
	}
   
    /**
     * This Method gets file
     * @param AbsFileName absolute file name 
     * @return long returns record count of file 
     */
    public boolean setOutputFileRecordCount(String aLogicalFileName,
            String aAsOfDate, long aRecordCount, int runNum) throws TIERSBatchException {
        int runNo = 0;
        try {
            //runNo = getAdjustedMaximumRunNo();
            if (runNo > 0 ){
            runNo = getParallelRunNum();
            runNo--;
            }
            if (isParallelRunProgram()) {
                bfcDAO.lockOutputFiles(getTIERSBatchControllerConnection(),
                        getJobId(), getAsOfDate());
            }
           // System.err.println("LogicalFilename ="+aLogicalFileName);
            bfcDAO.updateFileControlRecordCount(
                    getTIERSBatchControllerConnection(), jobId,
                    aLogicalFileName, aAsOfDate, runNo, aRecordCount,
                    createUpdateUserId);
          //  System.err.println("Record Count TBC "+aRecordCount);
        //    System.err.println("Run Num = "+runNo);
            if (isParallelRunProgram()) {
                bfcDAO.unlockOutputFiles(getTIERSBatchControllerConnection(),
                        getJobId(), getAsOfDate());
            }
            return true;
        } catch (Exception ex) {
            throw new TIERSBatchException(
                    "Error in Updating File Control Record Count "
                            + ex.getMessage(), ex);
        }
    }
    
    /**
     * This method returns a boolean values
     * true if env is production false if test
     * @return boolean returns true or false
     * @throws TIERSBatchException
    */
    
    public boolean isEnvironmentProduction() throws TIERSBatchException {
		boolean isProdEnv = false;
		String env = null;
		env = getTIERSProperties().getProperty("SWSS_ENV");
		if (env == null || !env.equalsIgnoreCase("PROD")) {
			isProdEnv = false;
		} else {
			isProdEnv = true;
		}
		return isProdEnv;
	}
    
    
    /**
     * @param cargo passing values of FwBatchFileControlCargo
     * @return String returns fileName
     * @throws TIERSBatchException
     */
    
    public String getAbsoluteFileName(FwBatchFileControlCargo cargo) throws TIERSBatchException{
    	
    	StringBuffer sBFtpFilePath = new StringBuffer();
    	String aJobId = null;
    	String logicalFilename = null;
    	String inpFolder = null;    	    	
    	sBFtpFilePath = null;
		sBFtpFilePath = new StringBuffer();
		String FileName = null;
		String environment = getTIERSProperties().getProperty(
				BatchConstants.PROPERTY_TAG_ENVIRONMENT);
		String DOUBLE_BACKWARD_SLASH = "\\";
		String FORWARD_SLASH = "/";
		String localDirectory ;
		String absoluteFileName;
		

		aJobId = cargo.getJobId();

		logicalFilename = cargo.getLogicalFileName();

		String tempAsofdate = cargo.getAsOfDt()
				.toString().substring(0, 10);

		String runNumber = "run" + cargo.getRunNum();

		StringTokenizer st = new StringTokenizer(tempAsofdate, "-");

		String year = st.nextToken();

		String month = st.nextToken();

		String date = st.nextToken();

		String asofdate = month + "-" + date + "-" + year;

		String fileType = logicalFilename.substring(logicalFilename
				.length() - 3, logicalFilename.length());

		

		if (fileType.equals(BatchConstants.FILE_TYPE_DATA)) {
			inpFolder = BatchConstants.DIR_NAME_DATA;
		} else if (fileType.equals(BatchConstants.FILE_TYPE_REPORT)) {
			inpFolder = BatchConstants.DIR_NAME_REPORT;
		} else if (fileType.equals(BatchConstants.FILE_TYPE_SORT)) {
			inpFolder = BatchConstants.DIR_NAME_SORT;
		} else if (fileType.equals(BatchConstants.FILE_TYPE_TEMP)) {
			inpFolder = BatchConstants.DIR_NAME_TEMP;
		} else if (fileType.equals(BatchConstants.FILE_TYPE_PRINT)) {
			inpFolder = BatchConstants.DIR_NAME_PRINT;
		} else if (fileType.equals(BatchConstants.FILE_TYPE_SPLIT)) {
			inpFolder = BatchConstants.DIR_NAME_SPLIT;
		} else if (fileType.equals(BatchConstants.FILE_TYPE_MERGE)) {
			inpFolder = BatchConstants.DIR_NAME_MERGE;
		} else if (fileType.equals(BatchConstants.FILE_TYPE_LEGACY)) {
			inpFolder = BatchConstants.DIR_NAME_LEGACY;
		}

		if (TIERSBatchController.operatingSystem
				.equalsIgnoreCase("WINDOWS")) {
			sBFtpFilePath.append(environment);
			sBFtpFilePath.append(DOUBLE_BACKWARD_SLASH);
			sBFtpFilePath.append(aJobId.substring(0, 2).toLowerCase());
			sBFtpFilePath.append(DOUBLE_BACKWARD_SLASH);
			sBFtpFilePath.append(inpFolder);
			sBFtpFilePath.append(DOUBLE_BACKWARD_SLASH);
		} else {
			sBFtpFilePath.append(environment);
			sBFtpFilePath.append(FORWARD_SLASH);
			sBFtpFilePath.append(aJobId.substring(0, 2).toLowerCase());
			sBFtpFilePath.append(FORWARD_SLASH);
			sBFtpFilePath.append(inpFolder);
			sBFtpFilePath.append(FORWARD_SLASH);
		}

		localDirectory = sBFtpFilePath.toString();

		StringBuffer absSbFileName = new StringBuffer();
		absSbFileName.append(localDirectory);
		absSbFileName.append(aJobId);
		absSbFileName.append(".");
		absSbFileName.append(logicalFilename);
		absSbFileName.append("-");
		absSbFileName.append(asofdate);
		absSbFileName.append(".");
		absSbFileName.append(runNumber);
		
		absoluteFileName = absSbFileName.toString();

    	return absoluteFileName;
    }
    
    /**
     * @param cargo passing values of FwBatchFileControlCargo
     * @return String retuns meesage queue Name
     * @throws TIERSBatchException
     */
    public String getMessagingQueueName(String propName){
    	String messagingQueue = null;
    	messagingQueue=  MessagingProperty.getProperty(propName);
    	return messagingQueue;
    }
    
    // BRGUS00266110 - NaredlaS
    /**
     * This method returns the flat Y or N depening upon the batch day 0 entry
     * @param job_id batch job id
     * @return String retstart value Y or N
     */
	private String getBatchRestartFlag(String job_id) {
		
		FwBatchContextCargo params = new FwBatchContextCargo();
		String contextRestart = "N";
		params.setJobId(job_id);
		params.setKeyColumn("RESTART");

		FwBatchContextCargo[] fwBatchContextCargo = null;

		FwBatchContextCollection contextCollection;
		try {
			contextCollection = new FwBatchContextCollection(getConnection());
			contextCollection.setCargo(params);
			fwBatchContextCargo = (FwBatchContextCargo[]) contextCollection
					.select("findByCommitKey");

		} catch (Exception e) {
			throw new FwException(FwConstants.LOGGING_CATEGORY_FRAMEWORK, ILog.ERROR, e);
		}

		if (fwBatchContextCargo != null && fwBatchContextCargo.length > 0)
			contextRestart = fwBatchContextCargo[0].getJobKeyValue();

		return contextRestart;
	}

    // BRGUS00266110 - NaredlaS	
	/**
	 * This Method returns if a batch job has been aborted and can be restarted
	 * 
	 * @param jobId The identifier for the job
	 * @return boolean returns true or false
	 * @throws ApplicationException
	 */
	public boolean isProgramRestarted(String jobId) throws ApplicationException {

		boolean result = false;

		FwBatchRunControlCargo[] params = { new FwBatchRunControlCargo() };
		java.sql.Timestamp tAsofDate = DataFormatter.strDateToTimestamp(
				getAsOfDate(), "mm/dd/yyyy");
		params[0].setJobId(jobId);
		params[0].setParallelRunNum(getParallelRunNum());
		params[0].setAsOfDt(tAsofDate);

		FwBatchRunControlCollection batchRunControlCollection = new FwBatchRunControlCollection(
				getTIERSBatchControllerConnection());
		FwBatchRunControlCargo[] returnRunControlCargos;
		try {
			returnRunControlCargos = (FwBatchRunControlCargo[]) batchRunControlCollection
					.select("findByAbortStatusforParallelRunNum", params);
		} catch (Exception ex) {
			getLogger()
					.log(FwConstants.LOGGING_CATEGORY_FRAMEWORK,
							ILog.ERROR,
							"Error reading from FW_BATCH_RUN_CONTROL with finder findByAbortStatusforParallelRunNum. Message: "
									+ ex.getMessage(), ex);
			throw new TIERSBatchException(
					"Error reading from FW_BATCH_RUN_CONTROL with finder findByAbortStatusforParallelRunNum. Message: "
							+ ex.getMessage(), ex);
		}
		if (returnRunControlCargos != null
				&& returnRunControlCargos.length > 0
				&& "AB".equalsIgnoreCase(returnRunControlCargos[0]
						.getStatusCd())) {
			result = true;
		}
		return result;
	}

	/**
	 * this method searches for a given search pattern in the header text
	 * 
	 * @param physicalFileName
	 *            batch physical file name
	 * @param pattern
	 *            search pattern
	 * @param numberOfLines
	 *            number of lines that needs to be searched
	 * @return String
	 * @throws TIERSBatchException
	 */
	public String getHeaderText(String physicalFileName, String pattern,
			int numberOfLines) throws TIERSBatchException {

		StringBuffer command = new StringBuffer();
		String HEAD = " head ";
		String output = null;
		String env = getEnv();
		// BRGUS00269696 - file ext changed to ksh
		command.append(env);
		command.append("/fw/script/getTextFromFile.ksh ");
		command.append(physicalFileName);
		command.append(HEAD);
		command.append(pattern);
		command.append(" ");
		command.append(numberOfLines);

		try {
			output = (String) SystemOperator.getInstance()
					.execute(command.toString()).get(0);
		} catch (Exception ex) {
			getLogger().log(FwConstants.LOGGING_CATEGORY_FRAMEWORK, ILog.ERROR,
					"Error in tbc.getHeaderText. Message: " + ex.getMessage(),
					ex);
			throw new TIERSBatchException(
					"Error in tbc.getHeaderText. Message: " + ex.getMessage(), ex);
		}
		return output;
	}

	/**
	 * this method searches for a given search pattern in the trailer text
	 * @param physicalFileName batch physical file name 
	 * @param pattern search pattern
	 * @param numberOfLines number of lines that needs to be searched
	 * @return String
	 * @throws TIERSBatchException
	 */
	public String getTrailerText(String physicalFileName, String pattern,
			int numberOfLines) throws TIERSBatchException {

		StringBuffer command = new StringBuffer();
		String TAIL = " tail ";
		String output = null;
		String env = getEnv();
		// BRGUS00269696 - file ext changed to ksh

		command.append(env);
		command.append("/fw/script/getTextFromFile.ksh ");
		command.append(physicalFileName);
		command.append(TAIL);
		command.append(pattern);
		command.append(" ");
		command.append(numberOfLines);

		try {
			output = (String) SystemOperator.getInstance()
					.execute(command.toString()).get(0);
		} catch (Exception ex) {
			getLogger().log(FwConstants.LOGGING_CATEGORY_FRAMEWORK, ILog.ERROR,
					"Error in getTrailerText. Message: " + ex.getMessage(),
					ex);
			throw new TIERSBatchException(
					"Error in getTrailerText. Message: " + ex.getMessage(), ex);
		}
		return output;
	}
	
	/**
	 * This method writes the summary for a batch job execution.
	 * 
	 * @param ReadRecCnt
	 * @param ProcessedRecCnt
	 * @param ErrorRecCnt
	 * @throws TIERSBatchException
	 */
	public void insertSummaryRecord(Integer readRecCnt, Integer processedRecCnt, Integer errorRecCnt) throws TIERSBatchException {
		StringBuffer reportLinesBuffer = new StringBuffer();
		reportLinesBuffer.append("Read:").append(readRecCnt);
		reportLinesBuffer.append(" | Processed:").append(processedRecCnt);
		reportLinesBuffer.append(" | Error:").append(errorRecCnt);
		String reportLines[] = { reportLinesBuffer.toString() };
		String columnTypes[] = { BatchConstants.REPORT_TITLE };
		// generate the Summary Report
		batchController.generateReport(reportLines, columnTypes);
	}
	
	/**
	 * This method writes the summary for a batch job execution.
	 * 
	 * @param readRecCnt
	 * @param processedRecCnt
	 * @param unProcessedRecCnt
	 * @param errorRecCnt
	 * @param invalidCnt
	 * @param triggerCnt
	 * @throws TIERSBatchException
	 */
	public void insertSummaryInLtcImpactRecord(Integer readRecCnt, Integer processedRecCnt,Integer unProcessedRecCnt,
			Integer errorRecCnt,Integer invalidCnt,Integer triggerCnt) throws TIERSBatchException {
		StringBuffer reportLinesBuffer = new StringBuffer();
		reportLinesBuffer.append("Read:").append(readRecCnt);
		reportLinesBuffer.append(" | Invalid:").append(invalidCnt);
		reportLinesBuffer.append(" | Processed:").append(processedRecCnt);
		reportLinesBuffer.append(" | triggers:").append(triggerCnt);
		reportLinesBuffer.append(" | Skipped:").append(unProcessedRecCnt);
		reportLinesBuffer.append(" | Error:").append(errorRecCnt);
		String reportLines[] = { reportLinesBuffer.toString() };
		String columnTypes[] = { BatchConstants.REPORT_TITLE };
		// generate the Summary Report
		batchController.generateReport(reportLines, columnTypes);
	}
	
	/**
	 * This method writes the summary for a provider batch job execution.
	 * 
	 * @param readRecCnt
	 * @param processedRecCnt
	 * @param unProcessedRecCnt
	 * @param errorRecCnt
	 * @param delCount
	 * @throws TIERSBatchException
	 */
	public void insertSummaryInLtcProviderRecord(Integer readRecCnt, Integer processedRecCnt,Integer unProcessedRecCnt,
			Integer errorRecCnt,int delCount) throws TIERSBatchException {
		StringBuffer reportLinesBuffer = new StringBuffer();
		reportLinesBuffer.append("Read:").append(readRecCnt);
		reportLinesBuffer.append(" | Processed:").append(processedRecCnt);
		reportLinesBuffer.append(" | Skipped:").append(unProcessedRecCnt);
		reportLinesBuffer.append(" | Error:").append(errorRecCnt);
		reportLinesBuffer.append(" | Deleted:").append(delCount);
		String reportLines[] = { reportLinesBuffer.toString() };
		String columnTypes[] = { BatchConstants.REPORT_TITLE };
		// generate the Summary Report
		batchController.generateReport(reportLines, columnTypes);
	}

	protected ILog getLogger() {
		if (logger == null) {
			logger = (ILog) FwServiceFactory.getInstance().create(ILog.class);
		}
		return logger;
	}
	
	/**
	 * This method logs the number of connections closed into FW_BATCH_SUMMARY.
	 * 
	 * @throws TIERSBatchException
	 */
	public void logConnectionInfo() throws TIERSBatchException {

		int runNumber = this.getMaximumRunNo();
		int connectionPoolSize = 0;

		runNumber++;
		String temp_JobId = null;

		if (isLoadUtility) {
			temp_JobId = jobId.substring(0, 9) + "LDU";
		} else {
			temp_JobId = jobId;
		}

		connectionPoolSize = batchConnManager.getConnectionPoolSize();

		bsc.insertSummaryRecord(getTIERSBatchControllerConnection(),
				temp_JobId, getAsOfDate(), runNumber, ++batchSummaryRecordNum,
				"DB Connections Opened: " + connectionPoolSize + " | Closed: " + batchConnManager.getConnectionCount(),
				createUpdateUserId, programName, BatchConstants.REPORT_BODY,
				getParallelRunNum());

	}
	
    /**
     * This method returns the threshold value
     * @param jobId
     * @return Long thresholdValue
     */
	private String getThresholdValue(String jobId){
		FwBatchContextCargo params = new FwBatchContextCargo();
		params.setJobId(jobId);
		FwBatchContextCargo[] fwBatchContextCargo = null;

		FwBatchContextCollection contextCollection;
		try {
			contextCollection = new FwBatchContextCollection(getConnection());
			contextCollection.setCargo(params);
			fwBatchContextCargo = (FwBatchContextCargo[]) contextCollection.select("findThresholdByJobId");
			if(fwBatchContextCargo.length>0){
				return fwBatchContextCargo[0].getJobKeyValue();
			}
		} catch (Exception e) {
			throw new FwException(e.getMessage(), e);
		}
		
		return FwConstants.EMPTY_STRING;
	}
	
	private void checkFromPostProcess(){
		if(!fromPostProcess){
			for(StackTraceElement e: Thread.currentThread().getStackTrace()){
				if(e.getMethodName().equals("postProcess")){
					fromPostProcess = true;
					break;
				}
			}
		}
	}
	
	private Boolean isThresholdDataScanActivated(){
		return "true".equalsIgnoreCase(System.getProperty(FwConstants.THRESHOLD_DATA_SCAN));
	}

	private void checkStatusException(int statusCode, String exceptionCode) throws Exception{
		if(statusCode == BatchConstants.EXIT_FAILURE 
			|| BatchConstants.FATAL.equals(exceptionCode) 
			|| FWUtils.isFatalExceptionOccurred()
			|| (isThresholdDataScanActivated() && !BatchConstants.INFO.equals(exceptionCode))
		){
			
			String abortMessage = "";
			if(statusCode == BatchConstants.EXIT_FAILURE){
				TIERSBatchController.stop = true;
				getLogger().log(FwConstants.LOGGING_CATEGORY_FRAMEWORK, ILog.ERROR, "Threshold reached.");
				abortMessage = "Threshold reached. Exception count: "+batchExcController.numberOfExceptions;
			}
			if(BatchConstants.FATAL.equals(exceptionCode)){
				TIERSBatchController.stop = true;
				getLogger().log(FwConstants.LOGGING_CATEGORY_FRAMEWORK, ILog.ERROR, "Fatal exception. Exiting the batch. ");
			}
			if(FWUtils.isFatalExceptionOccurred()){
				TIERSBatchController.stop = true;
				getLogger().log(FwConstants.LOGGING_CATEGORY_FRAMEWORK, ILog.ERROR, "Fatal exception. Framework or TIERSRunTimeException");
				abortMessage = "Fatal exception. Framework or TIERSRunTimeException";
			}
			if(isThresholdDataScanActivated()){
				getLogger().log(FwConstants.LOGGING_CATEGORY_FRAMEWORK, ILog.ERROR, "Threshold Data Scan is activated.");
				if(StringUtils.isEmpty(abortMessage)) abortMessage = "Threshold Data Scan is activated.";
			}
			
			if(!fatalExceptionSaved && !BatchConstants.FATAL.equals(exceptionCode)){
				try {
					fatalExceptionSaved = true;
					writeExceptionRecord(BatchConstants.FATAL, "Batch Aborted", abortMessage, false);
				} catch (TIERSBatchException e) {
					throw new FwException(e);
				}
			}
			String multithread = System.getProperty(FwConstants.MULTITHREAD);
			if(!"true".equals(multithread)){
				checkFromPostProcess();
				if(!fromPostProcess && !redirectedPostProcess && !postProcessCalled){
					redirectedPostProcess = true;
					getConnection().rollback();
					postProcessAbortAndExit();
				}
			}
		}
	}
	
	private void postProcessAbortAndExit(){
		try {
			if(getCallerRef() instanceof AbstractBatch){
				getLogger().log(FwConstants.LOGGING_DEFAULT_CATEGORY, ILog.INFO, "Redirected to PostProcess");
				((AbstractBatch)getCallerRef()).callPostProcessMethod();
			}
		} catch (ApplicationException e1) {
			// PMD_Override - R6 - The functionality here is working as expected, we should not throw the exception and the next step is to abort the job.
        	PMDRules.markApprovedCatchBlock("R6");
			getLogger().log(FwConstants.LOGGING_CATEGORY_FRAMEWORK, ILog.ERROR, "Error while trying to execute postProcess() after redirection to exit." +e1.getMessage(), e1);
		}
		try {
			// PMD_Override - R7 - The functionality here is working as expected, we should abort the job in postPrcoessAbortAndExit method..
        	PMDRules.markApprovedStatement("R7");
			stop(BatchConstants.ABORT);
		} catch (ApplicationException e1) {
			// PMD_Override - R6 - The functionality here is working as expected, we should not throw the exception and the next step is to exit the job.
        	PMDRules.markApprovedCatchBlock("R6");
			getLogger().log(FwConstants.LOGGING_CATEGORY_FRAMEWORK, ILog.ERROR, "Error while trying to execute abort() after redirection to exit." +e1.getMessage(), e1);
		}
		getLogger().log(FwConstants.LOGGING_DEFAULT_CATEGORY, ILog.INFO, "Exit because of the threshold or fatal exception is logged.");
		// PMD_Override - R7 - The functionality here is working as expected, we should exit the job in postPrcoessAbortAndExit method..
    	PMDRules.markApprovedStatement("R7");
		System.exit(BatchConstants.EXIT_FAILURE);
	}


	public String getThresholdValue() {
		return thresholdValue;
	}
	
	/**
	 * This method grabs the Okta properties configured for the batch job.
	 */
	private void getOktaProperties() {	
		this.oktaAuthentication = "true".equals(batchProperty.getProperty(FwConstants.OKTA_AUTHENTICATION.toString()));
		this.employeeGroupId = batchProperty.getProperty(FwConstants.EMPLOYEE_GROUP_ID.toString());
		this.externalProviderGroupId = batchProperty.getProperty(FwConstants.EXTERNAL_PROVIDER_GROUP_ID.toString());
	}

	/**
	 * Returns if oktaAuthentication is enabled or not.
	 * 
	 * @return oktaAuthentication
	 */
	public boolean isOktaAuthentication() {
		return oktaAuthentication;
	}

	/**
	 * Returns the ID of the Okta Group for Employees.
	 *  
	 * @return employeeGroupId
	 */
	public String getEmployeeGroupId() {
		return employeeGroupId;
	}

	/**
	 * Returns the ID of the Okta Group for External Providers.
	 *  
	 * @return employeeGroupId
	 */
	public String getExternalProviderGroupId() {
		return externalProviderGroupId;
	}
	
	public void setParallelRunIdSEBT(String aparallelRunId) {
		 parallelRunProgram = BatchConstants.NOTAPPLICABLE;
    }

}