package gov.illinois.ies.data.oracle.cases;

import gov.illinois.framework.management.logging.ILog;
import gov.illinois.fw.batch.HelperClasses.BatchConstants;
import gov.illinois.fw.business.exceptions.TIERSRunTimeException;
import gov.illinois.fw.management.logger.Debug;
import gov.illinois.fw.management.logger.LogLevel;
import gov.illinois.fw.management.logger.Logger;
import gov.illinois.fw.persistence.connection.ConnectionManager;
import gov.illinois.ies.business.entities.cases.DcCasesCargo;
import gov.illinois.ies.business.entities.cases.DcCasesExtendedCargo;
import gov.illinois.ies.data.oracle.DAOHelper;
import gov.illinois.ies.data.oracle.eligibility.DateUtility;
import gov.illinois.ies.utils.FWUtils;
import gov.illinois.ies.utils.SQLQueryUtil;

import java.sql.Connection;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.sql.Timestamp;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Map;

import org.apache.commons.lang.StringUtils;


/**
 *The class <code> DcCasesDAO </code> provides access to DC_CASES
 * table for retrieval of data. The class contains methods (finders)
 * to retrieve data from the table using various search criteria.
 * <dl>
 * <dt>
 * <b>DcCasesDAO</b>
 * </dt>
 * </dl>
 * @author Deloitte
 * @version %Revision%
 *
 */

public class DcCasesDAO extends DcCasesGenDAO {

	/**
	 * Logger is used to log the messages to log file.
	 */
	private static final Logger logger=Logger.getInstance();

	/**
	 * Field batchClassName
	 * Used to store the current class name. 
	 */
	private final String CLASS_NAME = this.getClass().getName();
	
	private static final String SELECT_SQL_LGCSE_FILTER ="SELECT CASE_NUM,APP_RECVD_DT,OFFICE_NUM FROM DC_CASES";
	private static final String SELECT_SQL_A_LGCSE_FILTER="SELECT CASE_NUM,OFFICE_NUM FROM DC_CASES_A";
	
	/**
	 * Field calendar.
	 */
	java.util.Calendar calendar = new java.util.GregorianCalendar();
	/**
	 * Field date.
	 */
	java.util.Date date = calendar.getTime();
	/**
	 * Field sdf.
	 */
	java.text.SimpleDateFormat sdf = new java.text.SimpleDateFormat("MM/dd/yyyy");
	java.text.SimpleDateFormat sdfDB = new java.text.SimpleDateFormat("yyyy-MM-dd");
	/**
	 * Field dateStr.
	 */
	//String dateStrDB = sdfDB.format(date);
	String dateStrDB = new FWUtils().synchronizedFormat(date, sdfDB);
	
	private DAOHelper<DcCasesCargo> daoHelper = null;

	/**
	 * Constructor for DcCasesDAO.
	 */
	public DcCasesDAO() {
	}
	/**
	 *Constructor for DcCasesDAO.
	 * @param conn Connection*/
	public DcCasesDAO(Connection conn) {
		super(conn);
	}

	public DAOHelper<DcCasesCargo> getDaoHelper() {
		if (this.daoHelper == null) {
			this.daoHelper = new DAOHelper<DcCasesCargo>(this, "DC_CASES", DcCasesCargo.class, COLUMN_MAP);
			daoHelper.setDefaultSelectSQL(SELECT_SQL);
		}
		this.daoHelper.clearTemporalColumnMapping();
		return this.daoHelper;
	}

	/**
	 *Method findByCaseNum.
	 * This method is used to retreive records for a given case number
	 * @param maxRows int
	 * @param lCaseNum long
	 * @return DcCasesCargo[]
	 * @throws TIERSRunTimeException
	 */
	public DcCasesCargo[] findByCaseNum(int maxRows, long lCaseNum)
	throws TIERSRunTimeException {
		ArrayList v = new ArrayList();
		Connection conn = null;
		PreparedStatement statement = null;
		ResultSet rs = null;
		try {
			conn = getConnection();
			statement =
				conn.prepareStatement(
						SELECT_SQL + " Where CASE_NUM = ? " + " "+ " WITH UR ");
			statement.setLong(1, lCaseNum);
			rs = statement.executeQuery();
			int cnt = 0;
			//          while (rs.next() && cnt++ < maxRows) {
			//          BRGUS00102765 Ã¢â‚¬â€œ jampanip Ã¢â‚¬â€œ As Per QA Review Prefetch logic Changes
			while (cnt++ < maxRows && rs.next()) {
				DcCasesCargo row = new DcCasesCargo();
				getRowFromResultSet(row, rs);
				v.add(row);
			}
			DcCasesCargo colrows[] = new DcCasesCargo[v.size()];
			v.toArray(colrows);
			return colrows;
		} catch (SQLException e) {
			throw new TIERSRunTimeException(e.getMessage(), e);
		} finally {
			try {
				if (rs != null) {
					rs.close();
				}
			} catch (SQLException e) {
				throw new TIERSRunTimeException(
						e.getClass().getName() + " " + e.getMessage(), e);
			}
			try {
				if (statement != null) {
					statement.close();
				}
			} catch (SQLException e) {
				throw new TIERSRunTimeException(
						e.getClass().getName() + " " + e.getMessage(), e);
			}
			try {
				if (conn != null && getClose()) {
					conn.close();
				}
			} catch (SQLException e) {
				throw new TIERSRunTimeException(
						e.getClass().getName() + " " + e.getMessage(), e);
			}
		}
	}

	/**
	 *Method findCaseStatusCDsByCaseNum.
	 * This method is used to retrieve case status cds for a given case number
	 * @param maxRows int
	 * @param lCaseNum long
	 * @return DcCasesCargo[]
	 * @throws TIERSRunTimeException
	 */
	public DcCasesCargo[] findCaseStatusCDsByCaseNum(int maxRows, long lCaseNum)
	throws TIERSRunTimeException {
		ArrayList v = new ArrayList();
		Connection conn = null;
		PreparedStatement statement = null;
		ResultSet rs = null;
		try {
			conn = getConnection();
			statement =
				conn.prepareStatement(
						"SELECT CASE_STATUS_CD FROM DC_CASES Where CASE_NUM = ? WITH UR ");
			statement.setLong(1, lCaseNum);
			rs = statement.executeQuery();
			int cnt = 0;
			while (cnt++ < maxRows && rs.next()) {
				DcCasesCargo row = new DcCasesCargo(); 
				row.setCaseStatusCd(rs.getString("CASE_STATUS_CD"));
				v.add(row);
			}
			DcCasesCargo colrows[] = new DcCasesCargo[v.size()];
			v.toArray(colrows);
			return colrows;
		} catch (SQLException e) {
			throw new TIERSRunTimeException(e.getMessage(), e);
		} finally {
			try {
				if (rs != null) {
					rs.close();
				}
			} catch (SQLException e) {
				throw new TIERSRunTimeException(
						e.getClass().getName() + " " + e.getMessage(), e);
			}
			try {
				if (statement != null) {
					statement.close();
				}
			} catch (SQLException e) {
				throw new TIERSRunTimeException(
						e.getClass().getName() + " " + e.getMessage(), e);
			}
			try {
				if (conn != null && getClose()) {
					conn.close();
				}
			} catch (SQLException e) {
				throw new TIERSRunTimeException(
						e.getClass().getName() + " " + e.getMessage(), e);
			}
		}
	}
	
	/**
	 *Method findByCaseNum.
	 * This method is used to retreive records for a given case number
	 * @param maxRows int
	 * @param lCaseNum long
	 * @return DcCasesCargo[]
	 * @throws TIERSRunTimeException
	 */
	public DcCasesCargo[] findByCaseNumsListCaseChange(int maxRows, long[] casesList) throws TIERSRunTimeException {
		ArrayList v = new ArrayList();
		Connection conn = null;
		PreparedStatement statement = null;
		ResultSet rs = null;
		try {
			conn = getConnection();
			statement = conn.prepareStatement(SELECT_SQL + " Where CASE_NUM in( " + SQLQueryUtil.preparePlaceHolders(casesList.length) + 
											  " ) AND CASE_MODE_CD = 'IR' and USER_ACTION_CD = 'PC' WITH UR ");
			SQLQueryUtil.setValues(1, statement, casesList);
			rs = statement.executeQuery();
			int cnt = 0;
			while (cnt++ < maxRows && rs.next()) {
				DcCasesCargo row = new DcCasesCargo();
				getRowFromResultSet(row, rs);
				v.add(row);
			}
			DcCasesCargo colrows[] = new DcCasesCargo[v.size()];
			v.toArray(colrows);
			return colrows;
		} catch (SQLException e) {
			throw new TIERSRunTimeException(e.getMessage(), e);
		} finally {
			try {
				if (rs != null) {
					rs.close();
				}
			} catch (SQLException e) {
				throw new TIERSRunTimeException(e.getClass().getName() + " " + e.getMessage(), e);
			}
			try {
				if (statement != null) {
					statement.close();
				}
			} catch (SQLException e) {
				throw new TIERSRunTimeException(e.getClass().getName() + " " + e.getMessage(), e);
			}
			try {
				if (conn != null && getClose()) {
					conn.close();
				}
			} catch (SQLException e) {
				throw new TIERSRunTimeException(e.getClass().getName() + " " + e.getMessage(), e);
			}
		}
	}
	/**
	 *Method findByCaseNum.
	 * This method is used to retreive records for a given case number
	 * @param maxRows int
	 * @param lCaseNum long
	 * @return DcCasesCargo[]
	 * @throws TIERSRunTimeException
	 */
	public DcCasesCargo[] findByCaseNumsList(int maxRows, ArrayList<Long> caseNumLst)
	throws TIERSRunTimeException {
		ArrayList v = new ArrayList();
		Connection conn = null;
		PreparedStatement statement = null;
		ResultSet rs = null;
		
		try {
			maxRows = caseNumLst.size();
			conn = getConnection();
			String placeHolders = SQLQueryUtil.preparePlaceHolders(caseNumLst.size());
			statement =
				conn.prepareStatement(
						SELECT_SQL + " Where CASE_NUM in( "+placeHolders+" ) WITH UR ");
			
			//statement.setLong(1, lCaseNum);
			SQLQueryUtil.setValues(1, statement, caseNumLst.toArray());
			rs = statement.executeQuery();
			int cnt = 0;
			//          while (rs.next() && cnt++ < maxRows) {
			//          BRGUS00102765 Ã¢â‚¬â€œ jampanip Ã¢â‚¬â€œ As Per QA Review Prefetch logic Changes
			while (cnt++ < maxRows && rs.next()) {
				DcCasesCargo row = new DcCasesCargo();
				getRowFromResultSet(row, rs);
				v.add(row);
			}
			DcCasesCargo colrows[] = new DcCasesCargo[v.size()];
			v.toArray(colrows);
			return colrows;
		} catch (SQLException e) {
			throw new TIERSRunTimeException(e.getMessage(), e);
		} finally {
			try {
				if (rs != null) {
					rs.close();
				}
			} catch (SQLException e) {
				throw new TIERSRunTimeException(
						e.getClass().getName() + " " + e.getMessage(), e);
			}
			try {
				if (statement != null) {
					statement.close();
				}
			} catch (SQLException e) {
				throw new TIERSRunTimeException(
						e.getClass().getName() + " " + e.getMessage(), e);
			}
			try {
				if (conn != null && getClose()) {
					conn.close();
				}
			} catch (SQLException e) {
				throw new TIERSRunTimeException(
						e.getClass().getName() + " " + e.getMessage(), e);
			}
		}
	}
	
	//ILIES-236366: START: New method added to fetch only needed columns
	/**
	 *Method findStatusByCaseNum.
	 * This method is used to retrieve status code for a given case number.
	 * @param maxRows int
	 * @param cargo DcCasesCargo
	 * @return DcCasesCargo[]
	 * @throws TIERSRunTimeException
	 */
	public DcCasesCargo[] findStatusByCaseNum(int maxRows, DcCasesCargo cargo) throws TIERSRunTimeException {
		Debug.println("findStatusByCaseNum " + " maxRows= " + maxRows + " cargo=" + cargo);
		ArrayList v = new ArrayList();
		Connection conn = null;
		PreparedStatement statement = null;
		ResultSet rs = null;
		try {
			conn = getConnection();
			statement =	conn.prepareStatement("SELECT CASE_STATUS_CD FROM DC_CASES  WHERE (CASE_NUM = ?  ) WITH UR");
			statement.setLong(1, cargo.getCaseNum());
			rs = statement.executeQuery();
			int cnt = 0;
			while (cnt++ < maxRows && rs.next()) {
				DcCasesCargo row = new DcCasesCargo();
				row.setCaseStatusCd(rs.getString("CASE_STATUS_CD"));
				v.add(row);
			}
			DcCasesCargo colrows[] = new DcCasesCargo[v.size()];
			v.toArray(colrows);
			return colrows;
		} catch (SQLException e) {
			throw new TIERSRunTimeException(e.getMessage(), e);
		} finally {
			try {
				if (rs != null) {
					rs.close();
				}
			} catch (SQLException e) {
				throw new TIERSRunTimeException(
						e.getClass().getName() + " " + e.getMessage(), e);
			}
			try {
				if (statement != null) {
					statement.close();
				}
			} catch (SQLException e) {
				throw new TIERSRunTimeException(
						e.getClass().getName() + " " + e.getMessage(), e);
			}
			try {
				if (conn != null && getClose()) {
					conn.close();
				}
			} catch (SQLException e) {
				throw new TIERSRunTimeException(
						e.getClass().getName() + " " + e.getMessage(), e);
			}
		}
	}
	//ILIES-236366: END

	/**
	 * @param args
	 * @return inBatchTriggerCargoArray
	 * @throws TIERSRunTimeException
	 */
	public DcCasesCargo[] findByCaseNumByList(int maxRows, ArrayList caseNumList) throws TIERSRunTimeException {
		logger.Log(LogLevel.INFO,"Start DcCasesCargoDAO.findByCaseNumByList...");
		ArrayList v = new ArrayList();
		ResultSet rs = null;
		PreparedStatement statement = null;
		Connection conn = null;
		char authRepSwitch = 'Y';
		try {
			conn = connection;
			if (conn == null) {
				conn = ConnectionManager.getConnection();
			}

			String caseNums = ((String) caseNumList.get(0));
			String clause = "  WHERE CASE_NUM IN (" + caseNums + ") AND AUTH_REP_SW ='"
			+ authRepSwitch +"' WITH UR";

			statement = conn.prepareStatement(SELECT_SQL + clause);
			rs = statement.executeQuery();

			int cnt = 0;
			while (rs.next() && cnt++ < maxRows) {
				DcCasesCargo row = new DcCasesCargo();
				getRowFromResultSet(row, rs);
				v.add(row);
			}
			DcCasesCargo colrows[] = new DcCasesCargo[v.size()];
			v.toArray(colrows);

			logger.Log(LogLevel.INFO,"End DcCasesCargoDAO.findByCaseNumByList...");
			return colrows;
		} catch (Exception e) {
			throw new TIERSRunTimeException(e.getMessage(), e);

		} finally {
			try {
				if (rs != null) {
					rs.close();
				}
			} catch (SQLException e) {
				throw new TIERSRunTimeException(e.getClass().getName() + " "
						+ e.getMessage(), e);
			}
			try {
				if (statement != null) {
					statement.close();
				}
			} catch (SQLException e) {
				throw new TIERSRunTimeException(e.getClass().getName() + " "
						+ e.getMessage(), e);
			}
			try {
				if (conn != null && getClose()) {
					conn.close();
				}
			} catch (SQLException e) {
				throw new TIERSRunTimeException(e.getClass().getName() + " "
						+ e.getMessage(), e);
			}
		}

	}


	/**
	 *Method findByAppRcvdDT.
	 * This method is used to retreive records for a given case number
	 * @param maxRows int
	 * @param cargo DcCasesCargo
	 * @return DcCasesCargo[]
	 * @throws TIERSRunTimeException
	 */
	public DcCasesCargo[] findByAppRcvdDT(int maxRows, DcCasesCargo cargo)
	throws TIERSRunTimeException {
		Debug.println(
				"findByAppRcvdDT" + " maxRows= " + maxRows + " cargo=" + cargo);
		ArrayList v = new ArrayList();
		Connection conn = null;
		PreparedStatement statement = null;
		ResultSet rs = null;
		try {
			conn = getConnection();
			statement =
				conn.prepareStatement(SELECT_SQL + "  WHERE (CASE_NUM = ?) WITH UR");
			statement.setLong(1, cargo.getCaseNum());
			rs = statement.executeQuery();
			int cnt = 0;
			//          while (rs.next() && cnt++ < maxRows) {
			//          BRGUS00102765 Ã¢â‚¬â€œ jampanip Ã¢â‚¬â€œ As Per QA Review Prefetch logic Changes
			while (cnt++ < maxRows && rs.next()) {
				DcCasesCargo row = new DcCasesCargo();
				getRowFromResultSet(row, rs);
				v.add(row);
			}
			DcCasesCargo colrows[] = new DcCasesCargo[v.size()];
			v.toArray(colrows);
			return colrows;
		} catch (SQLException e) {
			throw new TIERSRunTimeException(e.getMessage(), e);
		} finally {
			try {
				if (rs != null) {
					rs.close();
				}
			} catch (SQLException e) {
				throw new TIERSRunTimeException(
						e.getClass().getName() + " " + e.getMessage(), e);
			}
			try {
				if (statement != null) {
					statement.close();
				}
			} catch (SQLException e) {
				throw new TIERSRunTimeException(
						e.getClass().getName() + " " + e.getMessage(), e);
			}
			try {
				if (conn != null && getClose()) {
					conn.close();
				}
			} catch (SQLException e) {
				throw new TIERSRunTimeException(
						e.getClass().getName() + " " + e.getMessage(), e);
			}
		}
	}

	/**
	 *Method findByCaseNum.
	 * This method is used to retreive records for a given case number.
	 * @param maxRows int
	 * @param cargo DcCasesCargo
	 * @return DcCasesCargo[]
	 * @throws TIERSRunTimeException
	 */
	public DcCasesCargo[] findByCaseNum(int maxRows, DcCasesCargo cargo)
	throws TIERSRunTimeException {
		Debug.println(
				"findByCaseNum " + " maxRows= " + maxRows + " cargo=" + cargo);
		ArrayList v = new ArrayList();
		Connection conn = null;
		PreparedStatement statement = null;
		ResultSet rs = null;
		try {
			conn = getConnection();
			statement =
				conn.prepareStatement(SELECT_SQL + "  WHERE (CASE_NUM = ?  ) WITH UR");
			statement.setLong(1, cargo.getCaseNum());
			rs = statement.executeQuery();
			int cnt = 0;
			//          while (rs.next() && cnt++ < maxRows) {
			//          BRGUS00102765 Ã¢â‚¬â€œ jampanip Ã¢â‚¬â€œ As Per QA Review Prefetch logic Changes
			while (cnt++ < maxRows && rs.next()) {
				DcCasesCargo row = new DcCasesCargo();
				getRowFromResultSet(row, rs);
				v.add(row);
			}
			DcCasesCargo colrows[] = new DcCasesCargo[v.size()];
			v.toArray(colrows);
			return colrows;
		} catch (SQLException e) {
			throw new TIERSRunTimeException(e.getMessage(), e);
		} finally {
			try {
				if (rs != null) {
					rs.close();
				}
			} catch (SQLException e) {
				throw new TIERSRunTimeException(
						e.getClass().getName() + " " + e.getMessage(), e);
			}
			try {
				if (statement != null) {
					statement.close();
				}
			} catch (SQLException e) {
				throw new TIERSRunTimeException(
						e.getClass().getName() + " " + e.getMessage(), e);
			}
			try {
				if (conn != null && getClose()) {
					conn.close();
				}
			} catch (SQLException e) {
				throw new TIERSRunTimeException(
						e.getClass().getName() + " " + e.getMessage(), e);
			}
		}
	}
	
	public DcCasesCargo[] findByCaseInfo(int maxRows, DcCasesCargo cargo)
	throws TIERSRunTimeException {
		Debug.println(
				"findByCaseNum " + " maxRows= " + maxRows + " cargo=" + cargo);
		ArrayList v = new ArrayList();
		Connection conn = null;
		PreparedStatement statement = null;
		ResultSet rs = null;
		try {
			conn = getConnection();
			statement =
				conn.prepareStatement("SELECT CASE_MODE_CD, CASE_STATUS_CD, OFFICE_NUM,USER_ACTION_CD  FROM DC_CASES " + "  WHERE (CASE_NUM = ?  ) WITH UR");
			statement.setLong(1, cargo.getCaseNum());
			rs = statement.executeQuery();
			int cnt = 0;
			//          while (rs.next() && cnt++ < maxRows) {
			//          BRGUS00102765 â€“ jampanip â€“ As Per QA Review Prefetch logic Changes
			while (cnt++ < maxRows && rs.next()) {
				DcCasesCargo row = new DcCasesCargo();

				row.setCaseModeCd(rs.getString("CASE_MODE_CD"));
				row.setCaseStatusCd(rs.getString("CASE_STATUS_CD"));
				row.setOfficeNum(rs.getLong("OFFICE_NUM"));
				row.setUserActionCd(rs.getString("USER_ACTION_CD"));

				//	getRowFromResultSet(row, rs);
				v.add(row);
			}
			DcCasesCargo colrows[] = new DcCasesCargo[v.size()];
			v.toArray(colrows);
			return colrows;
		} catch (SQLException e) {
			throw new TIERSRunTimeException(e.getMessage(), e);
		} finally {
			try {
				if (rs != null) {
					rs.close();
				}
			} catch (SQLException e) {
				throw new TIERSRunTimeException(
						e.getClass().getName() + " " + e.getMessage(), e);
			}
			try {
				if (statement != null) {
					statement.close();
				}
			} catch (SQLException e) {
				throw new TIERSRunTimeException(
						e.getClass().getName() + " " + e.getMessage(), e);
			}
			try {
				if (conn != null && getClose()) {
					conn.close();
				}
			} catch (SQLException e) {
				throw new TIERSRunTimeException(
						e.getClass().getName() + " " + e.getMessage(), e);
			}
		}
	}
	
	/**
	 *Method findByCaseNumWithoutUr.
	 * This method is used to retrieve only committed records for a given case number.
	 * @param maxRows int
	 * @param cargo DcCasesCargo
	 * @return DcCasesCargo[]
	 * @throws TIERSRunTimeException
	 */
	public DcCasesCargo[] findByCaseNumWithoutUr(int maxRows, DcCasesCargo cargo)
	throws TIERSRunTimeException {
		Debug.println(
				"findByCaseNumWithoutUr " + " maxRows= " + maxRows + " cargo=" + cargo);
		ArrayList v = new ArrayList();
		Connection conn = null;
		PreparedStatement statement = null;
		ResultSet rs = null;
		try {
			conn = getConnection();
			statement =
				conn.prepareStatement(SELECT_SQL + "  WHERE CASE_NUM = ? WITH UR");
			statement.setLong(1, cargo.getCaseNum());
			rs = statement.executeQuery();
			int cnt = 0;
			
			while (cnt++ < maxRows && rs.next()) {
				DcCasesCargo row = new DcCasesCargo();
				getRowFromResultSet(row, rs);
				v.add(row);
			}
			DcCasesCargo colrows[] = new DcCasesCargo[v.size()];
			v.toArray(colrows);
			return colrows;
		} catch (SQLException e) {
			throw new TIERSRunTimeException(e.getMessage(), e);
		} finally {
			try {
				if (rs != null) {
					rs.close();
				}
			} catch (SQLException e) {
				throw new TIERSRunTimeException(
						e.getClass().getName() + " " + e.getMessage(), e);
			}
			try {
				if (statement != null) {
					statement.close();
				}
			} catch (SQLException e) {
				throw new TIERSRunTimeException(
						e.getClass().getName() + " " + e.getMessage(), e);
			}
			try {
				if (conn != null && getClose()) {
					conn.close();
				}
			} catch (SQLException e) {
				throw new TIERSRunTimeException(
						e.getClass().getName() + " " + e.getMessage(), e);
			}
		}
	}

	/**
	 * Gets the case's phone-numbers
	 * 
	 * @param maxRows
	 * @param caseNumber
	 * @return
	 * @throws TIERSRunTimeException
	 */
	public DcCasesCargo[] findInfo(int maxRows, long caseNumber) throws TIERSRunTimeException {
		String finderName = "findInfo";
		logger.Log(LogLevel.INFO, "In " + finderName + " method, before query.");

		DcCasesCargo[] colrows = null;
		try {
			StringBuilder selectQuery = new StringBuilder()
					.append("SELECT WORK_PH_NUM_EXT ,MSG_PHN_NUM ,OTHER_PH_NUM ,WORK_PH_NUM ,PH_NUM, OFFICE_NUM")
					.append(" FROM DC_CASES WHERE CASE_NUM=? WITH UR");

			int index = 1;
			Map<Integer, Object> parameters = new HashMap<Integer, Object>();
			parameters.put(index++, caseNumber);

			colrows = getDaoHelper().find(maxRows, selectQuery.toString(), parameters, true);
		} catch (TIERSRunTimeException e) {
			logger.Log(LogLevel.INFO, " Exception in finder " + finderName);
			throw new TIERSRunTimeException(e);
		}
		return colrows;
	}

	/**
	 * Finds the communication preferences, from DC_INDV_COM_PREF, for a given case number
	 * 
	 * @param maxRows
	 * @param caseNumber
	 * @return
	 * @throws TIERSRunTimeException
	 */
	public DcCasesCargo[] findByCaseNumAndComPref(int maxRows, long caseNumber) throws TIERSRunTimeException {
		String finderName = "findByCaseNumAndComPref";
		logger.Log(LogLevel.INFO, "In " + finderName + " method, before query.");

		DcCasesCargo[] colrows = null;
		try {
			StringBuilder selectQuery = new StringBuilder()
					.append("SELECT CASES.CASE_NUM, CASES.OFFICE_NUM,")
					.append(" 	CASE WHEN PREF.LANG_CD IS NOT NULL THEN PREF.LANG_CD ")
					.append(" 	ELSE CASES.LANGUAGE_CD ")
					.append(" 	END AS LANGUAGE_CD,")
					.append(" 	CASE WHEN PREF.PREF_TYPE_CD IS NOT NULL THEN PREF.PREF_TYPE_CD")
					.append(" 	ELSE CASES.NOTICE_METHOD_CD")
					.append(" 	END AS NOTICE_METHOD_CD")
					.append(" FROM DC_CASES CASES")
					.append(" RIGHT JOIN DC_HEAD_OF_HOUSEHOLD HOH ON HOH.CASE_NUM=CASES.CASE_NUM AND HOH.HOH_END_DT IS NULL")
					.append(" LEFT JOIN DC_INDV_COM_PREF PREF ON PREF.INDV_ID=HOH.INDV_ID")
					.append(" WHERE CASES.CASE_NUM=?")
					.append(" WITH UR");

			int index = 1;
			Map<Integer, Object> parameters = new HashMap<Integer, Object>();
			parameters.put(index++, caseNumber);

			colrows = getDaoHelper().find(maxRows, selectQuery.toString(), parameters, true);

		} catch (TIERSRunTimeException e) {
			logger.Log(LogLevel.INFO, " Exception in finder " + finderName);
			throw new TIERSRunTimeException(e);
		}
		return colrows;
	}
	
	/**
	 * Finds the LANGUAGE_CD and communication preferences, from DC_CASE,
	 * DC_INDV_COM_PREF, give the precedence to DC_CASE LANGUAGE_CD for a given
	 * case number
	 * 
	 * @param maxRows
	 * @param caseNumber
	 * @return
	 * @throws TIERSRunTimeException
	 */
	public DcCasesCargo[] findByCaseNumFromDCCaseComPref(int maxRows, long caseNumber) throws TIERSRunTimeException {
		String finderName = "findByCaseNumFromDCCaseComPref";
		logger.Log(LogLevel.INFO, "In " + finderName + " method, before query.");

		DcCasesCargo[] colrows = null;
		try {
			StringBuilder selectQuery = new StringBuilder()
					.append("SELECT CASES.CASE_NUM, CASES.OFFICE_NUM,")
					.append(" 	CASE WHEN CASES.LANGUAGE_CD IS NOT NULL THEN CASES.LANGUAGE_CD ")
					.append(" 	ELSE PREF.LANG_CD")
					.append(" 	END AS LANGUAGE_CD,")
					.append(" 	CASE WHEN PREF.PREF_TYPE_CD IS NOT NULL THEN PREF.PREF_TYPE_CD")
					.append(" 	ELSE CASES.NOTICE_METHOD_CD")
					.append(" 	END AS NOTICE_METHOD_CD")
					.append(" FROM DC_CASES CASES")
					.append(" RIGHT JOIN DC_HEAD_OF_HOUSEHOLD HOH ON HOH.CASE_NUM=CASES.CASE_NUM AND HOH.HOH_END_DT IS NULL")
					.append(" LEFT JOIN DC_INDV_COM_PREF PREF ON PREF.INDV_ID=HOH.INDV_ID")
					.append(" WHERE CASES.CASE_NUM=?")
					.append(" WITH UR");

			int index = 1;
			Map<Integer, Object> parameters = new HashMap<Integer, Object>();
			parameters.put(index++, caseNumber);

			colrows = getDaoHelper().find(maxRows, selectQuery.toString(), parameters, true);

		} catch (TIERSRunTimeException e) {
			logger.Log(LogLevel.INFO, " Exception in finder " + finderName);
			throw new TIERSRunTimeException(e);
		}
		return colrows;
	}

	/**
	 * Created by Munther for Performance team Method findByCaseNum. This method
	 * is used to retrieve records for a given case number.
	 * 
	 * @param maxRows
	 *            int
	 * @param cargo
	 *            DcCasesCargo
	 * @return DcCasesCargo[]
	 * @throws TIERSRunTimeException
	 */
	public DcCasesCargo[] findCasePhoneByCaseNum(int maxRows, DcCasesCargo cargo) throws TIERSRunTimeException {
//		Debug.println("findByCaseNum " + " maxRows= " + maxRows + " cargo=" + cargo);
		ArrayList v = new ArrayList();
		Connection conn = null;
		PreparedStatement statement = null;
		ResultSet rs = null;
		try {
			conn = getConnection();
			statement = conn.prepareStatement("SELECT CASE_NUM,PH_NUM,WORK_PH_NUM,OTHER_PH_NUM,MSG_PHN_NUM,WORK_PH_NUM_EXT FROM DC_CASES WHERE CASE_NUM = ? WITH UR");
			statement.setLong(1, cargo.getCaseNum());
			rs = statement.executeQuery();
			int cnt = 0;
			while (cnt++ < maxRows && rs.next()) {
				DcCasesCargo row = new DcCasesCargo();
				row.setCaseNum(rs.getLong("CASE_NUM"));
				row.setPhNum(rs.getString("PH_NUM"));
				row.setWorkPhNum(rs.getString("WORK_PH_NUM"));
				row.setWorkPhNumExt(rs.getLong("WORK_PH_NUM_EXT"));
				row.setOtherPhNum(rs.getString("OTHER_PH_NUM"));
				row.setMsgPhnNum(rs.getString("MSG_PHN_NUM"));
				v.add(row);
			}
			DcCasesCargo colrows[] = new DcCasesCargo[v.size()];
			v.toArray(colrows);
			return colrows;
		} catch (SQLException e) {
			throw new TIERSRunTimeException(e.getMessage(), e);
		} finally {
			try {
				if (rs != null) {
					rs.close();
				}
			} catch (SQLException e) {
				throw new TIERSRunTimeException(
						e.getClass().getName() + " " + e.getMessage(), e);
			}
			try {
				if (statement != null) {
					statement.close();
				}
			} catch (SQLException e) {
				throw new TIERSRunTimeException(
						e.getClass().getName() + " " + e.getMessage(), e);
			}
			try {
				if (conn != null && getClose()) {
					conn.close();
				}
			} catch (SQLException e) {
				throw new TIERSRunTimeException(
						e.getClass().getName() + " " + e.getMessage(), e);
			}
		}
	}

	/**
	 * Method findByCaseNumsForOffice.
	 * This method is used to find the records for the given case numbers
	 * @param maxRows int
	 * @param caseNumbers String
	 * @return DcCasesCargo[]
	 * @throws TIERSRunTimeException
	 */
	public DcCasesCargo[] findByCaseNumsForOfficeId(int maxRows, String caseNum)
	throws TIERSRunTimeException {
		ArrayList v = new ArrayList();
		Connection conn = null;
		PreparedStatement statement = null;
		ResultSet rs = null;

		try {
			Debug.println("Inside method findByCaseNumsForOffice");

			conn = getConnection();
			statement = conn.prepareStatement("SELECT OFFICE_NUM FROM DC_CASES WHERE CASE_NUM = ?  WITH UR");
			statement.setString(1, caseNum);
			rs = statement.executeQuery();
			int cnt = 0;
			while (cnt++ < maxRows && rs.next()) {
				DcCasesCargo row = new DcCasesCargo();
				row.setOfficeNum(rs.getLong("OFFICE_NUM"));
				v.add(row);
			}

			DcCasesCargo colrows[] = new DcCasesCargo[v.size()];
			v.toArray(colrows);
			Debug.println("Exiting method findByCaseNumsForOfficeId");
			return colrows;

		} catch (SQLException e) {
			throw new TIERSRunTimeException(e.getMessage());
		} finally {
			try {
				if (rs != null) {
					rs.close();
				}
			} catch (SQLException e) {
				throw new TIERSRunTimeException(e.getClass().getName() + " "
						+ e.getMessage());
			}
			try {
				if (statement != null) {
					statement.close();
				}
			} catch (SQLException e) {
				throw new TIERSRunTimeException(e.getClass().getName() + " "
						+ e.getMessage());
			}
			try {
				if (conn != null && getClose()) {
					conn.close();
				}
			} catch (SQLException e) {
				throw new TIERSRunTimeException(e.getClass().getName() + " "
						+ e.getMessage());
			}
		}
	}

	/**
	 *Method findByInvestigationArchivalData.
	 * This method is used to retreive records for a given set of data
	 * @param maxRows int
	 * @param cargo DcCasesCargo
	 * @return DcCasesCargo[]
	 * @throws TIERSRunTimeException
	 */
	public DcCasesCargo[] findByInvestigationArchivalData(
			int maxRows,
			DcCasesCargo cargo)
	throws TIERSRunTimeException {
		Debug.println(
				" findByInvestigationArchivalData "
				+ " maxRows= "
				+ maxRows
				+ " cargo="
				+ cargo);
		ArrayList v = new ArrayList();
		Connection conn = null;
		PreparedStatement statement = null;
		ResultSet rs = null;
		try {
			conn = getConnection();
			statement =
				conn.prepareStatement(
						SELECT_SQL
						+ " WHERE CASE_NUM= ? AND ARCHIVE_DT IS NOT NULL WITH UR");
			statement.setLong(1, cargo.getCaseNum());
			rs = statement.executeQuery();
			int cnt = 0;
			//          while (rs.next() && cnt++ < maxRows) {
			//          BRGUS00102765 Ã¢â‚¬â€œ jampanip Ã¢â‚¬â€œ As Per QA Review Prefetch logic Changes
			while (cnt++ < maxRows && rs.next()) {
				DcCasesCargo row = new DcCasesCargo();
				getRowFromResultSet(row, rs);
				v.add(row);
			}
			statement.close();
			statement =
				conn.prepareStatement(
						SELECT_SQL_A
						+ " WHERE CASE_NUM= ? AND ARCHIVE_DT IS NOT NULL WITH UR");
			statement.setLong(1, cargo.getCaseNum());
			rs = statement.executeQuery();
			cnt = 0;
			//          while (rs.next() && cnt++ < maxRows) {
			//          BRGUS00102765 Ã¢â‚¬â€œ jampanip Ã¢â‚¬â€œ As Per QA Review Prefetch logic Changes
			while (cnt++ < maxRows && rs.next()) {
				DcCasesCargo row = new DcCasesCargo();
				getAuditRowFromResultSet(row, rs);
				v.add(row);
			}
			DcCasesCargo colrows[] = new DcCasesCargo[v.size()];
			v.toArray(colrows);
			return colrows;
		} catch (SQLException e) {
			throw new TIERSRunTimeException(e.getMessage(), e);
		} finally {
			try {
				if (rs != null) {
					rs.close();
				}
			} catch (SQLException e) {
				throw new TIERSRunTimeException(
						e.getClass().getName() + " " + e.getMessage(), e);
			}
			try {
				if (statement != null) {
					statement.close();
				}
			} catch (SQLException e) {
				throw new TIERSRunTimeException(
						e.getClass().getName() + " " + e.getMessage(), e);
			}
			try {
				if (conn != null && getClose()) {
					conn.close();
				}
			} catch (SQLException e) {
				throw new TIERSRunTimeException(
						e.getClass().getName() + " " + e.getMessage(), e);
			}
		}
	}

	public DcCasesCargo[] findByCustParam(int maxRows, String firstName,String lastName,String middleName,String prefixName,String suffixName)
	throws TIERSRunTimeException {
		Debug.println(
				"findByCustParam " + " maxRows= " + maxRows);
		ArrayList v = new ArrayList();
		Connection conn = null;
		PreparedStatement statement = null;
		ResultSet rs = null;
		try {
			conn = getConnection();
			StringBuffer sbfSearchClause = new StringBuffer();
			sbfSearchClause.append(" SELECT DISTINCT(DC.CASE_NUM) FROM BRG_OWNER.DC_INDV DI INNER JOIN BRG_OWNER.DC_CASE_INDIVIDUAL DC ON DC.INDV_ID = DI.INDV_ID ");
			sbfSearchClause.append((lastName == null || lastName.equals("")) ? "" : " AND UPPER(DI.LAST_NAME) LIKE UPPER('"+ lastName + "%')");
			sbfSearchClause.append((firstName == null || firstName.equals("")) ? "" : " AND UPPER(DI.FIRST_NAME) LIKE UPPER('"	+ firstName + "%')");
			sbfSearchClause.append((middleName == null || middleName.equals("")) ? "" : " AND UPPER(DI.MID_NAME) LIKE UPPER( '"+ middleName + "%')");
			sbfSearchClause.append((prefixName == null || prefixName.equals("")) ? "" : " AND UPPER(DI.PREFIX_NAME) LIKE UPPER( '"+ prefixName + "%')");
			sbfSearchClause.append((suffixName == null || suffixName.equals("")) ? "" : " AND UPPER(DI.SUFX_NAME) LIKE UPPER( '"+ suffixName + "%')");
			sbfSearchClause.append(" WITH UR");
			statement =	conn.prepareStatement(sbfSearchClause.toString());
			rs = statement.executeQuery();
			int cnt = 0;
			while (cnt++ < maxRows && rs.next()) {
				DcCasesCargo row = new DcCasesCargo();
				row.setCaseNum(rs.getLong("CASE_NUM"));
				v.add(row);
			}
			DcCasesCargo colrows[] = new DcCasesCargo[v.size()];
			v.toArray(colrows);
			return colrows;
		} catch (SQLException e) {
			throw new TIERSRunTimeException(e.getMessage(), e);
		} finally {
			try {
				if (rs != null) {
					rs.close();
				}
			} catch (SQLException e) {
				throw new TIERSRunTimeException(
						e.getClass().getName() + " " + e.getMessage(), e);
			}
			try {
				if (statement != null) {
					statement.close();
				}
			} catch (SQLException e) {
				throw new TIERSRunTimeException(
						e.getClass().getName() + " " + e.getMessage(), e);
			}
			try {
				if (conn != null && getClose()) {
					conn.close();
				}
			} catch (SQLException e) {
				throw new TIERSRunTimeException(
						e.getClass().getName() + " " + e.getMessage(), e);
			}
		}
	}
	
	/**
	 *Method findByArchivalCases.
	 * This method is used to retreve records for a given set of data.
	 * @param maxRows int
	 * @param cargo DcCasesCargo
	 * @return DcCasesCargo[]
	 * @throws TIERSRunTimeException
	 */
	public DcCasesCargo[] findByArchivalCases(int maxRows, DcCasesCargo cargo)
	throws TIERSRunTimeException {
		Debug.println(
				" findByArchivalCases "
				+ " maxRows= "
				+ maxRows
				+ " cargo="
				+ cargo);
		ArrayList v = new ArrayList();
		Connection conn = null;
		PreparedStatement statement = null;
		ResultSet rs = null;
		try {
			conn = getConnection();
			statement =
				conn.prepareStatement(
						SELECT_SQL
						+ " WHERE CASE_CLOSED_DT <= ? AND CASE_STATUS_CD = ? WITH UR");

			Debug.println(
			"DcCaseAddressesDAO-findByArchivalCases() : WHERE clause :  WHERE CASE_CLOSED_DT <= ? AND CASE_STATUS_CD = ?  ");
			//statement.setLong(1, cargo.getCaseNum());
			//statement.setTimestamp(2, cargo.getUpdateDt());
			statement.setTimestamp(1, cargo.getCaseClosedDt());
			statement.setString(2, cargo.getCaseStatusCd());
			rs = statement.executeQuery();
			int cnt = 0;
			//          while (rs.next() && cnt++ < maxRows) {
			//          BRGUS00102765 Ã¢â‚¬â€œ jampanip Ã¢â‚¬â€œ As Per QA Review Prefetch logic Changes
			while (cnt++ < maxRows && rs.next()) {
				DcCasesCargo row = new DcCasesCargo();
				getRowFromResultSet(row, rs);
				v.add(row);
			}
			statement.close();
			statement =
				conn.prepareStatement(
						SELECT_SQL_A
						+ " WHERE CASE_CLOSED_DT <= ? AND CASE_STATUS_CD = ? WITH UR");

			Debug.println(
			"DcCaseAddressesDAO-findByArchivalCases() : WHERE clause :  WHERE CASE_CLOSED_DT <= ? AND CASE_STATUS_CD = ?  ");
			//statement.setLong(1, cargo.getCaseNum());
			//statement.setTimestamp(2, cargo.getUpdateDt());
			statement.setTimestamp(1, cargo.getCaseClosedDt());
			statement.setString(2, cargo.getCaseStatusCd());
			rs = statement.executeQuery();
			cnt = 0;
			//          while (rs.next() && cnt++ < maxRows) {
			//          BRGUS00102765 Ã¢â‚¬â€œ jampanip Ã¢â‚¬â€œ As Per QA Review Prefetch logic Changes
			while (cnt++ < maxRows && rs.next()) {
				DcCasesCargo row = new DcCasesCargo();
				getAuditRowFromResultSet(row, rs);
				v.add(row);
			}
			DcCasesCargo colrows[] = new DcCasesCargo[v.size()];
			v.toArray(colrows);
			return colrows;
		} catch (SQLException e) {
			throw new TIERSRunTimeException(e.getMessage(), e);
		} finally {
			try {
				if (rs != null) {
					rs.close();
				}
			} catch (SQLException e) {
				throw new TIERSRunTimeException(
						e.getClass().getName() + " " + e.getMessage(), e);
			}
			try {
				if (statement != null) {
					statement.close();
				}
			} catch (SQLException e) {
				throw new TIERSRunTimeException(
						e.getClass().getName() + " " + e.getMessage(), e);
			}
			try {
				if (conn != null && getClose()) {
					conn.close();
				}
			} catch (SQLException e) {
				throw new TIERSRunTimeException(
						e.getClass().getName() + " " + e.getMessage(), e);
			}
		}
	}

	/**
	 *Method findByNextCaseNum.
	 * This method is used to retreive records for a given case number
	 * @param maxRows int
	 * @param cargo DcCasesCargo
	 * @return DcCasesCargo[]
	 * @throws TIERSRunTimeException
	 */
	public DcCasesCargo[] findByNextCaseNum(int maxRows, DcCasesCargo cargo)
	throws TIERSRunTimeException {
		long lCASE_NUM = 0;
		DcCasesCargo colrows[] = new DcCasesCargo[1];
		Connection conn = null;
		PreparedStatement statement = null;
		ResultSet rs = null;
		try {
			conn = getConnection();
			statement =
				conn.prepareStatement(
				"select DC_CASES_1SQ.nextval newCASENUM from dual");
			rs = statement.executeQuery();
			rs.next();
			lCASE_NUM = rs.getLong("newCASENUM");
		} catch (Exception e) {
			throw new TIERSRunTimeException(e.getMessage(), e);
		} finally {
			try {
				if (rs != null) {
					rs.close();
				}
			} catch (SQLException e) {
				throw new TIERSRunTimeException(
						e.getClass().getName() + " " + e.getMessage(), e);
			}
			try {
				if (statement != null) {
					statement.close();
				}
			} catch (SQLException e) {
				throw new TIERSRunTimeException(
						e.getClass().getName() + " " + e.getMessage(), e);
			}
			try {
				if (conn != null && getClose()) {
					conn.close();
				}
			} catch (SQLException e) {
				throw new TIERSRunTimeException(
						e.getClass().getName() + " " + e.getMessage(), e);
			}
		}
		if (lCASE_NUM > 0) {
			colrows[0] = new DcCasesCargo();
			colrows[0].setCaseNum(lCASE_NUM);
		}
		return (colrows);
	}

	/**
	 *Method findByCaseNumCaseMode
	 * This findByCaseNumCaseMode finder by method returns the records for the given case number if the
	 * case mode code is OG or CV. This method is used in Inter Office Transfer to validate the case can
	 * only be transferred if it is in Ongoing or Converted mode.
	 * @param maxRows int
	 * @param caseNum long
	 * @return DcCasesCargo[]
	 * @throws TIERSRunTimeException
	 */
	public DcCasesCargo[] findByCaseNumCaseMode(int maxRows, long caseNum)
	throws TIERSRunTimeException {
		ArrayList v = new ArrayList();
		Connection conn = null;
		PreparedStatement statement = null;
		ResultSet rs = null;
		DcCasesCargo[] colrows = null;

		try {
			conn = getConnection();

			String sqlString =
				SELECT_SQL
				+ " WHERE CASE_NUM = ? AND CASE_MODE_CD IN ( 'OG', 'CV' ) WITH UR";

			statement = conn.prepareStatement(sqlString);

			statement.setLong(1, caseNum);
			Debug.println("SQL String " + sqlString);
			rs = statement.executeQuery();
			int cnt = 0;
			//          while (rs.next() && cnt++ < maxRows) {
			//          BRGUS00102765 Ã¢â‚¬â€œ jampanip Ã¢â‚¬â€œ As Per QA Review Prefetch logic Changes
			while (cnt++ < maxRows && rs.next()) {
				DcCasesCargo row = new DcCasesCargo();
				getRowFromResultSet(row, rs);
				v.add(row);
			}

			colrows = new DcCasesCargo[v.size()];
			v.toArray(colrows);
		} catch (Exception e) {
			throw new TIERSRunTimeException(e.getMessage(), e);
		} finally {
			try {
				if (rs != null) {
					rs.close();
				}
			} catch (SQLException e) {
				throw new TIERSRunTimeException(
						e.getClass().getName() + " " + e.getMessage(), e);
			}
			try {
				if (statement != null) {
					statement.close();
				}
			} catch (SQLException e) {
				throw new TIERSRunTimeException(
						e.getClass().getName() + " " + e.getMessage(), e);
			}
			try {
				if (conn != null && getClose()) {
					conn.close();
				}
			} catch (SQLException e) {
				throw new TIERSRunTimeException(
						e.getClass().getName() + " " + e.getMessage(), e);
			}
		}
		return colrows;
	}

	/**
	 *Method findByCaseOfficeNum
	 * This findByCaseOfficeNum finder by method returns the records for the given case number and office number.
	 * This method is used in Inter Office Transfer to validate the case exists in the logged in office.
	 * @param maxRows int
	 * @param caseNum long
	 * @param officeNum long
	 * @return DcCasesCargo[]
	 * @throws TIERSRunTimeException
	 */
	public DcCasesCargo[] findByCaseOfficeNum(
			int maxRows,
			long caseNum,
			long officeNum)
	throws TIERSRunTimeException {
		ArrayList v = new ArrayList();
		Connection conn = null;
		PreparedStatement statement = null;
		ResultSet rs = null;
		DcCasesCargo[] colrows = null;
		try {
			conn = getConnection();
			String sqlString =
				SELECT_SQL + " WHERE CASE_NUM = ? AND OFFICE_NUM = ? WITH UR";
			statement = conn.prepareStatement(sqlString);
			statement.setLong(1, caseNum);
			statement.setLong(2, officeNum);
			Debug.println("SQL String " + sqlString);
			rs = statement.executeQuery();
			int cnt = 0;
			//          while (rs.next() && cnt++ < maxRows) {
			//          BRGUS00102765 Ã¢â‚¬â€œ jampanip Ã¢â‚¬â€œ As Per QA Review Prefetch logic Changes
			while (cnt++ < maxRows && rs.next()) {
				DcCasesCargo row = new DcCasesCargo();
				getRowFromResultSet(row, rs);
				v.add(row);
			}
			statement.close();
			rs.close();

			//            retreivng record from Audit table
			String sqlAuditString =
				SELECT_SQL + " WHERE CASE_NUM = ? AND OFFICE_NUM = ? WITH UR";
			statement = conn.prepareStatement(sqlAuditString);
			statement.setLong(1, caseNum);
			statement.setLong(2, officeNum);
			Debug.println("SQL String " + sqlAuditString);
			rs = statement.executeQuery();
			cnt = 0;
			//          while (rs.next() && cnt++ < maxRows) {
			//          BRGUS00102765 Ã¢â‚¬â€œ jampanip Ã¢â‚¬â€œ As Per QA Review Prefetch logic Changes
			while (cnt++ < maxRows && rs.next()) {
				DcCasesCargo row = new DcCasesCargo();
				getRowFromResultSet(row, rs);
				v.add(row);
			}
			statement.close();
			rs.close();
			colrows = new DcCasesCargo[v.size()];
			v.toArray(colrows);
		} catch (Exception e) {
			throw new TIERSRunTimeException(e.getMessage(), e);
		} finally {
			try {
				if (rs != null) {
					rs.close();
				}
			} catch (SQLException e) {
				throw new TIERSRunTimeException(
						e.getClass().getName() + " " + e.getMessage(), e);
			}
			try {
				if (statement != null) {
					statement.close();
				}
			} catch (SQLException e) {
				throw new TIERSRunTimeException(
						e.getClass().getName() + " " + e.getMessage(), e);
			}
			try {
				if (conn != null && getClose()) {
					conn.close();
				}
			} catch (SQLException e) {
				throw new TIERSRunTimeException(
						e.getClass().getName() + " " + e.getMessage(), e);
			}
		}
		return colrows;
	}

	/**
	 *Method findByCaseMode.
	 * This method is used to retreive records for a given action date
	 * @param maxRows int
	 * @param asOfDate Timestamp
	 * @return DcCasesCargo[]
	 * @throws TIERSRunTimeException
	 */
	public DcCasesCargo[] findByCaseMode(int maxRows, Timestamp asOfDate)
	throws TIERSRunTimeException {
		ArrayList v = new ArrayList();
		Connection conn = null;
		PreparedStatement statement = null;
		ResultSet rs = null;
		try {
			conn = getConnection();
			statement =
				conn.prepareStatement(
						SELECT_SQL
						+ " Where ACTION_DT = ?  AND CASE_MODE_CD ='ON' ORDER BY CASE_NUM DESC WITH UR");
			statement.setTimestamp(1, asOfDate);
			rs = statement.executeQuery();
			int cnt = 0;
			//          while (rs.next() && cnt++ < maxRows) {
			//          BRGUS00102765 Ã¢â‚¬â€œ jampanip Ã¢â‚¬â€œ As Per QA Review Prefetch logic Changes
			while (cnt++ < maxRows && rs.next()) {
				DcCasesCargo row = new DcCasesCargo();
				getRowFromResultSet(row, rs);
				v.add(row);
			}
			DcCasesCargo colrows[] = new DcCasesCargo[v.size()];
			v.toArray(colrows);
			return colrows;
		} catch (SQLException e) {
			throw new TIERSRunTimeException(e.getMessage(), e);
		} finally {
			try {
				if (rs != null) {
					rs.close();
				}
			} catch (SQLException e) {
				throw new TIERSRunTimeException(
						e.getClass().getName() + " " + e.getMessage(), e);
			}
			try {
				if (statement != null) {
					statement.close();
				}
			} catch (SQLException e) {
				throw new TIERSRunTimeException(
						e.getClass().getName() + " " + e.getMessage(), e);
			}
			try {
				if (conn != null && getClose()) {
					conn.close();
				}
			} catch (SQLException e) {
				throw new TIERSRunTimeException(
						e.getClass().getName() + " " + e.getMessage(), e);
			}
		}
	}

	/**
	 *Method findByActionDate.
	 * This method is used to retreive records for a given action date.
	 * @param maxRows int
	 * @param asOfDate Timestamp
	 * @return DcCasesCargo[]
	 * @throws TIERSRunTimeException
	 */
	public DcCasesCargo[] findByActionDate(int maxRows, Timestamp asOfDate)
	throws TIERSRunTimeException {
		ArrayList v = new ArrayList();
		Connection conn = null;
		PreparedStatement statement = null;
		ResultSet rs = null;
		try {
			conn = getConnection();
			statement =
				conn.prepareStatement(
						SELECT_SQL
						+ " Where ACTION_DT <= ? AND ACTION_DT IS NOT NULL  ORDER BY CASE_NUM DESC, ACTION_DT DESC WITH UR");
			statement.setTimestamp(1, asOfDate);
			rs = statement.executeQuery();
			int cnt = 0;
			//prefetch changes
			//   while (rs.next() && cnt++ < maxRows) {
			while (cnt++ < maxRows && rs.next()) {
				DcCasesCargo row = new DcCasesCargo();
				getRowFromResultSet(row, rs);
				v.add(row);
			}
			statement.close();
			rs.close();

			//            retreivng record from Audit table

			statement =
				conn.prepareStatement(
						SELECT_SQL_A

						+ " Where ACTION_DT <= ? AND ACTION_DT IS NOT NULL  ORDER BY CASE_NUM DESC, ACTION_DT DESC WITH UR");
			statement.setTimestamp(1, asOfDate);
			rs = statement.executeQuery();
			cnt = 0;
			//prefetch changes
			//   while (rs.next() && cnt++ < maxRows) {
			while (cnt++ < maxRows && rs.next()) {
				DcCasesCargo row = new DcCasesCargo();
				getAuditRowFromResultSet(row, rs);
				v.add(row);
			}
			statement.close();
			rs.close();
			DcCasesCargo colrows[] = new DcCasesCargo[v.size()];
			v.toArray(colrows);
			return colrows;
		} catch (SQLException e) {

			throw new TIERSRunTimeException(e.getMessage(), e);
		} finally {
			try {
				//Prefetch
				//              if (rs != null) {rs.close();}
				if (rs != null && getClose()) {
					rs.close();
				}
			} catch (SQLException e) {
				throw new TIERSRunTimeException(
						e.getClass().getName() + " " + e.getMessage(), e);
			}
			try {
				if (statement != null) {
					//Prefectch
					//                  statement.close();
					closeStatement("findByActionDate", statement,maxRows,v.size());

				}
			} catch (SQLException e) {
				throw new TIERSRunTimeException(
						e.getClass().getName() + " " + e.getMessage(), e);
			}
			try {
				if (conn != null && getClose()) {
					conn.close();
				}
			} catch (SQLException e) {
				throw new TIERSRunTimeException(
						e.getClass().getName() + " " + e.getMessage(), e);
			}
		}
	}


	/**
	 *Method findByArchivalData.
	 * This method is used to retreive records for a given set of data.
	 * @param maxRows int
	 * @param cargo DcCasesCargo
	 * @return DcCasesCargo[]
	 * @throws TIERSRunTimeException
	 */
	public DcCasesCargo[] findByArchivalData(int maxRows, DcCasesCargo cargo)
	throws TIERSRunTimeException {
		Debug.println(
				" findByArchivalData "
				+ " maxRows= "
				+ maxRows
				+ " cargo="
				+ cargo);
		ArrayList v = new ArrayList();
		Connection conn = null;
		PreparedStatement statement = null;
		ResultSet rs = null;
		try {
			conn = getConnection();
			statement =
				conn.prepareStatement(
						SELECT_SQL
						+ " WHERE CASE_CLOSED_DT <= ? AND CASE_STATUS_CD = ? WITH UR");
			Debug.println(
			"DcCasesDAO-findByArchivalCases() : WHERE clause :  WHERE CASE_CLOSED_DT <= ? AND CASE_STATUS_CD = ?  ");
			//statement.setLong(1, cargo.getCaseNum());
			//statement.setTimestamp(2, cargo.getUpdateDt());
			statement.setTimestamp(1, cargo.getCaseClosedDt());
			statement.setString(2, cargo.getCaseStatusCd());
			rs = statement.executeQuery();
			int cnt = 0;
			while (cnt++ < maxRows && rs.next()) {
				DcCasesCargo row = new DcCasesCargo();
				getRowFromResultSet(row, rs);
				v.add(row);
			}
			statement.close();
			rs.close();
			//RETREIVED RECORDS FROM AUDIT TABLE
			DcCasesCargo colrows[] = new DcCasesCargo[v.size()];
			v.toArray(colrows);
			return colrows;
		} catch (SQLException e) {
			throw new TIERSRunTimeException(e.getMessage(), e);
		} finally {
			try {
				if (rs != null && getClose()) {
					rs.close();
				}
			} catch (SQLException e) {
				throw new TIERSRunTimeException(
						e.getClass().getName() + " " + e.getMessage(), e);
			}
			try {
				if (statement != null) {
					closeStatement("findByArchivalData", statement,maxRows,v.size());
				}
			} catch (SQLException e) {
				throw new TIERSRunTimeException(
						e.getClass().getName() + " " + e.getMessage(), e);
			}
			try {
				if (conn != null && getClose()) {
					conn.close();
				}
			} catch (SQLException e) {
				throw new TIERSRunTimeException(
						e.getClass().getName() + " " + e.getMessage(), e);
			}
		}
	}

	/**
	 *Method findByCaseNumForDenied
	 * This method reads all denied/terminated cases.
	 * @param maxRows int
	 * @param cargo DcCasesCargo
	 * @return DcCasesCargo[]
	 * @throws TIERSRunTimeException
	 **/

	public DcCasesCargo[] findByCaseNumForDenied(
			int maxRows,
			DcCasesCargo cargo)
	throws TIERSRunTimeException {
		Debug.println(
				"findByCaseNum " + " maxRows= " + maxRows + " cargo=" + cargo);
		ArrayList v = new ArrayList();
		Connection conn = null;
		PreparedStatement statement = null;
		ResultSet rs = null;
		try {
			conn = getConnection();
			Debug.println(
					"DcCasesDAO-findByCaseNumForDenied() : SELECT->WHERE clause :"
					+ SELECT_SQL
					+ " WHERE (CASE_NUM = ? AND CASE_STATUS_CD IN ('TN', 'DN')) WITH UR");
			statement =
				conn.prepareStatement(
						SELECT_SQL
						+ "  WHERE (CASE_NUM = ? AND CASE_STATUS_CD IN ('TN', 'DN')) WITH UR");
			statement.setLong(1, cargo.getCaseNum());
			rs = statement.executeQuery();
			int cnt = 0;
			//          while (rs.next() && cnt++ < maxRows) {
			//          BRGUS00102765 Ã¢â‚¬â€œ jampanip Ã¢â‚¬â€œ As Per QA Review Prefetch logic Changes
			while (cnt++ < maxRows && rs.next()) {
				DcCasesCargo row = new DcCasesCargo();
				getRowFromResultSet(row, rs);
				v.add(row);
			}
			statement.close();
			rs.close();

			statement =
				conn.prepareStatement(
						SELECT_SQL_A
						+ "  WHERE (CASE_NUM = ? AND CASE_STATUS_CD IN ('TN', 'DN')) WITH UR");
			statement.setLong(1, cargo.getCaseNum());
			rs = statement.executeQuery();
			cnt = 0;
			//          while (rs.next() && cnt++ < maxRows) {
			//          BRGUS00102765 Ã¢â‚¬â€œ jampanip Ã¢â‚¬â€œ As Per QA Review Prefetch logic Changes
			while (cnt++ < maxRows && rs.next()) {
				DcCasesCargo row = new DcCasesCargo();
				getAuditRowFromResultSet(row, rs);
				v.add(row);
			}
			statement.close();
			rs.close();
			Debug.println(
					"DcCasesDAO-findByCaseNumForDenied() : retrieved rows-size "
					+ v.size());

			DcCasesCargo colrows[] = new DcCasesCargo[v.size()];
			v.toArray(colrows);
			return colrows;
		} catch (SQLException e) {
			throw new TIERSRunTimeException(e.getMessage(), e);
		} finally {
			try {
				if (rs != null) {
					rs.close();
				}
			} catch (SQLException e) {
				throw new TIERSRunTimeException(
						e.getClass().getName() + " " + e.getMessage(), e);
			}
			try {
				if (statement != null) {
					statement.close();
				}
			} catch (SQLException e) {
				throw new TIERSRunTimeException(
						e.getClass().getName() + " " + e.getMessage(), e);
			}
			try {
				if (conn != null && getClose()) {
					conn.close();
				}
			} catch (SQLException e) {
				throw new TIERSRunTimeException(
						e.getClass().getName() + " " + e.getMessage(), e);
			}
		}
	}

	/**
	 *Method findCaseModeByCaseNum
	 * Requested by Prateek (track02 - Alerts)
	 * added by Mahesh M 07/07/2004
	 * @param maxRows int
	 * @param cargo DcCasesCargo
	 * @return DcCasesCargo[]
	 * @throws TIERSRunTimeException
	 */
	public DcCasesCargo[] findCaseModeByCaseNum(
			int maxRows,
			DcCasesCargo cargo)
	throws TIERSRunTimeException {
		ArrayList v = new ArrayList();
		Connection conn = null;
		PreparedStatement statement = null;
		ResultSet rs = null;
		try {
			conn = getConnection();
			statement =
				conn.prepareStatement(
				"SELECT CASE_MODE_CD FROM DC_CASES WHERE CASE_NUM = ? WITH UR");
			statement.setLong(1, cargo.getCaseNum());
			rs = statement.executeQuery();
			int cnt = 0;
			//          while (rs.next() && cnt++ < maxRows) {
			//          BRGUS00102765 Ã¢â‚¬â€œ jampanip Ã¢â‚¬â€œ As Per QA Review Prefetch logic Changes
			while (cnt++ < maxRows && rs.next()) {
				DcCasesCargo row = new DcCasesCargo();
				row.setCaseModeCd(rs.getString("CASE_MODE_CD"));
				v.add(row);
			}
			DcCasesCargo colrows[] = new DcCasesCargo[v.size()];
			v.toArray(colrows);
			return colrows;
		} catch (SQLException e) {
			throw new TIERSRunTimeException(e.getMessage(), e);
		} finally {
			try {
				if (rs != null && getClose()) {
					rs.close();
				}
			} catch (SQLException e) {
				throw new TIERSRunTimeException(
						e.getClass().getName() + " " + e.getMessage(), e);
			}
			try {
				if (statement != null) {
					statement.close();
				}
			} catch (SQLException e) {
				throw new TIERSRunTimeException(
						e.getClass().getName() + " " + e.getMessage(), e);
			}
			try {
				if (conn != null && getClose()) {
					conn.close();
				}
			} catch (SQLException e) {
				throw new TIERSRunTimeException(
						e.getClass().getName() + " " + e.getMessage(), e);
			}
		}
	}

	//FO627 Starts - New finders added. Finders based on Case numbers, empIds,
	//Office Numbers & Unit Numbers
	/**
	 * Method findByCaseNumbers.
	 * This method is used to case nos which are not in ongoing mode based on
	 * the input - caseNumbers
	 *
	 * @param maxRows int
	 * @param asOfDate Timestamp
	 * @return DcCasesCargo[]
	 * @throws TIERSRunTimeException
	 */
	public DcCasesCargo[] findByCaseNumbers(int maxRows, String caseNumbers)
	throws TIERSRunTimeException {
		ArrayList v = new ArrayList();
		Connection conn = null;
		PreparedStatement statement = null;
		ResultSet rs = null;

		try {
			Debug.println("Inside method findByCaseNumbers");
			conn = getConnection();
			statement = conn
			.prepareStatement("SELECT CASE_NUM FROM DC_CASES WHERE "
					+ "CASE_MODE_CD != 'OG' AND CASE_NUM IN ("
					+ caseNumbers + ") WITH UR");

			rs = statement.executeQuery();
			int cnt = 0;

			//          while (rs.next() && cnt++ < maxRows) {
			//          BRGUS00102765 Ã¢â‚¬â€œ jampanip Ã¢â‚¬â€œ As Per QA Review Prefetch logic Changes
			while (cnt++ < maxRows && rs.next()) {
				DcCasesCargo row = new DcCasesCargo();
				row.setCaseNum(rs.getLong(1));
				//getRowFromResultSet(row, rs);
				v.add(row);
			}

			DcCasesCargo colrows[] = new DcCasesCargo[v.size()];
			v.toArray(colrows);
			Debug.println("Exiting method findByCaseNumbers");
			return colrows;

		} catch (SQLException e) {
			throw new TIERSRunTimeException(e.getMessage(), e);
		} finally {
			try {
				if (rs != null) {
					rs.close();
				}
			} catch (SQLException e) {
				throw new TIERSRunTimeException(e.getClass().getName() + " "
						+ e.getMessage(), e);
			}
			try {
				if (statement != null) {
					statement.close();
				}
			} catch (SQLException e) {
				throw new TIERSRunTimeException(e.getClass().getName() + " "
						+ e.getMessage(), e);
			}
			try {
				if (conn != null && getClose()) {
					conn.close();
				}
			} catch (SQLException e) {
				throw new TIERSRunTimeException(e.getClass().getName() + " "
						+ e.getMessage(), e);
			}
		}
	}

	/**
	 * Method findByOfficeNum.
	 * This method is used to case nos which are not in ongoing mode based on
	 * the input - office num
	 *
	 * @param maxRows int
	 * @param long officeNum
	 * @return DcCasesCargo[]
	 * @throws TIERSRunTimeException
	 */
	public DcCasesCargo[] findByOfficeNum(int maxRows, long officeNum)
	throws TIERSRunTimeException {
		ArrayList v = new ArrayList();
		Connection conn = null;
		PreparedStatement statement = null;
		ResultSet rs = null;

		try {
			Debug.println("Inside method findByOfficeNum");
			conn = getConnection();

			StringBuffer sqlBuff = new StringBuffer();

			sqlBuff.append(" SELECT CASE_NUM FROM DC_CASES ").append(
			"WHERE OFFICE_NUM = ? AND CASE_MODE_CD != 'OG' WITH UR");

			statement = conn.prepareStatement(sqlBuff.toString());
			statement.setLong(1, officeNum);

			rs = statement.executeQuery();
			int cnt = 0;

			//          while (rs.next() && cnt++ < maxRows) {
			//          BRGUS00102765 Ã¢â‚¬â€œ jampanip Ã¢â‚¬â€œ As Per QA Review Prefetch logic Changes
			while (cnt++ < maxRows && rs.next()) {
				DcCasesCargo row = new DcCasesCargo();
				row.setCaseNum(rs.getLong(1));
				//getRowFromResultSet(row, rs);
				v.add(row);
			}

			DcCasesCargo colrows[] = new DcCasesCargo[v.size()];
			v.toArray(colrows);
			Debug.println("Exiting method findByOfficeNum");
			return colrows;

		} catch (SQLException e) {
			throw new TIERSRunTimeException(e.getMessage(), e);
		} finally {
			try {
				if (rs != null) {
					rs.close();
				}
			} catch (SQLException e) {
				throw new TIERSRunTimeException(e.getClass().getName() + " "
						+ e.getMessage(), e);
			}
			try {
				if (statement != null) {
					statement.close();
				}
			} catch (SQLException e) {
				throw new TIERSRunTimeException(e.getClass().getName() + " "
						+ e.getMessage(), e);
			}
			try {
				if (conn != null && getClose()) {
					conn.close();
				}
			} catch (SQLException e) {
				throw new TIERSRunTimeException(e.getClass().getName() + " "
						+ e.getMessage(), e);
			}
		}
	}
	//FO627 Ends

	//FO627 Ends


	/*  Added  by Bhaskar...*/


	/**
	 *Method findByCaseOfficeNum
	 * This findByCaseOfficeNum finder by method returns the records for the given case number and office number.
	 * This method is used in Inter Office Transfer to validate the case exists in the logged in office.
	 * @param maxRows int
	 * @param caseNum long
	 * @param officeNum long
	 * @return DcCasesCargo[]
	 * @throws TIERSRunTimeException
	 */
	public DcCasesCargo[] findByCaseFuelType(int maxRows,DcCasesCargo cargo)
	throws TIERSRunTimeException {
		ArrayList v = new ArrayList();
		Connection conn = null;
		PreparedStatement statement = null;
		ResultSet rs = null;
		DcCasesCargo[] colrows = null;
		try {
			conn = getConnection();
			String sqlString =
				SELECT_SQL + " WHERE CASE_NUM = ?  WITH UR";
			statement = conn.prepareStatement(sqlString);
			statement.setLong(1, cargo.getCaseNum());
			//statement.setString(2, cargo.getFuelTypeCd());
			Debug.println("SQL String " + sqlString);
			rs = statement.executeQuery();
			int cnt = 0;
			//              while (rs.next() && cnt++ < maxRows) {
			//              BRGUS00102765 Ã¢â‚¬â€œ jampanip Ã¢â‚¬â€œ As Per QA Review Prefetch logic Changes
			while (cnt++ < maxRows && rs.next()) {
				DcCasesCargo row = new DcCasesCargo();
				getRowFromResultSet(row, rs);
				v.add(row);
			}
			statement.close();
			rs.close();

			//                retreivng record from Audit table
			/*String sqlAuditString =
                    SELECT_SQL + " WHERE CASE_NUM = ? AND FUEL_TYPE = ?  ";
                statement = conn.prepareStatement(sqlAuditString);
                statement.setLong(1, caseNum);
                statement.setLong(2, officeNum);
                Debug.println("SQL String " + sqlAuditString);
                rs = statement.executeQuery();
                cnt = 0;
                while (rs.next() && cnt++ < maxRows) {
                    DcCasesCargo row = new DcCasesCargo();
                    getRowFromResultSet(row, rs);
                    v.add(row);
                }
                statement.close();
                rs.close();*/
			colrows = new DcCasesCargo[v.size()];
			v.toArray(colrows);
		} catch (Exception e) {
			throw new TIERSRunTimeException(e.getMessage(), e);
		} finally {
			try {
				if (rs != null) {
					rs.close();
				}
			} catch (SQLException e) {
				throw new TIERSRunTimeException(
						e.getClass().getName() + " " + e.getMessage(), e);
			}
			try {
				if (statement != null) {
					statement.close();
				}
			} catch (SQLException e) {
				throw new TIERSRunTimeException(
						e.getClass().getName() + " " + e.getMessage(), e);
			}
			try {
				if (conn != null && getClose()) {
					conn.close();
				}
			} catch (SQLException e) {
				throw new TIERSRunTimeException(
						e.getClass().getName() + " " + e.getMessage(), e);
			}
		}
		return colrows;
	}


	//Method added by Gopi on 12/07/2007 for the Defect BRGUS00086914
	//Requested by - Gouthami Chiluka
	/**
	 * Method findByCaseNums.
	 * This method is used to find the records for the given case numbers
	 * @param maxRows int
	 * @param caseNumbers String
	 * @return DcCasesCargo[]
	 * @throws TIERSRunTimeException
	 */
	public DcCasesCargo[] findByCaseNums(int maxRows, String caseNumbers)
	throws TIERSRunTimeException {
		ArrayList v = new ArrayList();
		Connection conn = null;
		PreparedStatement statement = null;
		ResultSet rs = null;

		try {
			Debug.println("Inside method findByCaseNums");
			conn = getConnection();
			statement = conn
			.prepareStatement("SELECT CASE_NUM, CONVERSION_DT FROM DC_CASES WHERE "
					+ "CASE_NUM IN ("
					+ caseNumbers + ") WITH UR");

			rs = statement.executeQuery();
			int cnt = 0;

			//                  while (rs.next() && cnt++ < maxRows) {
			//                  BRGUS00102765 Ã¢â‚¬â€œ jampanip Ã¢â‚¬â€œ As Per QA Review Prefetch logic Changes
			while (cnt++ < maxRows && rs.next()) {
				DcCasesCargo row = new DcCasesCargo();
				row.setCaseNum(rs.getLong("CASE_NUM"));
				row.setConversionDt(rs.getTimestamp("CONVERSION_DT"));
				//getRowFromResultSet(row, rs);
				v.add(row);
			}

			DcCasesCargo colrows[] = new DcCasesCargo[v.size()];
			v.toArray(colrows);
			Debug.println("Exiting method findByCaseNums");
			return colrows;

		} catch (SQLException e) {
			throw new TIERSRunTimeException(e.getMessage(), e);
		} finally {
			try {
				if (rs != null) {
					rs.close();
				}
			} catch (SQLException e) {
				throw new TIERSRunTimeException(e.getClass().getName() + " "
						+ e.getMessage(), e);
			}
			try {
				if (statement != null) {
					statement.close();
				}
			} catch (SQLException e) {
				throw new TIERSRunTimeException(e.getClass().getName() + " "
						+ e.getMessage(), e);
			}
			try {
				if (conn != null && getClose()) {
					conn.close();
				}
			} catch (SQLException e) {
				throw new TIERSRunTimeException(e.getClass().getName() + " "
						+ e.getMessage(), e);
			}
		}
	}
	//Defect#-----BRGUS00087883
	/**
	 *Method findByCaseNumsAndMode.
	 * This method is used to retreive records for given case numbers and case status
	 * @param maxRows int
	 * @param lCaseNums long[]
	 * @return DcCasesCargo[]
	 * @throws TIERSRunTimeException
	 */
	public DcCasesCargo[] findByCaseNumsAndMode(int maxRows, long[] lCaseNums,String caseStatusCd)
	throws TIERSRunTimeException {
		ArrayList v = new ArrayList();
		Connection conn = null;
		PreparedStatement statement = null;
		ResultSet rs = null;
		try {
			conn = getConnection();
			StringBuffer clause = new StringBuffer();
			clause.append("WHERE CASE_NUM IN (");
			for (int i = 0;i < lCaseNums.length;i++) {
				clause.append(lCaseNums[i]);
				if (!((i + 1) == lCaseNums.length)) {
					clause.append( ",");
				}
			}
			clause.append( ")");
			//BRGUS00184025 -- padmanabhunip --If empty string for caseStatusCd ,then ignore it
			if(caseStatusCd!=null && !caseStatusCd.equals("")){
				clause.append("AND CASE_STATUS_CD NOT IN ('"+caseStatusCd+"')"); //BRGUS00176753 --padmanabhunip
			}
			statement = conn.prepareStatement(SELECT_SQL + " " + clause.toString() + " WITH UR");

			rs = statement.executeQuery();
			int cnt = 0;
			//              while (rs.next() && cnt++ < maxRows) {
			//              BRGUS00102765 Ã¢â‚¬â€œ jampanip Ã¢â‚¬â€œ As Per QA Review Prefetch logic Changes
			while (cnt++ < maxRows && rs.next()) {
				DcCasesCargo row = new DcCasesCargo();
				getRowFromResultSet(row, rs);
				v.add(row);
			}
			DcCasesCargo colrows[] = new DcCasesCargo[v.size()];
			v.toArray(colrows);
			return colrows;
		}   catch (SQLException e) {
			throw new TIERSRunTimeException(e.getMessage(), e);
		}   finally {
			try {
				if (rs != null) {
					rs.close();
				}
			} catch (SQLException e) {
				throw new TIERSRunTimeException(
						e.getClass().getName() + " " + e.getMessage(), e);
			}
			try {
				if (statement != null) {
					statement.close();
				}
			} catch (SQLException e) {
				throw new TIERSRunTimeException(
						e.getClass().getName() + " " + e.getMessage(), e);
			}
			try {
				if (conn != null && getClose()) {
					conn.close();
				}
			} catch (SQLException e) {
				throw new TIERSRunTimeException(
						e.getClass().getName() + " " + e.getMessage(), e);
			}
		}
	}

	/**This method retrieves the all the cases assigned to an employee.
	 * @param maxRows - maximum number of records
	 * @param empId - Employee Id
	 * @return DcCasesCargo[]
	 * @throws Exception
	 */
	public DcCasesCargo[] findAllCasesForEmp(int maxRows, long empId) throws Exception{
		ArrayList v = new ArrayList();
		Connection conn = null;
		PreparedStatement statement = null;
		ResultSet rs = null;
		try {
			conn = getConnection();
			StringBuffer clause = new StringBuffer();
			//BRGUS00164845 - pulaguma - To correct the sql and to get all the case data including special programs like IAA
			//Added App_Recvd_dt to search criteria as part of ILIES-134042
			StringBuffer sql = new StringBuffer("select A.Case_Num, " );
			sql.append(" (select first_name || ' ' || last_name from dc_indv D, dc_case_individual E where E.case_num = A.case_num and E.Head_Of_Household_Sw= 'Y' and D.indv_id = E.indv_id and rownum = 1 ) case_Name, " );
	//		sql.append(" A.App_Recvd_Dt, A.Case_Status_Cd, A.Case_Mode_Cd, C.Office_Num , NVL(B.Prog_Cd,  'IAA') Prog_Cd, B.Prog_Status_Cd" );
			sql.append(" A.App_Recvd_Dt, A.Case_Status_Cd, A.Case_Mode_Cd, C.Office_Num , B.Prog_Cd, B.Prog_Status_Cd" );
			sql.append(" from DC_CASES A , dc_case_program B , mo_offices C  where " );
			sql.append(" A.case_num = B.case_num(+) and A.office_num = C.office_num and C.hist_nav_ind in ('S','P') " );
			sql.append(" AND A.CASE_NUM  in ( " );
			sql.append(" select case_num from mo_employee_cases where emp_id = ? " );
			sql.append(" and (assign_end_dt is null OR assign_end_dt >= SYSDATE) group by case_num ) WITH UR" );


			Debug.print("Query from DCCasesDAO.findAllCasesForEmp : " + sql.toString());

			statement = conn.prepareStatement(sql.toString());

			statement.setLong(1,empId);

			rs = statement.executeQuery();
			int cnt = 0;
			while (rs.next()) {
				DcCasesCargo row = new DcCasesCargo();

				row.setCaseNum(rs.getLong("Case_Num"));
				row.setAuthrepFirstName(rs.getString("Case_Name")); // Case Name
				row.setAppRecvdDt(rs.getTimestamp("App_Recvd_Dt"));
				row.setCaseStatusCd(rs.getString("Case_Status_Cd"));
				row.setCaseModeCd(rs.getString("Case_Mode_Cd"));
				row.setOfficeNum(rs.getLong("Office_Num"));
				row.setFuelTypeCd(rs.getString("Prog_Cd")); // Program Cd
				row.setInterviewTypeCd(rs.getString("Prog_Status_Cd")); // Program Status

				v.add(row);
			}
			DcCasesCargo colrows[] = new DcCasesCargo[v.size()];
			v.toArray(colrows);
			return colrows;
		}   catch (SQLException e) {
			throw new TIERSRunTimeException(e.getMessage(), e);
		}   finally {
			try {
				if (rs != null) {
					rs.close();
				}
			} catch (SQLException e) {
				throw new TIERSRunTimeException(
						e.getClass().getName() + " " + e.getMessage(), e);
			}
			try {
				if (statement != null) {
					statement.close();
				}
			} catch (SQLException e) {
				throw new TIERSRunTimeException(
						e.getClass().getName() + " " + e.getMessage(), e);
			}
			try {
				if (conn != null && getClose()) {
					conn.close();
				}
			} catch (SQLException e) {
				throw new TIERSRunTimeException(
						e.getClass().getName() + " " + e.getMessage(), e);
			}
		}
	}

	/**
	 * Method findByCaseNumsForOffice.
	 * This method is used to find the records for the given case numbers
	 * @param maxRows int
	 * @param caseNumbers String
	 * @return DcCasesCargo[]
	 * @throws TIERSRunTimeException
	 */
	public DcCasesCargo[] findByCaseNumsForOffice(int maxRows, StringBuffer clause, String officeNum)
	throws TIERSRunTimeException {
		ArrayList v = new ArrayList();
		Connection conn = null;
		PreparedStatement statement = null;
		ResultSet rs = null;

		try {
			Debug.println("Inside method findByCaseNumsForOffice");

			conn = getConnection();
			statement = conn
			.prepareStatement("SELECT CASE_NUM, OFFICE_NUM FROM DC_CASES WHERE "
					+ "CASE_NUM IN ("
					+ clause.toString() + ") AND OFFICE_NUM != "+officeNum+" WITH UR");

			rs = statement.executeQuery();
			int cnt = 0;
			while (cnt++ < maxRows && rs.next()) {
				DcCasesCargo row = new DcCasesCargo();
				row.setCaseNum(rs.getLong("CASE_NUM"));
				row.setOfficeNum(rs.getLong("OFFICE_NUM"));
				v.add(row);
			}

			DcCasesCargo colrows[] = new DcCasesCargo[v.size()];
			v.toArray(colrows);
			Debug.println("Exiting method findByCaseNumsForOffice");
			return colrows;

		} catch (SQLException e) {
			throw new TIERSRunTimeException(e.getMessage(), e);
		} finally {
			try {
				if (rs != null) {
					rs.close();
				}
			} catch (SQLException e) {
				throw new TIERSRunTimeException(e.getClass().getName() + " "
						+ e.getMessage(), e);
			}
			try {
				if (statement != null) {
					statement.close();
				}
			} catch (SQLException e) {
				throw new TIERSRunTimeException(e.getClass().getName() + " "
						+ e.getMessage(), e);
			}
			try {
				if (conn != null && getClose()) {
					conn.close();
				}
			} catch (SQLException e) {
				throw new TIERSRunTimeException(e.getClass().getName() + " "
						+ e.getMessage(), e);
			}
		}
	}

	/**
	 * Method findByNonFixedCertifications reads records for approved ongoing EDGs which redetermination is required.
	 * Added using WR BRGUS00177531 by AnandP on 10/28/2009
	 * @param maxRows int
	 * @param currMonthFirstDay String
	 * @param currMonthlastDay String
	 * @param cargo DcCasesCargo
	 * @return DcCasesCargo[]
	 * @throws TIERSRunTimeException
	 */
	public DcCasesCargo[] findByNonFixedCertifications (int maxRows, String currMonthFirstDay, String currMonthlastDay)
	throws TIERSRunTimeException {
		Debug.println("findByNonFixedCertifications" + " maxRows= " + maxRows);
		ArrayList v = new ArrayList();
		Connection conn = null;
		PreparedStatement statement = null;
		ResultSet rs = null;
		DcCasesCargo[] colrows = null;
		StringBuffer sqlClause = new StringBuffer();

		try {
			conn = getConnection();
			sqlClause.append("SELECT case_num");
			sqlClause.append("  FROM dc_cases");
			sqlClause.append(" WHERE case_num IN");
			sqlClause.append("       (SELECT /*+ parallel(v1.ed_case_recert_dates)*/");
			sqlClause.append("         t1_case_num");
			sqlClause.append("          FROM v_ed_eligibility_recert_dates v1");
			sqlClause.append("         WHERE recert_review_due_dt < TO_DATE(?, 'YYYY-MM-DD')");
			sqlClause.append("           AND review_pending_cd <> 'RI'");
			sqlClause.append("           AND eligibility_end_dt IS NULL");
			sqlClause.append("           AND current_elig_ind = 'A'");
			sqlClause.append("           AND cg_elig_rslt_cd = 'PS'");
			sqlClause.append("           AND rec_end_dt IS NULL");
			sqlClause.append("           AND cg_status_cd = 'AP'");
			sqlClause.append("           AND eff_end_dt IS NULL");
			sqlClause.append("           AND delete_sw = 'N'");
			sqlClause.append("           AND edg_closure_approval_sw = 'Y'");
			sqlClause.append("           AND t1_program_cd IN ('MA', 'ME', 'MC')");
			sqlClause.append("        UNION ALL");
			sqlClause.append("        SELECT /*+ full(v2.ed_case_recert_dates) parallel(v2.ed_case_recert_dates)*/");
			sqlClause.append("         t1_case_num");
			sqlClause.append("          FROM v_ed_eligibility_recert_dates v2");
			sqlClause.append("         WHERE (recert_review_due_dt >= TO_DATE(?, 'YYYY-MM-DD') AND");
			sqlClause.append("               recert_review_due_dt <= TO_DATE(?, 'YYYY-MM-DD'))");
			sqlClause.append("           AND (estimated_elig_end_dt IS NULL OR");
			sqlClause.append("               (estimated_elig_end_dt IS NOT NULL AND");
			sqlClause.append("               t1_program_cd IN ('MA', 'ME')))");
			sqlClause.append("           AND review_pending_cd <> 'RI'");
			sqlClause.append("           AND eligibility_end_dt IS NULL");
			sqlClause.append("           AND current_elig_ind = 'A'");
			sqlClause.append("           AND cg_elig_rslt_cd = 'PS'");
			sqlClause.append("           AND rec_end_dt IS NULL");
			sqlClause.append("           AND cg_status_cd = 'AP'");
			sqlClause.append("           AND eff_end_dt IS NULL");
			sqlClause.append("           AND delete_sw = 'N'");
			sqlClause.append("           AND ((edg_closure_approval_sw = 'Y' AND");
			sqlClause.append("               t1_program_cd IN ('MA', 'ME', 'MC')) OR");
			sqlClause.append("               t1_program_cd NOT IN ('MA', 'ME', 'MC'))) WITH UR");

			statement = conn.prepareStatement(sqlClause.toString());
			statement.setString(1,currMonthFirstDay);
			statement.setString(2,currMonthFirstDay);
			statement.setString(3,currMonthlastDay);

			rs = statement.executeQuery();

			int cnt = 0;
			while ( cnt++ < maxRows && rs.next() ) {
				DcCasesCargo row = new DcCasesCargo();
				getCustomRowFromResultSet(row, rs, "findByNonFixedCertifications");
				v.add(row);
			}
			colrows = new DcCasesCargo[v.size()];
			v.toArray(colrows);
		}
		catch (Exception e) {
			throw new TIERSRunTimeException(e.getMessage(), e);
		}
		finally {
			try {
				if (rs != null && getClose()) {
					rs.close();
				}
			}
			catch (SQLException e) {
				throw new TIERSRunTimeException(e.getClass().getName() + " " + e.getMessage(), e);
			}
			try {
				if (statement != null) {
					closeStatement("findByNonFixedCertifications", statement,maxRows,v.size());
					Debug.println("called close statement for findByNonFixedCertifications");
				}
			}
			catch (SQLException e) {
				Debug.println("exception in close statement for findByNonFixedCertifications");
				throw new TIERSRunTimeException(e.getClass().getName() + "findByNonFixedCertifications " + e.getMessage(), e);
			}
			try {
				if (conn != null && getClose()) {
					conn.close();
				}
			}
			catch (SQLException e) {
				throw new TIERSRunTimeException(e.getClass().getName() + " findByNonFixedCertifications" + e.getMessage(), e);
			}
		}
		return colrows;
	}

	/**
	 * Method findByCaseNumNonFixedCert reads the cases and checks
	 * if a certified group(CG) individual has MA_NEWBORN_SW = 'Y' in ED_INDV_ELIGIBILITY.
	 * Added using WR BRGUS00177531 by AnandP on 10/28/2009
	 * @param maxRows int
	 * @param currMonthFirstDay String
	 * @param currMonthlastDay String
	 * @param cargo DcCasesCargo
	 * @return DcCasesCargo[]
	 * @throws TIERSRunTimeException
	 */
	public DcCasesCargo[] findByCaseNumNonFixedCert (int maxRows, DcCasesCargo cargo, String currMonthFirstDay, String currMonthlastDay)
	throws TIERSRunTimeException {
		Debug.println("findByCaseNumNonFixedCert" + " maxRows= " + maxRows);
		ArrayList v = new ArrayList();
		Connection conn = null;
		PreparedStatement statement = null;
		ResultSet rs = null;
		DcCasesCargo[] colrows = null;
		StringBuffer sqlClause = new StringBuffer();

		try {
			conn = getConnection();
			sqlClause.append("SELECT case_num");
			sqlClause.append("   FROM dc_cases dcc");
			sqlClause.append("  WHERE case_num = ?");
			sqlClause.append("    AND EXISTS");
			sqlClause.append("  (SELECT ein.case_num");
			sqlClause.append("           FROM ed_indv_eligibility ein, ed_eligibility ed");
			sqlClause.append("          WHERE ed.case_num = dcc.case_num");
			sqlClause.append("            AND ein.case_num = ed.case_num");
			sqlClause.append("            AND ein.edg_trace_id = ed.edg_trace_id");
			sqlClause.append("            AND ed.delete_sw = 'N'");
			sqlClause.append("            AND ed.current_elig_ind = 'A'");
			sqlClause.append("            AND ed.rec_end_dt IS NULL");
			sqlClause.append("            AND ed.cg_status_cd = 'AP'");
			sqlClause.append("            AND ein.ma_newborn_sw = 'Y'");
			sqlClause.append("            AND program_cd IN ('MA', 'ME', 'MC')");
			sqlClause.append("            AND ed.type_of_assistance_cd IN ('TP07', 'TP08', 'TP20')");
			sqlClause.append("            AND ein.group_ind = 'C')");
			sqlClause.append("    AND EXISTS");
			sqlClause.append("  (SELECT NULL");
			sqlClause.append("           FROM v_ed_eligibility_recert_dates v1");
			sqlClause.append("          WHERE (recert_review_due_dt < TO_DATE(?, 'YYYY-MM-DD') OR");
			sqlClause.append("                ((recert_review_due_dt >= TO_DATE(?, 'YYYY-MM-DD') AND");
			sqlClause.append("                recert_review_due_dt <= TO_DATE(?, 'YYYY-MM-DD')) AND");
			sqlClause.append("                estimated_elig_end_dt IS NOT NULL AND");
			sqlClause.append("                t1_program_cd IN ('MA', 'ME')))");
			sqlClause.append("            AND review_pending_cd <> 'RI'");
			sqlClause.append("            AND eligibility_end_dt IS NULL");
			sqlClause.append("            AND current_elig_ind = 'A'");
			sqlClause.append("            AND cg_elig_rslt_cd = 'PS'");
			sqlClause.append("            AND rec_end_dt IS NULL");
			sqlClause.append("            AND cg_status_cd = 'AP'");
			sqlClause.append("            AND eff_end_dt IS NULL");
			sqlClause.append("            AND delete_sw = 'N'");
			sqlClause.append("            AND edg_closure_approval_sw = 'Y'");
			sqlClause.append("            AND v1.t2_case_num = dcc.case_num");
			sqlClause.append("            AND t1_program_cd IN ('MA', 'ME', 'MC')) WITH UR");

			statement = conn.prepareStatement(sqlClause.toString());
			statement.setLong(1,cargo.getCaseNum());
			statement.setString(2,currMonthFirstDay);
			statement.setString(3,currMonthFirstDay);
			statement.setString(4,currMonthlastDay);

			rs = statement.executeQuery();

			int cnt = 0;
			while ( cnt++ < maxRows && rs.next() ) {
				DcCasesCargo row = new DcCasesCargo();
				getCustomRowFromResultSet(row, rs, "findByCaseNumNonFixedCert");
				v.add(row);
			}
			colrows = new DcCasesCargo[v.size()];
			v.toArray(colrows);
		}
		catch (Exception e) {
			throw new TIERSRunTimeException(e.getMessage(), e);
		}
		finally {
			try {
				if (rs != null && getClose()) {
					rs.close();
				}
			}
			catch (SQLException e) {
				throw new TIERSRunTimeException(e.getClass().getName() + " " + e.getMessage(), e);
			}
			try {
				if (statement != null) {
					statement.close();
					Debug.println("called close statement for findByCaseNumNonFixedCert");
				}
			}
			catch (SQLException e) {
				Debug.println("exception in close statement for findByCaseNumNonFixedCert");
				throw new TIERSRunTimeException(e.getClass().getName() + "findByCaseNumNonFixedCert " + e.getMessage(), e);
			}
			try {
				if (conn != null && getClose()) {
					conn.close();
				}
			}
			catch (SQLException e) {
				throw new TIERSRunTimeException(e.getClass().getName() + " findByCaseNumNonFixedCert" + e.getMessage(), e);
			}
		}
		return colrows;
	}

	/**
	 * getCustomRowFromResultSet to fetch custom rows from resultset
	 * Added using WR BRGUS00177531 by AnandP on 10/28/2009
	 *
	 * @param row DcCasesCargo
	 * @param rs ResultSet
	 * @param findBy String - finder to get data
	 * @throws SQLException
	 */
	public void getCustomRowFromResultSet(DcCasesCargo row, ResultSet rs,
			String findBy) throws SQLException {
		if (findBy.equalsIgnoreCase("findByNonFixedCertifications")
				|| findBy.equalsIgnoreCase("findByCaseNumNonFixedCert")
				|| findBy.equalsIgnoreCase("findByEmpRegEndDate")
				|| findBy.equalsIgnoreCase("findByPenaltyIncomeRemoval")
				|| findBy.equalsIgnoreCase("findBySpendDownMonitoringDt")
				|| findBy.equalsIgnoreCase("findByFixedCertifications")
				|| findBy.equalsIgnoreCase("findByMidSemiCertTrigger")
				|| findBy.equalsIgnoreCase("findSNAPFailureToReturnPacketByCutOffDt")
				|| findBy.equalsIgnoreCase("findFailureToReturnPacketByCutOffDt")
				|| "findAllCaseNumbers".equals(findBy)) {
			row.setCaseNum(rs.getLong("CASE_NUM"));
		}else if(findBy.equalsIgnoreCase("findByClosedCaseNum") || "findByTempPayee90DaysOld".equals(findBy)){
			row.setOfficeNum(rs.getLong("OFFICE_NUM"));
			row.setCaseNum(rs.getLong("CASE_NUM"));
		} else if(findBy.equalsIgnoreCase("findOfficeNumberByCaseNumber"))
		{
			row.setCaseNum(rs.getLong("CASE_NUM"));
			row.setOfficeNum(rs.getLong("OFFICE_NUM"));
		}else if(findBy.equalsIgnoreCase("findCaseNumList")){
			row.setCaseNum(rs.getLong("CASE_NUM"));
		}else if(findBy.equalsIgnoreCase("findByCasesList")){
			row.setCaseNum(rs.getLong("CASE_NUM"));
			row.setOfficeNum(rs.getLong("OFFICE_NUM"));
			row.setLanguageCd(rs.getString("LANGUAGE_CD"));
			row.setSpokenLanguageTypeCd(rs.getString("SPOKEN_LANGUAGE_TYPE_CD"));
			row.setEbtAcctNum(rs.getLong("EBT_ACCT_NUM"));
			row.setAvailDay(rs.getShort("AVAIL_DAY"));
		}else {
			getRowFromResultSet(row, rs);
		}
	}

	/**
	 * Method findByEmpRegEndDate fetches all the cases
	 * based on the ET_REG_END_DT from ED_INDV_ELIGIBILITY table.
	 * Added using WR BRGUS00208275 by AnandP on 11/11/2009
	 * @param maxRows int
	 * @param currMonthFirstDay String
	 * @param currMonthLastDay String
	 * @param asOfDate Timestamp
	 * @return DcCasesCargo[]
	 * @throws TIERSRunTimeException
	 */
	public DcCasesCargo[] findByEmpRegEndDate(int maxRows,
			String currMonthFirstDay, String currMonthLastDay, Timestamp asOfDate)
	throws TIERSRunTimeException {
		Debug.println("findByEmpRegEndDate" + " maxRows= " + maxRows);
		ArrayList v = new ArrayList();
		Connection conn = null;
		PreparedStatement statement = null;
		ResultSet rs = null;
		DcCasesCargo[] colrows = null;
		StringBuffer sqlClause = new StringBuffer();

		try {
			conn = getConnection();
			sqlClause.append("SELECT case_num");
			sqlClause.append("  FROM dc_cases dcc");
			sqlClause.append(" WHERE EXISTS");
			sqlClause.append(" (SELECT /*+ parallel(dcpb)*/");
			sqlClause.append("         NULL");
			sqlClause.append("          FROM dc_case_program dcpb");
			sqlClause.append("         WHERE dcpb.prog_cd IN ('FS', 'TF')");
			sqlClause.append("           AND prog_status_cd = 'AP'");
			sqlClause.append("           AND dcc.case_num = dcpb.case_num");
			sqlClause.append("           AND dcpb.eff_begin_dt <= ?");
			sqlClause.append("           AND (dcpb.eff_end_dt IS NULL OR dcpb.eff_end_dt >= ?)");
			sqlClause.append("           AND EXISTS");
			sqlClause.append("         (SELECT NULL");
			sqlClause.append("                  FROM v_rp_elig_details vrp");
			sqlClause.append("                 WHERE vrp.t1_case_num = dcpb.case_num");
			sqlClause.append("                   and vrp.t2_case_num = dcpb.case_num");
			sqlClause.append("                   AND et_reg_end_dt >= TO_DATE(?, 'YYYY-MM-DD')");
			sqlClause.append("                   AND et_reg_end_dt <= TO_DATE(?, 'YYYY-MM-DD')");
			sqlClause.append("                   AND program_cd IN ('FS', 'TF')");
			sqlClause.append("                   AND rec_end_dt IS NULL");
			sqlClause.append("                   AND current_elig_ind = 'A'");
			sqlClause.append("                   AND delete_sw = 'N'");
			sqlClause.append("                   AND cg_status_cd IN ('AP')");
			sqlClause.append("                   AND elig_rslt_cd = 'PS')) WITH UR");

			statement = conn.prepareStatement(sqlClause.toString());
			statement.setTimestamp(1, asOfDate);
			statement.setTimestamp(2, asOfDate);
			statement.setString(3, currMonthFirstDay);
			statement.setString(4, currMonthLastDay);

			rs = statement.executeQuery();

			int cnt = 0;
			while ( cnt++ < maxRows && rs.next() ) {
				DcCasesCargo row = new DcCasesCargo();
				getCustomRowFromResultSet(row, rs, "findByEmpRegEndDate");
				v.add(row);
			}
			colrows = new DcCasesCargo[v.size()];
			v.toArray(colrows);
		}
		catch (Exception e) {
			throw new TIERSRunTimeException(e.getMessage(), e);
		}
		finally {
			try {
				if (rs != null && getClose()) {
					rs.close();
				}
			}
			catch (SQLException e) {
				throw new TIERSRunTimeException(e.getClass().getName() + " " + e.getMessage(), e);
			}
			try {
				if (statement != null) {
					closeStatement("findByEmpRegEndDate", statement,maxRows,v.size());
					Debug.println("called close statement for findByEmpRegEndDate");
				}
			}
			catch (SQLException e) {
				Debug.println("exception in close statement for findByEmpRegEndDate");
				throw new TIERSRunTimeException(e.getClass().getName() + "findByEmpRegEndDate " + e.getMessage(), e);
			}
			try {
				if (conn != null && getClose()) {
					conn.close();
				}
			}
			catch (SQLException e) {
				throw new TIERSRunTimeException(e.getClass().getName() + " findByEmpRegEndDate" + e.getMessage(), e);
			}
		}
		return colrows;
	}