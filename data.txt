{
    "question": "What will be the output of this code?\n\n@Component\nclass ServiceA {\n    public String getMessage() {\n        return \"ServiceA\";\n    }\n}\n\n@Component\nclass ServiceB {\n    @Autowired\n    private ServiceA serviceA;\n\n    public String getMessage() {\n        return \"ServiceB -> \" + serviceA.getMessage();\n    }\n}\n\n@SpringBootApplication\npublic class Application {\n    public static void main(String[] args) {\n        ApplicationContext context = SpringApplication.run(Application.class, args);\n        ServiceB serviceB = context.getBean(ServiceB.class);\n        System.out.println(serviceB.getMessage());\n    }\n}",
    "answer": "The output will be: 'ServiceB -> ServiceA'. This is because Spring Boot's dependency injection provides the ServiceA bean to ServiceB."
  },
  {
    "question": "What happens when there is a circular dependency between two Spring beans?",
    "answer": "Spring Boot will throw a BeanCurrentlyInCreationException. Circular dependencies can be resolved using @Lazy or by refactoring the code to remove the dependency cycle."
  },
  {
    "question": "What will be the response to a GET request at '/test' when using @RestController?\n\n@RestController\nclass MyController {\n    @GetMapping(\"/test\")\n    public String test() {\n        return \"Hello from RestController\";\n    }\n}",
    "answer": "The response will be 'Hello from RestController' because @RestController combines @Controller and @ResponseBody, directly returning the string as the response body."
  },
  {
    "question": "What will happen if a property configured in application.properties is missing in the @ConfigurationProperties class?\n\n@Configuration\n@ConfigurationProperties(prefix = \"app\")\nclass AppConfig {\n    private String name;\n    private String version;\n\n    // getters and setters\n}",
    "answer": "If the property is missing, the corresponding field in the AppConfig class will remain null unless a default value is assigned in the class."
  },
  {
    "question": "What will be printed to the console?\n\n@Component\nclass LazyService {\n    public LazyService() {\n        System.out.println(\"LazyService initialized\");\n    }\n\n    public String getMessage() {\n        return \"LazyService is active\";\n    }\n}\n\n@SpringBootApplication\npublic class Application {\n    public static void main(String[] args) {\n        SpringApplication.run(Application.class, args);\n    }\n\n    @Bean\n    public CommandLineRunner runner(@Lazy LazyService lazyService) {\n        return args -> {\n            System.out.println(\"Runner is running\");\n            System.out.println(lazyService.getMessage());\n        };\n    }\n}",
    "answer": "The output will be:\n'Runner is running'\n'LazyService initialized'\n'LazyService is active'. The LazyService bean is initialized only when it is accessed in the runner."
  },
  {
    "question": "What will happen if a RuntimeException is thrown inside a @Transactional method?\n\n@Service\nclass MyService {\n    @Transactional\n    public void performTransaction() {\n        System.out.println(\"Transaction started\");\n        throw new RuntimeException(\"Exception occurred\");\n    }\n}",
    "answer": "The transaction will roll back because Spring automatically rolls back transactions for unchecked exceptions (subclasses of RuntimeException)."
  }