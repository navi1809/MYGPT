package gov.illinois.ies.business.batch.ffm.outbound;

import gov.illinois.framework.management.logging.ILog;
import gov.illinois.fw.batch.IESExceptionBO;
import gov.illinois.fw.batch.Controller.TIERSBatchController;
import gov.illinois.fw.business.exceptions.ApplicationException;
import gov.illinois.fw.business.exceptions.FrameworkException;
import gov.illinois.fw.business.exceptions.TIERSRunTimeException;
import gov.illinois.fw.business.exceptions.TIERSValidationException;
import gov.illinois.fw.business.rules.AbstractBO;
import gov.illinois.ies.business.entities.application.ArApplicationForAidCargo;
import gov.illinois.ies.business.entities.application.ArApplicationForAidCollection;
import gov.illinois.ies.business.entities.eligibility.EdIndvEligibilityCargo;
import gov.illinois.ies.business.entities.eligibility.EdIndvEligibilityCollection;
import gov.illinois.ies.business.entities.interfaces.AuInterfaceCargo;
import gov.illinois.ies.business.entities.interfaces.AuInterfaceCollection;
import gov.illinois.ies.business.entities.interfaces.InFfmInboundAppsCargo;
import gov.illinois.ies.business.entities.interfaces.InFfmInboundAppsCollection;
import gov.illinois.ies.business.entities.interfaces.InFfmOutboundQueueCargo;
import gov.illinois.ies.business.entities.interfaces.InFfmOutboundQueueCollection;

import java.sql.Connection;
import java.text.ParseException;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.concurrent.ExecutionException;

/**
 * @author usekar
 * 
 */
public class OutboundFFMBatchBO extends AbstractBO {

	/**
	 * Comment for <code>conn</code>
	 */
	private Connection conn = null;

	private TIERSBatchController batchController = null;

	IESExceptionBO exceptionBO = null;
	public int recordsRead = 0;
	public int processedRecords = 0;
	public int totalExceptions = 0;

	/**
	 * Method OutboundFFMBatchBO Initializes connection in class variable
	 * 
	 * @param aConn
	 *            -- contains the connection value
	 */
	public OutboundFFMBatchBO(Connection aConn) {
		super(aConn);
		this.conn = aConn;
	}

	/**
	 * Empty Constructor for the class OutboundFFMBatchBO
	 */
	public OutboundFFMBatchBO() {
		super();
	}

	public OutboundFFMBatchBO(TIERSBatchController batchController, Connection conn) {
		super(conn);
		this.batchController = batchController;
		this.exceptionBO = new IESExceptionBO(this.batchController);
		this.conn = conn;
	}

	/**
	 * This method is used to fetch records from InFfmInboundApps table based on
	 * sendToFfmInd
	 * 
	 * @return List<InFfmInboundAppsCargo>
	 * @throws ParseException
	 * @throws ApplicationException
	 * @throws FrameworkException
	 */
	public List<InFfmInboundAppsCargo> fetchInFfmInboundAppsRecords(int parameterValue) throws Exception {
		List<InFfmInboundAppsCargo> inFfmInboundAppsCargoList = new ArrayList();
		try {
			InFfmInboundAppsCollection inFfmInboundAppsCollection = null;
			InFfmInboundAppsCargo[] inFfmInboundAppsCargoArray = null;
			String sendToFfmInd_Q = OutboundFFMBatchContants.sendToFfmInd_Q;

			List argumentsList = new ArrayList();
			Object[] methodArgs = new Object[1];

			argumentsList.add(sendToFfmInd_Q);

			methodArgs[0] = argumentsList;

			inFfmInboundAppsCollection = new InFfmInboundAppsCollection(conn);
			inFfmInboundAppsCollection.setSelectSize(parameterValue);
			inFfmInboundAppsCargoArray = (InFfmInboundAppsCargo[]) inFfmInboundAppsCollection.select("findBySendToFfmInd", methodArgs);
			if (inFfmInboundAppsCargoArray != null && inFfmInboundAppsCargoArray.length > 0) {
				inFfmInboundAppsCargoList = Arrays.asList(inFfmInboundAppsCargoArray);
			}
		} catch (Exception e) {
			log(ILog.ERROR, "Exception in fetchInFfmInboundAppsRecords method of OutboundFFMBatchBO : " + e.getMessage());
			throw e;
		}

		return inFfmInboundAppsCargoList;

	}

	/**
	 * This method is used to insert records to IN_FFM_OUTBOUND_QUEUE table And
	 * Update the status in IN_FFM_INBOUND_APPS table after every succesful
	 * insert
	 * 
	 * @throws InterfacesException
	 * 
	 */
	public void insertandUpdate(List<InFfmInboundAppsCargo> inFfmInboundAppsCargoList, Map<Long, List<InFfmOutboundQueueCargo>> inFFMOutboundQueueMap) throws TIERSRunTimeException, TIERSValidationException, InterfacesException, Exception {
		log(ILog.DEBUG, "COUNTER ******* In OutboundFFMBatchBO.insertIntoInFfmOutboundQueue method, before inserting data into IN_FFM_OUTBOUND_QUEUE");

		InFfmOutboundQueueCollection inFfmOutboundQueueCollection = null;
		InFfmInboundAppsCollection inFfmInboundAppsCollection = null;
		InFfmOutboundQueueCargo inFfmOutboundQueueCargo = null;
		StringBuffer appNumBuf = new StringBuffer();
		appNumBuf.append("FFMOB");
		
		for (int i = 0; i < inFfmInboundAppsCargoList.size(); i++) {
			if(inFfmInboundAppsCargoList.get(i).getIesApplicationId() != null) {
				appNumBuf.append(",").append("'").append(inFfmInboundAppsCargoList.get(i).getIesApplicationId()).append("'");
			}
		}
		String appNumbers = appNumBuf.toString();
		if(appNumbers.length() > 0) {
			appNumbers = appNumbers.substring(1);
		}
		
		Map<String, Long> appNumMap = new HashMap<String, Long>();
		Object[] methodArgs = {appNumbers};
		ArApplicationForAidCollection arApplicationForAidCollection=new ArApplicationForAidCollection(connection);
		ArApplicationForAidCargo[] arApplicationForAidCargos = (ArApplicationForAidCargo[]) arApplicationForAidCollection.select("findByAppNumbers", methodArgs);
		if(arApplicationForAidCargos != null && arApplicationForAidCargos.length > 0){
			for (ArApplicationForAidCargo arApplicationForAidCargo : arApplicationForAidCargos) {
				appNumMap.put(arApplicationForAidCargo.getAppNum() , arApplicationForAidCargo.getCaseNum() != 0L ? arApplicationForAidCargo.getCaseNum() : arApplicationForAidCargo.getAssociatedCaseNum());
			}
		}
		
		if (inFfmInboundAppsCargoList != null && inFfmInboundAppsCargoList.size() > 0) {

			for (InFfmInboundAppsCargo inFfmInboundAppsCargo : inFfmInboundAppsCargoList) {

				inFfmInboundAppsCollection = new InFfmInboundAppsCollection(conn);

				try {
					
					inFfmOutboundQueueCargo = null;
					if (appNumMap != null && appNumMap.get(inFfmInboundAppsCargo.getIesApplicationId()) != null && appNumMap.get(inFfmInboundAppsCargo.getIesApplicationId()) != 0) {
						inFfmOutboundQueueCargo = constructInFfmOutboundQueueCargo(inFfmInboundAppsCargo, appNumMap.get(inFfmInboundAppsCargo.getIesApplicationId()));
					}
					
					inFfmOutboundQueueCollection = new InFfmOutboundQueueCollection(conn);
	
					if (null != inFfmOutboundQueueCargo) {
						inFfmOutboundQueueCollection.setCargo(inFfmOutboundQueueCargo);
						// Insert into InFfmOutboundQueue Table
						inFfmOutboundQueueCollection.insert(inFfmOutboundQueueCollection);
						
						if(inFFMOutboundQueueMap.containsKey(inFfmOutboundQueueCargo.getCaseNum())){
							List<InFfmOutboundQueueCargo> list = inFFMOutboundQueueMap.get(inFfmOutboundQueueCargo.getCaseNum());
							list.add(inFfmOutboundQueueCargo);
							inFFMOutboundQueueMap.put(inFfmOutboundQueueCargo.getCaseNum(), list);
						} else {
							List<InFfmOutboundQueueCargo> list = new ArrayList<InFfmOutboundQueueCargo>();
							list.add(inFfmOutboundQueueCargo);
							inFFMOutboundQueueMap.put(inFfmOutboundQueueCargo.getCaseNum(), list);
						}

						// Update InFfmInboundApps table with sendToFfmInd = "P"
						inFfmInboundAppsCargo.setSendToFfmInd(OutboundFFMBatchContants.sendToFfmInd_P);
						inFfmInboundAppsCollection.setCargo(inFfmInboundAppsCargo);
						inFfmInboundAppsCollection.update(inFfmInboundAppsCollection);

					} else {
						log(ILog.DEBUG, "In OutboundFFMBatchBO.insertIntoInFfmOutboundQueue method, no case found in AR_APPLICATION_FOR_AID table for the Inbound Application Id:" + inFfmInboundAppsCargo.getIesApplicationId());
					}
				} catch (Exception e) {
						// Update InFfmInboundApps table with sendToFfmInd = "F"
						inFfmInboundAppsCargo.setSendToFfmInd(OutboundFFMBatchContants.sendToFfmInd_F);
						inFfmInboundAppsCollection.setCargo(inFfmInboundAppsCargo);
						inFfmInboundAppsCollection.update(inFfmInboundAppsCollection);
						throw new Exception("Error in OutboundFFMBatchBO.insertIntoInFfmOutboundQueue :" + e.getMessage() + " for input record with Case Num " + inFfmOutboundQueueCargo.getCaseNum(),
								e);
					}
				}
			log(ILog.ERROR, "In OutboundFFMBatchBO.insertandUpdate: RECORDS FROM InFfmInboundAppsCargo ::" + inFfmInboundAppsCargoList.size());
		}
	}

	/**
	 * This method is used to Construct InFfmOutboundQueueCargo from
	 * InFfmInboundAppsCargo
	 * 
	 * @param inFfmInboundAppsCargo
	 * @return InFfmOutboundQueueCargo
	 */
	private InFfmOutboundQueueCargo constructInFfmOutboundQueueCargo(InFfmInboundAppsCargo inFfmInboundAppsCargo, long caseNumber) {
		InFfmOutboundQueueCargo inFfmOutboundQueueCargo = new InFfmOutboundQueueCargo();

		inFfmOutboundQueueCargo.setCaseNum(caseNumber);
		inFfmOutboundQueueCargo.setFfmApplicationId(inFfmInboundAppsCargo.getFfmApplicationId());
		inFfmOutboundQueueCargo.setFfmTransferId(inFfmInboundAppsCargo.getFfmTransferId());
		inFfmOutboundQueueCargo.setIesApplicationId(inFfmInboundAppsCargo.getIesApplicationId());
		inFfmOutboundQueueCargo.setSendToFfmInd(OutboundFFMBatchContants.N_CONSTANT);
		inFfmOutboundQueueCargo.setTransferToFfmDt(inFfmInboundAppsCargo.getFfmTransferDt());

		return inFfmOutboundQueueCargo;
	}

	/**
	 * @throws Exception
	 * @throws ExecutionException
	 * @throws InterruptedException
	 */
	public void sendDataToFFM() throws Exception {
		StringBuffer sendToFFMIndBuf = new StringBuffer();
		sendToFFMIndBuf.append("'").append("N").append("'");
		sendToFFMIndBuf.append(",'").append("T").append("'");
		List<InFfmOutboundQueueCargo> inFfmOutboundQueueCargoList = fetchOutboundDataToSendFFM(sendToFFMIndBuf.toString());
		Set<InFfmOutboundQueueCargo> inFfmOutboundQueueCargoSet = new HashSet<InFfmOutboundQueueCargo>(inFfmOutboundQueueCargoList);

		List<FFMOutboundVO> FFMOutboundVOList = new ArrayList<FFMOutboundVO>();
		FFMOutboundVO ffmOutboundVO = null;

		if (inFfmOutboundQueueCargoSet != null && inFfmOutboundQueueCargoSet.size() > 0) {
			for (InFfmOutboundQueueCargo inFfmOutboundQueueCargo : inFfmOutboundQueueCargoSet) {
				ffmOutboundVO = new FFMOutboundVO();
				ffmOutboundVO.setCaseNum("" + inFfmOutboundQueueCargo.getCaseNum());
				ffmOutboundVO.setDiActionDate(inFfmOutboundQueueCargo.getDiActionDt());
				ffmOutboundVO.setFfmApplicationId(inFfmOutboundQueueCargo.getFfmApplicationId());
				ffmOutboundVO.setFfmOutboundSeqNum(inFfmOutboundQueueCargo.getFfmOutboundQueueSeqNum());
				ffmOutboundVO.setFfmTransferId(inFfmOutboundQueueCargo.getFfmTransferId());
				ffmOutboundVO.setIesApplicationId(inFfmOutboundQueueCargo.getIesApplicationId());
				FFMOutboundVOList.add(ffmOutboundVO);
			}
		}
		log(ILog.ERROR, "COUNTER ******* In OutboundFFMBatchBO.sendDataToFFM: FINAL LIST TO sendDataToFFM ::" + FFMOutboundVOList.size());
		OutboundFFMHelper outboundFFMHelper = new OutboundFFMHelper(conn);
		recordsRead = FFMOutboundVOList.size();
		
		try {
			outboundFFMHelper.processFFMOutbound(FFMOutboundVOList, inFfmOutboundQueueCargoSet, conn);
		} catch (Exception e) {
			throw e;
		} finally {
			processedRecords = outboundFFMHelper.processedRecords;
			totalExceptions = outboundFFMHelper.totalExceptions;
		}
	}

	public List<Long> fetchEDEligibilityDataForCase(long caseNum, Set<Long> indvIdSet) throws Exception {
		List<Long> indvEligibilityMemberList = new ArrayList<Long>();
		try {
			Object[] methodArgs = new Object[2];

			methodArgs[0] = caseNum;
			StringBuffer indvIdString = new StringBuffer("");
			for (Long indvId : indvIdSet) {
				indvIdString.append("," + indvId);
			}
			methodArgs[1] = indvIdString.substring(1);
			EdIndvEligibilityCollection edIndvEligibilityCollection;
			EdIndvEligibilityCargo[] eligibilityCargoArray;

			edIndvEligibilityCollection = new EdIndvEligibilityCollection(conn);

			eligibilityCargoArray = (EdIndvEligibilityCargo[]) edIndvEligibilityCollection.select("findOutboundData", methodArgs);
			if (eligibilityCargoArray != null && eligibilityCargoArray.length > 0) {
				for (EdIndvEligibilityCargo cargo : eligibilityCargoArray)
					indvEligibilityMemberList.add(cargo.getIndvId());
			}
		} catch (Exception e) {
			log(ILog.ERROR, "Exception in OutboundFFMBatchBO fetchEDEligibilityDataForCase::caseNum=" + caseNum + e.getMessage());
			throw new Exception("Exception in OutboundFFMBatchBO fetchEDEligibilityDataForCase::caseNum=" + caseNum + e.getMessage(), e);
		}

		return indvEligibilityMemberList;

	}
	
	public Map<Long, List<Long>> fetchEDEligibilityDataForCase(Set<Long> caseNumSet) throws Exception {
		
		Map<Long, List<Long>> indvEligibilityMemberMap = new HashMap<Long, List<Long>>();
		try {

			EdIndvEligibilityCollection edIndvEligibilityCollection = new EdIndvEligibilityCollection(conn);

			EdIndvEligibilityCargo[] eligibilityCargoArray = (EdIndvEligibilityCargo[]) edIndvEligibilityCollection.select("findOutboundData", new Object[]{caseNumSet});
			
			if(eligibilityCargoArray != null && eligibilityCargoArray.length > 0){
				for (EdIndvEligibilityCargo eligibilityCargo : eligibilityCargoArray) {
					if(indvEligibilityMemberMap.containsKey(eligibilityCargo.getCaseNum())){
						List<Long> IndvList =  indvEligibilityMemberMap.get(eligibilityCargo.getCaseNum());
						IndvList.add(eligibilityCargo.getIndvId());
						indvEligibilityMemberMap.put(eligibilityCargo.getCaseNum(), IndvList);
					}else{
						List<Long> indvList =  new ArrayList<Long>();
						indvList.add(eligibilityCargo.getIndvId());
						indvEligibilityMemberMap.put(eligibilityCargo.getCaseNum(), indvList);	
					}
				}
			}
			
		} catch (Exception e) {
			log(ILog.ERROR, "Exception in OutboundFFMBatchBO fetchEDEligibilityDataForCase::" + e.getMessage());
			throw new Exception("Exception in OutboundFFMBatchBO fetchEDEligibilityDataForCase::" + e.getMessage(), e);
		}

		return indvEligibilityMemberMap;
	}

	public List<InFfmOutboundQueueCargo> fetchOutboundDataToSendFFM(String ffmInd) throws Exception {
		List<InFfmOutboundQueueCargo> inFfmOutboundQueueCargoList = new ArrayList<InFfmOutboundQueueCargo>();
		try {
			InFfmOutboundQueueCollection inFfmOutboundQueueCollection = null;
			InFfmOutboundQueueCargo[] inFfmOutboundQueueCargoArray = null;

			Object[] methodArgs = new Object[1];

			methodArgs[0] = ffmInd;
			inFfmOutboundQueueCollection = new InFfmOutboundQueueCollection(conn);

			inFfmOutboundQueueCargoArray = (InFfmOutboundQueueCargo[]) inFfmOutboundQueueCollection.select("findAppDataToProcess", methodArgs);
			if (inFfmOutboundQueueCargoArray != null && inFfmOutboundQueueCargoArray.length > 0) {
				inFfmOutboundQueueCargoList = Arrays.asList(inFfmOutboundQueueCargoArray);
			}
		} catch (Exception e) {
			log(ILog.ERROR, "Exception in fecthOutboundDataToSendFFM method of OutboundFFMBatchBO : " + e.getMessage());
			throw new Exception("Error While getting the ED Indv Eligibility Records for Processing", e);
		}

		return inFfmOutboundQueueCargoList;

	}

	public Map<Long, List<InFfmOutboundQueueCargo>> fetchOutboundDataByCaseNumToSendFFM(Set<Long> caseNumSet) throws Exception {
		Map<Long, List<InFfmOutboundQueueCargo>> inFFMOutBoundMap = new HashMap<Long, List<InFfmOutboundQueueCargo>>();
		try {
			InFfmOutboundQueueCollection inFfmOutboundQueueCollection = new InFfmOutboundQueueCollection(conn);
			InFfmOutboundQueueCargo[] inFfmOutboundQueueCargoArray = null;

			inFfmOutboundQueueCargoArray = (InFfmOutboundQueueCargo[]) inFfmOutboundQueueCollection.select("findAppDataForCaseNumAnddiActionDate", new Object[]{caseNumSet});
			if (inFfmOutboundQueueCargoArray != null && inFfmOutboundQueueCargoArray.length > 0) {
				
				for (InFfmOutboundQueueCargo inFfmOutboundQueueCargo : inFfmOutboundQueueCargoArray) {
					if(inFFMOutBoundMap.containsKey(inFfmOutboundQueueCargo.getCaseNum())){
						List<InFfmOutboundQueueCargo> list = inFFMOutBoundMap.get(inFfmOutboundQueueCargo.getCaseNum());
						list.add(inFfmOutboundQueueCargo);
						inFFMOutBoundMap.put(inFfmOutboundQueueCargo.getCaseNum(), list);
					} else {
						List<InFfmOutboundQueueCargo> list = new ArrayList<InFfmOutboundQueueCargo>();
						list.add(inFfmOutboundQueueCargo);
						inFFMOutBoundMap.put(inFfmOutboundQueueCargo.getCaseNum(), list);
					}
				}
			}
			
		} catch (Exception e) {
			log(ILog.ERROR, "Exception in fetchOutboundDataByCaseNumToSendFFM method of OutboundFFMBatchBO : " + e.getMessage());
			throw new Exception("Error While getting the ED Indv Eligibility Records for Processing", e);
		}

		return inFFMOutBoundMap;

	}

	/**
	 * This method is used to log the audit related information in the
	 * Au_Interface table
	 * 
	 * @throws ApplicationException
	 * @throws TIERSRunTimeException
	 */
	public void logAuditInfo() throws ApplicationException, TIERSRunTimeException {
		// audit info is built by calling InterfacesAuditHelper
		AuInterfaceCargo auInterfaceCargo = InterfacesAuditHelper.buildFfmOutboundBatchAuditInformation();
		// audit info is saved in au_interfaces table
		saveAuditDetails(auInterfaceCargo);
	}

	/**
	 * This method is used to save Audit Data to in the Au_Interface table
	 * 
	 * @param AuInterfaceCargo
	 * @throws ApplicationException
	 *             ,TIERSRunTimeException
	 */
	private void saveAuditDetails(AuInterfaceCargo auInterfacecargo) throws ApplicationException, TIERSRunTimeException {
		AuInterfaceCollection auInterfaceCollection = new AuInterfaceCollection(conn);
		auInterfaceCollection.setCargo((AuInterfaceCargo) auInterfacecargo);
		auInterfaceCollection.insert(auInterfaceCollection);
	}
}
