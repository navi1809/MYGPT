List<String> lines = Files.readAllLines(Paths.get("input.txt"));
lines.sort(Comparator
    .comparing((String s) -> s.substring(12, 18))  // 13–18 (0-based)
    .thenComparing(s -> s.substring(18, 27))       // 19–27
    .thenComparing(s -> s.substring(29, 30))       // 30
    .thenComparing(s -> s.substring(4, 6)));       // 5–6
Files.write(Paths.get("sorted_output.txt"), lines);



Perfect — let’s break it down clearly and create a shell script that mirrors exactly what the **JCL SORT FIELDS** does:

---

## 🔍 From the JCL:
```jcl
SORT FIELDS=(13,6,CH,A,19,9,CH,A,30,1,CH,A,5,2,CH,A)
```

This tells us:
- Sort by **characters 13 to 18** (length 6)
- Then **19 to 27** (length 9)
- Then **30** (length 1)
- Then **5 to 6** (length 2)
All fields are **character** and sorted **ascending**.

---

## 🛠 Shell Script Equivalent

```bash
#!/bin/bash

# File paths (update as needed)
INPUT_FILE="AIF11A_output.txt"
OUTPUT_FILE="AIF12A_input.txt"

# Perform sort using fixed-width character positions
# -k1.X,1.Y means sort using characters from X to Y (1-based indexing)
# Assumes no tabs in file, just flat text

sort \
  -k1.13,1.18 \    # field 1: chars 13–18
  -k1.19,1.27 \    # field 2: chars 19–27
  -k1.30,1.30 \    # field 3: char 30
  -k1.5,1.6   \    # field 4: chars 5–6
  "$INPUT_FILE" > "$OUTPUT_FILE"

echo "Sorted file written to $OUTPUT_FILE"
```

---

## 🧠 Explanation:

### ✅ `-k1.13,1.18`:
- `-k` = sort key
- `1.13` = line 1, character 13
- `1.18` = end at character 18

This mirrors the JCL's instruction to sort by that specific character range.