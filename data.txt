 /**
     * Gets Input File adapter given a logical file name 
     * @param aInpLogicalFileName
     * @return BatchFile
     * @throws TIERSBatchException
     */
    public BatchFile getInputFileName(String aInpLogicalFileName)
            throws TIERSBatchException {
        int irunNum = 0;
        String sJobId = null;
        String sAsOfDate = null;
        long lrecordCount = 0;
        FwBatchFileControlCargo fwbatFileCargo = null;
        BufferedReader br = null;
        BatchFile batFile = new BatchFile();
        String sinputFileName = null;
        String sFileName = null;
        try {
            fwbatFileCargo = bfcDAO.getMaxRunNumOfMaxAsOfDate(
                    getTIERSBatchControllerConnection(), jobId,
                    aInpLogicalFileName);
            if (fwbatFileCargo != null) {
            	// PMD_Override - R10 - The casting of this numeric/byte type
				// does not need to be addressed because - max daily runs for a
				// batch will not surpass the int limits.
            	PMDRules.markApprovedStatement("R10");
                irunNum = (int) fwbatFileCargo.getRunNum();
                sJobId = fwbatFileCargo.getJobId();
                sAsOfDate = fwbatFileCargo.getAsOfDt().toString();
                sAsOfDate = formatDate(sAsOfDate.substring(0, 10),
                        "yyyy-mm-dd", "mm-dd-yyyy");
                lrecordCount = fwbatFileCargo.getRecordCount();
                sFileName = fwbatFileCargo.getFileName();
                if (BatchConstants.FILE_BEING_PROCESSED_STATUS_CD == fwbatFileCargo
                        .getStatusCd()) {
                    System.err.println("WARNING: File " + aInpLogicalFileName
                            + " for asOfDate " + sAsOfDate
                            + " is still being written to.");
                }
            } else {
                throw new FileNotFoundException(
                        "No entry found in FW_BATCH_FILE_CONTROL for file: "
                                + aInpLogicalFileName);
            }
        } catch (FileNotFoundException fnfEx) {
            throw fnfEx;
        } catch (Exception ex) {
            throw new TIERSBatchException(
                    "Error in executing getMaxRunNumOfMaxAsOfDate while getting the Input File Name:  "
                            + ex.getMessage(), ex);
        }

        try {
            if (sFileName == null) {
                sinputFileName = fa.getInputFileName(sJobId,
                        aInpLogicalFileName, sAsOfDate, env, irunNum);
            } else {
                sinputFileName = fa.getInputFileName(sJobId, sFileName,
                        sAsOfDate, env, irunNum);
            }
        } catch (Exception ex) {
            throw new FileNotFoundException(
                    "Error in getting Input File name while getting the Input File Name: "+ex.getMessage(), ex);
        }

        if (sinputFileName == null) {
            throw new FileNotFoundException(
                    "Input File Name cannot be constructed");
        } else {
            try {
                br = exp.openInputFile(sinputFileName);
            } catch (Exception ex) {
                throw new FileNotFoundException(ex.getMessage(), ex);
            }
            try {
                batFile.setTIERSBatchControllerHandle(this);
                batFile.setRunNum(irunNum);
                batFile.setJobId(sJobId);
                batFile.setAsOfDt(sAsOfDate);
                batFile.setRecordCount(lrecordCount);
                batFile.setPhysicalFileName(sinputFileName);
                batFile.setLogicalFileName(aInpLogicalFileName);
                batFile.setBufferedReader(br);
            } catch (Exception ex) {
                throw new TIERSBatchException(
                        "Not able to return Batch File Adapter: "+ex.getMessage(), ex);
            }
            batchInputFileCollection.put(batFile.getLogicalFileName(), batFile);
            return batFile;
        }

    }

    /**
     * Returns information on whether a file or stream to persist has been
     * opened 
     * @return boolean returns true or false
     */
    public boolean getFilePersitence() {
        return gfilePersistence;
    }

    /**
     * Gets Output File adapter in stream format given a logical file 
     * @param aOutLogicalFileName
     * @return BatchFile
     * @throws TIERSBatchException
     */
    public BatchFile getOutputFileStream(String aOutLogicalFileName)
            throws TIERSBatchException {
        int irunNum = 0;
        String sAsOfDate = null;
        BufferedOutputStream bw = null;
        BatchFile batFile = new BatchFile();
        String soutputFileName = null;
        String sFileName = null;
        gfilePersistence = true;

        try {
            insertFileControlRecord(jobId, aOutLogicalFileName);
        } catch (Exception e) {
            throw new TIERSBatchException(
                    "Error in inserting the o/p file information into file control table."
                            + e.getMessage(), e);
        }
        try {
            if (isParallelRunProgram()) {
                irunNum = getParallelRunNum();
            } else {
                irunNum = getAdjustedMaximumRunNo();
            }
            sAsOfDate = getAsOfDate();
            sFileName = bfcDAO.getPhysicalFileName(
                    getTIERSBatchControllerConnection(), jobId,
                    aOutLogicalFileName);
            if (sFileName == null) {
                soutputFileName = fa.getOutputFileNames(jobId,
                        aOutLogicalFileName, overWriteFlag, irunNum, sAsOfDate,
                        env);
            } else {
                soutputFileName = fa.getOutputFileNames(jobId, sFileName,
                        overWriteFlag, irunNum, sAsOfDate, env);
            }
        } catch (Exception ex) {
            throw new TIERSBatchException(
                    "Error in getting the File Name or File Run Num: "+ex.getMessage(), ex);
        }

        if (soutputFileName == null) {
            throw new TIERSBatchException(
                    "Input File Name cannot be constructed");
        } else {
            try {
                bw = exp.openOutputStream(soutputFileName,
                        (isRestartProgram() || isParallelRunProgram())); //if
                                                                         // it
                                                                         // is
                                                                         // restart
                                                                         // or
                                                                         // parallel
                                                                         // the
                                                                         // file
                                                                         // will
                                                                         // be
                                                                         // opened
                                                                         // in
                                                                         // append
                                                                         // mode
            } catch (Exception ex) {
                throw new TIERSBatchException(ex.getMessage(), ex);
            }
            try {
                batFile.setTIERSBatchControllerHandle(this);
                batFile.setRunNum(irunNum);
                batFile.setJobId(jobId);
                batFile.setAsOfDt(sAsOfDate);
                batFile.setPhysicalFileName(soutputFileName);
                batFile.setLogicalFileName(aOutLogicalFileName);
                batFile.setBufferedOutputStream(bw);
            } catch (Exception ex) {
                throw new TIERSBatchException(
                        "Not able to return Batch File Adapter: "+ex.getMessage(), ex);
            }
            batchOutputFileCollection
                    .put(batFile.getLogicalFileName(), batFile);
            return batFile;
        }
    }

    /**
     * Gets Output File for Parallel Jobs 
     * @param aOutLogicalFileName
     * @return BatchFile
     * @throws TIERSBatchException
     */
    public BatchFile getOutPutFilenameForParllelJobs(String aOutLogicalFileName)
            throws TIERSBatchException {
        int  irunNum = 0;
        String sAsOfDate = null;
        BufferedWriter bw = null;
        BatchFile batFile = new BatchFile();
        String soutputFileName = null;
        String sFileName = null;
        gfilePersistence = true;
        try {
            insertFileControlRecordForParllelRun(jobId, aOutLogicalFileName);
        } catch (Exception e) {
            throw new TIERSBatchException(
                    "Error in inserting the o/p file information into file control table."
                            + e.getMessage(), e);
        }
        try {
            if (isParallelRunProgram() && !getParallelStream()) {
               // irunNum = getParallelRunNum();
                irunNum = Integer.parseInt(brcDAO.getParallelRunNum());
            } else {
                irunNum = getAdjustedMaximumRunNo();
                irunNum = brcDAO.getMaximumRunNoParallelJobInt(
                        getTIERSBatchControllerConnection(), jobId, asOfDate);
                irunNum++;
            }
            sAsOfDate = getAsOfDate();
            sFileName = bfcDAO.getPhysicalFileName(
                    getTIERSBatchControllerConnection(), jobId,
                    aOutLogicalFileName);
            if (sFileName == null) {
                soutputFileName = fa.getOutputFileNames(jobId,
                        aOutLogicalFileName, overWriteFlag, irunNum, sAsOfDate,
                        env);
            } else {
                soutputFileName = fa.getOutputFileNames(jobId, sFileName,
                        overWriteFlag, irunNum, sAsOfDate, env);
            }
        } catch (Exception ex) {
            throw new TIERSBatchException(
                    "Error in getting the File Name or File Run Num: "+ex.getMessage(), ex);
        }
        if (soutputFileName == null) {
            throw new TIERSBatchException(
                    "Input File Name cannot be constructed");
        } else {
            try {
                bw = exp.openOutputFile(soutputFileName,
                        (isRestartProgram() || isParallelRunProgram())); //if
                                                                         // it
                                                                         // is
                                                                         // restart
                                                                         // or
                                                                         // parallel
                                                                         // the
                                                                         // file
                                                                         // will
                                                                         // be
                                                                         // opened
                                                                         // in
                                                                         // append
                                                                         // mode
            } catch (Exception ex) {
                throw new TIERSBatchException(ex.getMessage(), ex);
            }
            try {
                batFile.setTIERSBatchControllerHandle(this);
                batFile.setRunNum(irunNum);
                batFile.setJobId(jobId);
                batFile.setAsOfDt(sAsOfDate);
                batFile.setPhysicalFileName(soutputFileName);
                batFile.setLogicalFileName(aOutLogicalFileName);
                batFile.setBufferedWriter(bw);
            } catch (Exception ex) {
                throw new TIERSBatchException(
                        "Not able to return Batch File Adapter: "+ex.getMessage(), ex);
            }
            batchOutputFileCollection
                    .put(batFile.getLogicalFileName(), batFile);
            return batFile;
        }
    }

    /**
     * Gets Output File in writer format given a logical file name 
     * @param aOutLogicalFileName 
     * @return BatchFile 
     * @throws TIERSBatchException
     */
    public BatchFile getOutputFileName(String aOutLogicalFileName)
            throws TIERSBatchException {
        int irunNum = 0;
        String sAsOfDate = null;
        BufferedWriter bw = null;
        BatchFile batFile = new BatchFile();
        String soutputFileName = null;
        String sFileName = null;
        gfilePersistence = true;
        try {
            insertFileControlRecord(jobId, aOutLogicalFileName);
        } catch (Exception e) {
            throw new TIERSBatchException(
                    "Error in inserting the o/p file information into file control table."
                            + e.getMessage(), e);
        }
        try {
            if (isParallelRunProgram() && !getParallelStream()) {
                irunNum = getParallelRunNum();
            } else {
                irunNum = getAdjustedMaximumRunNo();
            }
            sAsOfDate = getAsOfDate();
            sFileName = bfcDAO.getPhysicalFileName(
                    getTIERSBatchControllerConnection(), jobId,
                    aOutLogicalFileName);
            if (sFileName == null) {
                soutputFileName = fa.getOutputFileNames(jobId,
                        aOutLogicalFileName, overWriteFlag, irunNum, sAsOfDate,
                        env);
            } else {
                soutputFileName = fa.getOutputFileNames(jobId, sFileName,
                        overWriteFlag, irunNum, sAsOfDate, env);
            }
        } catch (Exception ex) {
            throw new TIERSBatchException(
                    "Error in getting the File Name or File Run Num: "+ex.getMessage(), ex);
        }
        if (soutputFileName == null) {
            throw new TIERSBatchException(
                    "Input File Name cannot be constructed");
        } else {
            try {
                bw = exp.openOutputFile(soutputFileName,
                        (isRestartProgram() || isParallelRunProgram())); //if
                                                                         // it
                                                                         // is
                                                                         // restart
                                                                         // or
                                                                         // parallel
                                                                         // the
                                                                         // file
                                                                         // will
                                                                         // be
                                                                         // opened
                                                                         // in
                                                                         // append
                                                                         // mode
            } catch (Exception ex) {
                throw new TIERSBatchException(ex.getMessage(), ex);
            }
            try {
                batFile.setTIERSBatchControllerHandle(this);
                batFile.setRunNum(irunNum);
                batFile.setJobId(jobId);
                batFile.setAsOfDt(sAsOfDate);
                batFile.setPhysicalFileName(soutputFileName);
                batFile.setLogicalFileName(aOutLogicalFileName);
                batFile.setBufferedWriter(bw);
            } catch (Exception ex) {
                throw new TIERSBatchException(
                        "Not able to return Batch File Adapter: "+ex.getMessage(), ex);
            }
            batchOutputFileCollection
                    .put(batFile.getLogicalFileName(), batFile);
            return batFile;
        }
    }
  //ILIES-197052 
    /**
     * Gets Output File in writer format given a logical file name 
     * @param aOutLogicalFileName , parentJobId
     * @return BatchFile 
     * @throws TIERSBatchException
     */
    public BatchFile getOutputFileNameInterfaceJobSplit(String aOutLogicalFileName,String parentJobId)
    throws TIERSBatchException {
		int irunNum = 0;
		String sAsOfDate = null;
		BufferedWriter bw = null;
		BatchFile batFile = new BatchFile();
		String soutputFileName = null;
		String sFileName = null;
		gfilePersistence = true;
		try {
		    insertFileControlRecord(jobId, aOutLogicalFileName);
		} catch (Exception e) {
		    throw new TIERSBatchException(
		            "Error in inserting the o/p file information into file control table."
		                    + e.getMessage(), e);
		}
		try {
		    if (isParallelRunProgram() && !getParallelStream()) {
		        irunNum = getParallelRunNum();
		    } else {
		        irunNum = getAdjustedMaximumRunNo();
		    }
		    sAsOfDate = getAsOfDate();
		    sFileName = bfcDAO.getPhysicalFileName(
		            getTIERSBatchControllerConnection(), jobId,
		            aOutLogicalFileName);
		    if (sFileName == null) {
		        soutputFileName = fa.getOutputFileNames(parentJobId,
		                aOutLogicalFileName, overWriteFlag, irunNum, sAsOfDate,
		                env);
		    } else {
		        soutputFileName = fa.getOutputFileNames(parentJobId, sFileName,
		                overWriteFlag, irunNum, sAsOfDate, env);
		    }
		} catch (Exception ex) {
		    throw new TIERSBatchException(
		            "Error in getting the File Name or File Run Num: "+ex.getMessage(), ex);
		}
		if (soutputFileName == null) {
		    throw new TIERSBatchException(
		            "Input File Name cannot be constructed");
		} else {
		    try {
		        bw = exp.openOutputFile(soutputFileName,
		                (isRestartProgram() || isParallelRunProgram())); //if
		                                                                 // it
		                                                                 // is
		                                                                 // restart
		                                                                 // or
		                                                                 // parallel
		                                                                 // the
		                                                                 // file
		                                                                 // will
		                                                                 // be
		                                                                 // opened
		                                                                 // in
		                                                                 // append
		                                                                 // mode
		    } catch (Exception ex) {
		        throw new TIERSBatchException(ex.getMessage(), ex);
		    }
		    try {
		        batFile.setTIERSBatchControllerHandle(this);
		        batFile.setRunNum(irunNum);
		        batFile.setJobId(jobId);
		        batFile.setAsOfDt(sAsOfDate);
		        batFile.setPhysicalFileName(soutputFileName);
		        batFile.setLogicalFileName(aOutLogicalFileName);
		        batFile.setBufferedWriter(bw);
		    } catch (Exception ex) {
		        throw new TIERSBatchException(
		                "Not able to return Batch File Adapter: "+ex.getMessage(), ex);
		    }
		    batchOutputFileCollection
		            .put(batFile.getLogicalFileName(), batFile);
		    return batFile;
		}
	}
	//ILIES-180619  Batch Run is taking prior month of DOB  
    /**
     * Gets Output File in writer format given a logical file name 
     * @param aOutLogicalFileName 
     * @return BatchFile 
     * @throws TIERSBatchException
     */
    public BatchFile getOutputFileName(String aOutLogicalFileName, String cutOffDate)
            throws TIERSBatchException {
        int irunNum = 0;
        String sAsOfDate = null;
        BufferedWriter bw = null;
        BatchFile batFile = new BatchFile();
        String soutputFileName = null;
        String sFileName = null;
        gfilePersistence = true;
        try {
            insertFileControlRecord(jobId, aOutLogicalFileName);
        } catch (Exception e) {
            throw new TIERSBatchException(
                    "Error in inserting the o/p file information into file control table."
                            + e.getMessage(), e);
        }
        try {
            if (isParallelRunProgram() && !getParallelStream()) {
                irunNum = getParallelRunNum();
            } else {
                irunNum = getAdjustedMaximumRunNo();
            }
            sAsOfDate = cutOffDate;
            sFileName = bfcDAO.getPhysicalFileName(
                    getTIERSBatchControllerConnection(), jobId,
                    aOutLogicalFileName);
            if (sFileName == null) {
                soutputFileName = fa.getOutputFileNames(jobId,
                        aOutLogicalFileName, overWriteFlag, irunNum, sAsOfDate,
                        env);
            } else {
                soutputFileName = fa.getOutputFileNames(jobId, sFileName,
                        overWriteFlag, irunNum, sAsOfDate, env);
            }
        } catch (Exception ex) {
            throw new TIERSBatchException(
                    "Error in getting the File Name or File Run Num: "+ex.getMessage(), ex);
        }
        if (soutputFileName == null) {
            throw new TIERSBatchException(
                    "Input File Name cannot be constructed");
        } else {
            try {
                bw = exp.openOutputFile(soutputFileName,
                        (isRestartProgram() || isParallelRunProgram())); //if
                                                                         // it
                                                                         // is
                                                                         // restart
                                                                         // or
                                                                         // parallel
                                                                         // the
                                                                         // file
                                                                         // will
                                                                         // be
                                                                         // opened
                                                                         // in
                                                                         // append
                                                                         // mode
            } catch (Exception ex) {
                throw new TIERSBatchException(ex.getMessage(), ex);
            }
            try {
                batFile.setTIERSBatchControllerHandle(this);
                batFile.setRunNum(irunNum);
                batFile.setJobId(jobId);
                batFile.setAsOfDt(sAsOfDate);
                batFile.setPhysicalFileName(soutputFileName);
                batFile.setLogicalFileName(aOutLogicalFileName);
                batFile.setBufferedWriter(bw);
            } catch (Exception ex) {
                throw new TIERSBatchException(
                        "Not able to return Batch File Adapter: "+ex.getMessage(), ex);
            }
            batchOutputFileCollection
                    .put(batFile.getLogicalFileName(), batFile);
            return batFile;
        }
    }

    /**
     * @deprecated since <unknown>
     * @return BufferedWriter
     * @throws TIERSBatchException
     */
    public BufferedWriter getSummaryReportFileHandle()
            throws TIERSBatchException {
        int irunNum = 0;
        String sAsOfDate = null;
        String soutputFileName = null;
        String sOutLogicalFileName = BatchConstants.SUMMARY_REPORT;

        try {
            irunNum = getAdjustedMaximumRunNo();
            sAsOfDate = getAsOfDate();
            soutputFileName = fa.getOutputFileNames(jobId, sOutLogicalFileName,
                    overWriteFlag, irunNum, sAsOfDate, env);
        } catch (Exception ex) {
            throw new TIERSBatchException(
                    "Error in getting the File Name or File Run Num: "+ex.getMessage(), ex);
        }

        if (soutputFileName == null) {
            throw new TIERSBatchException(
                    "Summary Report cannot be constructed");
        } else {
            try {
                return exp.openOutputFile(soutputFileName, true); //open in the
                                                                  // append mode
            } catch (Exception ex) {
                throw new TIERSBatchException(ex.getMessage(), ex);
            }
        }

    }

    /**
     * Gets Input File for a file name and AsOfDate
     * @param aInpLogicalFileName
     * @param aAsOfDt Has the as of date of the job
     * @return BatchFile returns batchfile Name
     *  @throws TIERSBatchException
     */
    public BatchFile getInputFileName(String aInpLogicalFileName, String aAsOfDt)
            throws TIERSBatchException {
        long irunNum = 0;
        String sJobId = null;
        long lrecordCount = 0;
        FwBatchFileControlCargo fwbatFileCargo = null;
        BufferedReader br = null;
        BatchFile batFile = new BatchFile();

        try {
            fwbatFileCargo = bfcDAO.getMaxRunNumOfAsOfDate(
                    getTIERSBatchControllerConnection(), jobId,
                    aInpLogicalFileName, aAsOfDt, true);
            if (fwbatFileCargo != null) {
                irunNum =  fwbatFileCargo.getRunNum();
                sJobId = fwbatFileCargo.getJobId();
                lrecordCount = fwbatFileCargo.getRecordCount();
            } else {
                throw new FileNotFoundException(
                        "No entry found in FW_BATCH_FILE_CONTROL for file: "
                                + aInpLogicalFileName + " for date: " + aAsOfDt);
            }
        } catch (FileNotFoundException fnfEx) {
            throw fnfEx;
        } catch (Exception ex) {
            throw new TIERSBatchException(
                    "Error in executing getMaxRunNumOfAsOfDate while getting the Input File Name : "
                            + ex.getMessage(), ex);
        }

        String sinputFileName = fa.getInputFileName(sJobId,
                aInpLogicalFileName, aAsOfDt, env, irunNum);

        if (sinputFileName == null) {
            throw new FileNotFoundException(
                    "Input File Name cannot be constructed");
        } else {
            try {
                br = exp.openInputFile(sinputFileName);
            } catch (Exception ex) {
                throw new FileNotFoundException(ex.getMessage(), ex);
            }
            try {
                batFile.setTIERSBatchControllerHandle(this);
                batFile.setRunNum(Integer.parseInt(String.valueOf(irunNum)));
                batFile.setJobId(sJobId);
                batFile.setAsOfDt(aAsOfDt);
                batFile.setRecordCount(lrecordCount);
                batFile.setPhysicalFileName(sinputFileName);
                batFile.setLogicalFileName(aInpLogicalFileName);
                batFile.setBufferedReader(br);
                if (BatchConstants.FILE_BEING_PROCESSED_STATUS_CD == fwbatFileCargo
                        .getStatusCd()) {
                    System.err.println("WARNING: File " + aInpLogicalFileName
                            + " for asOfDate " + aAsOfDt
                            + " is still being written to.");
                }
            } catch (Exception ex) {
                throw new TIERSBatchException(
                        "Not able to return Batch File Adapter: "+ex.getMessage(), ex);
            }
            batchInputFileCollection.put(batFile.getLogicalFileName(), batFile);
            return batFile;
        }
    }

    /**
     * Gets max Input File given the file name and a range of dates
     * @param aInpLogicalFileName inputlogical file name 
     * @param abeginAsOfDt Has the begin asOfDate
     * @param aendAsOfDt Has the end asOfDate
     * @return BatchFile returns batch fileName
     * @throws TIERSBatchException  
     */
    public BatchFile getInputFileName(String aInpLogicalFileName,
            String abeginAsOfDt, String aendAsOfDt) throws TIERSBatchException {
        int irunNum = 0;
        String sJobId = null;
        String asOfDateLocal = null;
        long lrecordCount = 0;
        FwBatchFileControlCargo fwbatFileCargo = null;
        BufferedReader br = null;
        BatchFile batFile = new BatchFile();

        try {
            fwbatFileCargo = bfcDAO.getMaxRunNumOfAsOfDateRange(
                    getTIERSBatchControllerConnection(), jobId,
                    aInpLogicalFileName, abeginAsOfDt, aendAsOfDt);
            if (fwbatFileCargo != null) {
				// PMD_Override - R10 - The casting of this numeric/byte type
				// does not need to be addressed because - max daily runs for a
				// batch will not surpass the int limits.
            	PMDRules.markApprovedStatement("R10");
                irunNum = (int) fwbatFileCargo.getRunNum();
                sJobId = fwbatFileCargo.getJobId();
                lrecordCount = fwbatFileCargo.getRecordCount();
                asOfDateLocal = fwbatFileCargo.getAsOfDt().toString();
                asOfDateLocal = formatDate(asOfDateLocal.substring(0, 10),
                        "yyyy-mm-dd", "mm-dd-yyyy");
            } else {
                throw new FileNotFoundException(
                        "No entry found in FW_BATCH_FILE_CONTROL for file: "
                                + aInpLogicalFileName + " for date between: "
                                + aendAsOfDt + "---" + abeginAsOfDt);
            }
        } catch (FileNotFoundException fnfEx) {
            throw fnfEx;
        } catch (Exception ex) {
            throw new TIERSBatchException(
                    "Error in executing getMaxRunNumOfAsOfDate while getting the Input File Name : "
                            + ex.getMessage(), ex);
        }
        String sinputFileName = fa.getInputFileName(sJobId,
                aInpLogicalFileName, asOfDateLocal, env, irunNum);
        if (sinputFileName == null) {
            throw new FileNotFoundException(
                    "Input File Name cannot be constructed");
        } else {
            try {
                br = exp.openInputFile(sinputFileName);
            } catch (Exception ex) {
                throw new FileNotFoundException(ex.getMessage(), ex);
            }
            try {
                batFile.setTIERSBatchControllerHandle(this);
                batFile.setRunNum(irunNum);
                batFile.setJobId(sJobId);
                batFile.setAsOfDt(asOfDateLocal);
                batFile.setRecordCount(lrecordCount);
                batFile.setPhysicalFileName(sinputFileName);
                batFile.setLogicalFileName(aInpLogicalFileName);
                batFile.setBufferedReader(br);
                if (BatchConstants.FILE_BEING_PROCESSED_STATUS_CD == fwbatFileCargo
                        .getStatusCd()) {
                    System.err.println("WARNING: File " + aInpLogicalFileName
                            + " for asOfDate " + asOfDateLocal
                            + " is still being written to.");
                }
            } catch (Exception ex) {
                throw new TIERSBatchException(
                        "Not able to return Batch File Adapter: "+ex.getMessage(), ex);
            }
            batchInputFileCollection.put(batFile.getLogicalFileName(), batFile);
            return batFile;
        }
    }

    /**
     * This method returns an array of output file names. 
     * @deprecated
     * @param aOutLogicalFileNames 
     * @return String[]
     * @throws TIERSBatchException
     */
    public String[] getOutputFileNames(String[] aOutLogicalFileNames)
            throws TIERSBatchException {
        StringBuffer[] outFileNamesBuffer = null;
        try {
            outFileNamesBuffer = fa.getOutputFileNames(jobId,
                    aOutLogicalFileNames, overWriteFlag, env, this);
        } catch (Exception ex) {
            throw new TIERSBatchException(
                    "Error in getting the Output file name from File Assembler: "+ex.getMessage(), ex);
        }
        if (outFileNamesBuffer == null) {
            throw new TIERSBatchException("Output File Names Araay is NULL");
        } else {
            String[] outFileNames = new String[outFileNamesBuffer.length];
            int length = outFileNamesBuffer.length;
            for (int i = 0; i < length; i++) {
                outFileNames[i] = outFileNamesBuffer[i].toString();
            }
            return outFileNames;
        }
    }

    /**
     * This method sets the jobId
     * @param aJobId The identifier for the job
     */
    public void setJobId(String aJobId) {
        this.jobId = aJobId;
        StringTokenizer stk = new StringTokenizer(jobId, "-");
        StringBuffer sbf = new StringBuffer();
        while (stk.hasMoreTokens()) {
            sbf.append(stk.nextToken());
        }
        createUpdateUserId = sbf.toString();
        batchConnManager.setJobID(jobId);
        createContext(createUpdateUserId);
        thresholdValue = getThresholdValue(jobId);
        System.setProperty(FwConstants.BATCH_JOB_ID, jobId);
    }

    /**
     * Sets Parallel Run Id 
     * @param aparallelRunId Has the run Id of the parallel run
     */
    public void setParallelRunId(String aparallelRunId) {
        this.parallelRunId = aparallelRunId;
        parallelRunProgram = BatchConstants.YES;
    }

    /**
     * Gets Parallel Run Id
     * @return String returns parallel runId
     */
    public String getParallelRunId() {
        if (this.parallelRunId == null) {
            return this.jobId;
        } else {
            return this.parallelRunId;
        }
    }

    /**
     * Gets Parallel Run Num 
     * @return int returns parallel runNum
     * @throws TIERSBatchException 
     */
    public int getParallelRunNum() throws TIERSBatchException {
        return brcDAO.getParallelRunNo(getTIERSBatchControllerConnection(),
                jobId, getParallelRunId(), getAsOfDate());
    }

    /**
     * Gets Curent Run Num 
     * @return int
     * @throws TIERSBatchException
     */
    public int getCurrentRunNum() throws TIERSBatchException {
        if (!currentRunNoSet) {
            currentRunNo = brcDAO.getMaximumRunNoInt(getTIERSBatchControllerConnection(), jobId, getAsOfDate());
            currentRunNo++;
            currentRunNoSet = true;
        }
        return currentRunNo;
    }

    /**
     * Gets Jobid 
     * @return String returns jobId
     */
    public String getJobId() {
        return this.jobId;
    }

    /**
     * Sets Program Name 
     * @param aProgramName 
     */
    public void setProgramName(String aProgramName) {
        this.programName = aProgramName;
    }

    /**
     * Sets overwrite flag 
     * @param aOverWriteFlag 
     */
    public void setOverWriteFlag(boolean aOverWriteFlag) {
        this.overWriteFlag = aOverWriteFlag;
    }

    /**
     * Gets Parameters 
     * @return BatchParameter
     * @throws TIERSBatchException
     */
    public BatchParameter getParameters() throws TIERSBatchException {
        BatchParameter bParms = null;
        try {
            bParms = bpcDAO.findParameters(getTIERSBatchControllerConnection(),
                    jobId, "OverLoadedDummyOperation");
            if (bParms != null) {
                asOfDate = bParms.getAsOfDate();
            }
        } catch (Exception ex) {
            throw new TIERSBatchException("Error in finding the parameter: "+ex.getMessage(), ex);
        }

        if (bParms == null) {
            throw new TIERSBatchException("Parameter vector is NULL");
        } else {
            return bParms;
        }
    }

    /**  
     * @param aJobId The identifier for the job
     * @param aProgramName
     * @param aoverWriteFlag 
     * @return Vector
     * @throws TIERSBatchException
     */
    public Vector getParameters(String aJobId, String aProgramName,
            boolean aoverWriteFlag) throws TIERSBatchException {

        overWriteFlag = aoverWriteFlag;
        jobId = aJobId;
        StringTokenizer stk = new StringTokenizer(jobId, "-");
        StringBuffer sbf = new StringBuffer();
        while (stk.hasMoreTokens()) {
            sbf.append(stk.nextToken());
        }
        createUpdateUserId = sbf.toString();
        programName = aProgramName;

        //Get the Job Name from FW_BATCH_PARAMETER Table using job id

        try {
            parms = bpcDAO.findParameters(getTIERSBatchControllerConnection(),
                    jobId);
        } catch (Exception ex) {
            throw new TIERSBatchException("Error in finding the parameter: "+ex.getMessage(), ex);
        }

        if (parms == null) {
            throw new TIERSBatchException("Parameter vector is NULL");
        } else {
            return parms;
        }
    }

    /**
     * This method returns a vector of parameters of the record with Global
     * JobID as Job Id and a specific Functional Area Id, Job Id and Program
     * Name.
     * @param aJobId The identifier for the job
     * @param aProgramName 
     * @return Vector returns a vector of parameters
     * @throws TIERSBatchException
     */
    public Vector getParameters(String aJobId, String aProgramName)
            throws TIERSBatchException {

        jobId = aJobId;
        StringTokenizer stk = new StringTokenizer(jobId, "-");
        StringBuffer sbf = new StringBuffer();
        while (stk.hasMoreTokens()) {
            sbf.append(stk.nextToken());
        }
        createUpdateUserId = sbf.toString();
        programName = aProgramName;

        try {
            parms = bpcDAO.findParameters(getTIERSBatchControllerConnection(),
                    jobId);

        } catch (Exception ex) {
            throw new TIERSBatchException("Error in finding the parameter: "+ex.getMessage(), ex);
        }

        if (parms == null) {
            throw new TIERSBatchException("Parameter vector is NULL");
        } else {
            return parms;
        }
    }

    /**
     * This method returns a ArrayList of parameters of the record with Gloabla
     * JobID as Job Id and a specific Functional Area Id, Job Id and Program
     * Name 
     * @param aJobId The identifier for the job
     * @param aProgramName 
     * @return ArrayList returns a arrayList of parameters
     * @throws TIERSBatchException
     */
    public ArrayList getParameter(String aJobId, String aProgramName)
            throws TIERSBatchException {
        jobId = aJobId;
        StringTokenizer stk = new StringTokenizer(jobId, "-");
        StringBuffer sbf = new StringBuffer();
        ArrayList lParms = null;
        while (stk.hasMoreTokens()) {
            sbf.append(stk.nextToken());
        }
        createUpdateUserId = sbf.toString();
        programName = aProgramName;
        try {
            lParms = bpcDAO.findParameter(getTIERSBatchControllerConnection(),
                    jobId);
        } catch (Exception ex) {
            throw new TIERSBatchException("Error in finding the parameter: "+ex.getMessage(), ex);
        }
        if (lParms == null) {
            throw new TIERSBatchException("Parameter vector is NULL");
        } else {
            return lParms;
        }
    }

    /**
     * This method returns the Run No of a given file.
     * @param aJobId The identifier for the job
     * @param aLogicalFileName
     * @param aFileMode
     * @return int
     * @throws TIERSBatchException
     */
    public int getRunNo(String aJobId, String aLogicalFileName, String aFileMode)
            throws TIERSBatchException {
        int runNo = 0;
        try {
            runNo = bfcDAO.getRunNo(getTIERSBatchControllerConnection(),
                    aJobId, aLogicalFileName, getAsOfDate(), aFileMode);
        } catch (Exception ex) {
            throw new TIERSBatchException("Error in getting the Run Number: "+ex.getMessage(), ex);
        } finally {
            
        }
        return runNo;
    }

    /**
     * This method returns the Start Date and Time of the program (recorded when
     * a record is inserted into FW_BATCH_RUN_CONTROL Table.
     * @return String
     * @throws TIERSBatchException  
     */
    public String getStartDateTime() throws TIERSBatchException {
        if (startDateTime == null) {
            throw new TIERSBatchException("Start Date Time is NULL");
        } else {
            return startDateTime;
        }
    }

    /**
     * This method returns Properties object.
     * @deprecated since <unknown>
     * @return Properties
     * @throws TIERSBatchException
     */
    public Properties getTIERSProperties() throws TIERSBatchException {
        try {
            if (batchProperty == null) {
                if (propsFileName == null) {
                    //Assign the argument aPath to path to use while invoking
                    // getRunNo from getOutputFileNames of File Assembler
                    //InputStream is =
                    // Class.forName("gov.illinois.fw.batch.Controller.TIERSBatchController").getResourceAsStream(BatchConstants.PROPERTIES_FILE);
                    //props.load(is);
                    batchProperty = FwPropertyLoader
                            .getProperties(BatchConstants.PROPERTIES_FILE);
                } else {
                    batchProperty.load(new FileInputStream(new File(
                    		FilenameUtils.normalize(propsFileName))));
                }
            }
        } catch (Exception ex) {
            throw new TIERSBatchException("Error in loading the error file: "+ex.getMessage(), ex);
        }
        if (batchProperty == null) {
            throw new TIERSBatchException("Property is NULL");
        } else {
            return batchProperty;
        }
    }

    /**
     * This method returns Properties object. Code added for Reports informatica enhancement
     * @deprecated since <unknown>
     * @return Properties
     * @throws TIERSBatchException
     */
    public Properties getInformaticaProperties() throws TIERSBatchException {
        try {
        	informaticaProperties = FwPropertyLoader.getProperties(BatchConstants.INFORMATICA_PROPERTIES_FILE);
        } catch (Exception ex) {
            throw new TIERSBatchException("Error in loading the error file: "+ex.getMessage(), ex);
        }
        if (informaticaProperties == null) {
            throw new TIERSBatchException("Informatica Property is NULL");
        } else {
            return informaticaProperties;
        }
    }
    
    
    /**
     * This method returns the System Time Stamp in the format MM-DD-YY
     * HH:MM:SS.
     * @return String 
     * @throws TIERSBatchException  
     */
    public static String getTimeStamp() throws TIERSBatchException {
        String ts = null;
        try {
            GregorianCalendar gc = new GregorianCalendar();
            int month = gc.get(GregorianCalendar.MONTH);
            String year = "" + gc.get(GregorianCalendar.YEAR);
            int day = gc.get(GregorianCalendar.DAY_OF_MONTH);
            int hour = gc.get(GregorianCalendar.HOUR_OF_DAY);
            int minute = gc.get(GregorianCalendar.MINUTE);
            int second = gc.get(GregorianCalendar.SECOND);
            ts = (month + 1) + "-" + day + "-" + year + " " + hour + ":"
                    + minute + ":" + second;
        } catch (Exception ex) {
            throw new TIERSBatchException("Error in formatting the TimeStamp: "+ex.getMessage(), ex);
        }

        if (ts == null) {
            throw new TIERSBatchException("Time Stamp is NULL");
        } else {
            return ts;
        }

    }
    
    /**
     * This method inserts into File Control for Parallel run
     * @return String returns true or false
     * @throws TIERSBatchException  
     */
    public boolean insertFileControlRecordForParllelRun(String ajobId,
            String aLogicalFileName) throws TIERSBatchException {
        int runNo = 0;

        try {
            if (isParallelRunProgram() && !getParallelStream()) {
               // runNo = getParallelRunNum();
                runNo = Integer.parseInt(brcDAO.getParallelRunNum());
            } else {
                long run = 0;
                runNo = getAdjustedMaximumRunNo();
                runNo = brcDAO.getMaximumRunNoParallelJobInt(
                        getTIERSBatchControllerConnection(), ajobId, getAsOfDate());
                runNo++;

            }
          //  System.err.println("Run Number :" + runNo);
            return bfcDAO.insertFileControlRecord(
                    getTIERSBatchControllerConnection(), ajobId,
                    aLogicalFileName, getAsOfDate(), runNo, createUpdateUserId);
        } catch (Exception ex) {
            throw new TIERSBatchException(
                    "Error in inserting the insertFileControlRecord "
                            + ex.getMessage(), ex);
        }
    }

    /**
     * This method returns boolean status of insertion of a record into
     * FW_BATCH_FILE_CONTROL table.
     * @param ajobId The identifier for the job
     * @param aLogicalFileName file name from the external source
     * @return boolean returns true or false
     * @throws TIERSBatchException
     */
    public boolean insertFileControlRecord(String ajobId,
            String aLogicalFileName) throws TIERSBatchException {
        int runNo = 0;

        try {
            if (isParallelRunProgram() && !getParallelStream()) {
                runNo = getParallelRunNum();
            } else {
                long run = 0;
                runNo = getAdjustedMaximumRunNo();

            }
        //    System.err.println("Run Number :" + runNo);
            return bfcDAO.insertFileControlRecord(
                    getTIERSBatchControllerConnection(), ajobId,
                    aLogicalFileName, getAsOfDate(), runNo, createUpdateUserId);
        } catch (Exception ex) {
            throw new TIERSBatchException(
                    "Error in inserting the insertFileControlRecord "
                            + ex.getMessage(), ex);
        }
    }

    /**
     * This method returns boolean status of insertion of a record into
     * FW_BATCH_RUN_CONTROL table.
     * @deprecated since <unknown>
     * @return boolean
     * @throws RunningProcessException
     * @throws TIERSBatchException
     */
    public boolean insertRunControlRecord() throws RunningProcessException,
            TIERSBatchException {
        boolean insertSuccessful = false;
        String timeStamp = null;
        try {
            if (asOfDate == null) {
                asOfDate = bpcDAO.findAsOfDate(
                        getTIERSBatchControllerConnection(), jobId);
            }
        } catch (Exception ex) {
            throw new TIERSBatchException("Error in finding AsOfDate "
                    + ex.getMessage(), ex);
        }
        try {
            timeStamp = getTimeStamp();
        } catch (Exception ex) {
            throw new TIERSBatchException("Error in finding TimeStamp "
                    + ex.getMessage(), ex);
        }
        startDateTime = timeStamp;

        try {
            if (isParallelRunProgram()) {
            	if (isLoadUtility){
            		
            		insertSuccessful = brcDAO.insertRunControlRecord(
                            getTIERSBatchControllerConnection(), jobId.substring(0,9)+"LDU",
                            getParallelRunId(), getAsOfDate(), BatchConstants.START,
                            overWriteFlag, isRestartProgram(), createUpdateUserId,errorLogContext);
            	}
            	else
            	{
            		insertSuccessful = brcDAO.insertRunControlRecord(
                            getTIERSBatchControllerConnection(), jobId,
                            getParallelRunId(), getAsOfDate(), BatchConstants.START,
                            overWriteFlag, isRestartProgram(), createUpdateUserId,errorLogContext);
            	}
                
            } else {
            	if (isLoadUtility){
            		
            		insertSuccessful = brcDAO.insertRunControlRecord(
                            getTIERSBatchControllerConnection(), jobId.substring(0,9)+"LDU", getAsOfDate(),
                            BatchConstants.START, overWriteFlag,
                            isRestartProgram(), createUpdateUserId,errorLogContext);
            	}
            	else
            	{
            		insertSuccessful = brcDAO.insertRunControlRecord(
                            getTIERSBatchControllerConnection(), jobId, getAsOfDate(),
                            BatchConstants.START, overWriteFlag,
                            isRestartProgram(), createUpdateUserId,errorLogContext);
            	}
                
            }
          
        } catch (RunningProcessException rpex) {
            throw new TIERSBatchException("Process already running "
                    + rpex.getMessage(), rpex);
        } catch (Exception ex) {
            throw new TIERSBatchException("Error in inserting RunControl "
                    + ex.getMessage(), ex);
        }
        return insertSuccessful;
    }
    
    /**
     * This method returns boolean status of insertion of a record into
     * FW_BATCH_RUN_CONTROL table.
     * @deprecated since <unknown>
     * @return boolean
     * @throws RunningProcessException
     * @throws TIERSBatchException
     */
    public boolean insertRunControlRecord(Connection con) throws RunningProcessException,
            TIERSBatchException {
        boolean insertSuccessful = false;
        String timeStamp = null;
        try {
            if (asOfDate == null) {
                asOfDate = bpcDAO.findAsOfDate(
                        con, jobId);
            }
        } catch (Exception ex) {
            throw new TIERSBatchException("Error in finding AsOfDate "
                    + ex.getMessage(), ex);
        }
        try {
            timeStamp = getTimeStamp();
        } catch (Exception ex) {
            throw new TIERSBatchException("Error in finding TimeStamp "
                    + ex.getMessage(), ex);
        }
        startDateTime = timeStamp;

        try {
            if (isParallelRunProgram()) {
            	if (isLoadUtility){
            		
            		insertSuccessful = brcDAO.insertRunControlRecord(
                            con, jobId.substring(0,9)+"LDU",
                            getParallelRunId(), getAsOfDate(), BatchConstants.START,
                            overWriteFlag, isRestartProgram(), createUpdateUserId,errorLogContext);
            	}
            	else
            	{
            		insertSuccessful = brcDAO.insertRunControlRecord(
                            con, jobId,
                            getParallelRunId(), getAsOfDate(), BatchConstants.START,
                            overWriteFlag, isRestartProgram(), createUpdateUserId,errorLogContext);
            	}
                
            } else {
            	if (isLoadUtility){
            		
            		insertSuccessful = brcDAO.insertRunControlRecord(
                            con, jobId.substring(0,9)+"LDU", getAsOfDate(),
                            BatchConstants.START, overWriteFlag,
                            isRestartProgram(), createUpdateUserId,errorLogContext);
            	}
            	else
            	{
            		insertSuccessful = brcDAO.insertRunControlRecord(
                            con, jobId, getAsOfDate(),
                            BatchConstants.START, overWriteFlag,
                            isRestartProgram(), createUpdateUserId,errorLogContext);
            	}
               
            }
          
        } catch (RunningProcessException rpex) {
            throw new TIERSBatchException("Process already running "
                    + rpex.getMessage(), rpex);
        } catch (Exception ex) {
            throw new TIERSBatchException("Error in inserting RunControl "
                    + ex.getMessage(), ex);
        }
        return insertSuccessful;
    }
    
    /**
     * This method returns HashMap populated with logical file name and a vector
     * containing physical file name, record count and buffered writer/reader
     * @param aJobIds The identifier for the job
     * @param aInpLogicalFileNamesAndDates 
     * @param aInputFileNames 
     * @param aRunNos 
     * @param aOutLogicalFileNames 
     * @param aOutputFileNames 
     * @return HashMap 
     * @throws TIERSBatchException  
     */
    public HashMap openFiles(String[] aJobIds,
            String[][] aInpLogicalFileNamesAndDates, String[] aInputFileNames,
            int[] aRunNos, String[] aOutLogicalFileNames,
            String[] aOutputFileNames) throws TIERSBatchException {

        long[] recordCounts = new long[aInputFileNames.length];
        HashMap lookupTableLocal = null;
        try {
            int recordCountsLength = recordCounts.length;
            for (int i = 0; i < recordCountsLength; i++) {
                recordCounts[i] = bfcDAO.getRecordCount(
                        getTIERSBatchControllerConnection(), aJobIds[i],
                        aInpLogicalFileNamesAndDates[i][0], getAsOfDate(),
                        aRunNos[i]);
            }
        } catch (Exception ex) {
            throw new TIERSBatchException(
                    "Error getting the record for record count: "
                            + ex.getMessage(), ex);
        }

        try {
            lookupTableLocal = exp.openFiles(aInpLogicalFileNamesAndDates,
                    aInputFileNames, recordCounts, aOutLogicalFileNames,
                    aOutputFileNames, overWriteFlag);
        } catch (Exception ex) {
            throw new TIERSBatchException("Error getting the physical Files "
                    + ex.getMessage(), ex);
        }

        if (lookupTableLocal == null) {
            throw new TIERSBatchException("Lookup Table is NULL");
        } else {
            return lookupTableLocal;
        }
    }

    /**
     * This method returns HashMap populated with logical file name and a vector
     * containing physical file name, record count and buffered writer/reader.
     * @param aOutLogicalFileNames
     * @param aOutputFileNames
     * @return HashMap 
     * @throws TIERSBatchException  
     */
    public HashMap openFiles(String[] aOutLogicalFileNames,
            String[] aOutputFileNames) throws TIERSBatchException {
        HashMap lookupTableLocal = null;

        try {
            lookupTableLocal = exp.openFiles(aOutLogicalFileNames,
                    aOutputFileNames, overWriteFlag);
        } catch (Exception ex) {
            throw new TIERSBatchException("Error in Opening Files "
                    + ex.getMessage(), ex);
        }
        if (lookupTableLocal == null) {
            throw new TIERSBatchException("Lookup Table is NULL");
        } else {
            return lookupTableLocal;
        }
    }

    /**
     * This method builds a HashMap containing logical file (input and output)
     * name as key and a vector containing physical file name, record count and
     * the corresponding buffered writer/reader.
     * @param aInputJobIds jobIds to be processed
     * @param aInpLogicalFileNamesAndDates
     * @param aOutLogicalFileNames
     * @return HashMap
     * @throws TIERSBatchException  
     */
    public HashMap processRequest(String[] aInputJobIds,
            String[][] aInpLogicalFileNamesAndDates,
            String[] aOutLogicalFileNames) throws TIERSBatchException {

        try {
            inputFileNames = getInputFileNames(aInputJobIds,
                    aInpLogicalFileNamesAndDates);
            outputFileNames = getOutputFileNames(aOutLogicalFileNames);
        } catch (Exception ex) {
            throw new TIERSBatchException("Error in getting FileNames "
                    + ex.getMessage(), ex);
        }

        try {
            lookupTable = openFiles(aInputJobIds, aInpLogicalFileNamesAndDates,
                    inputFileNames, runNos, aOutLogicalFileNames,
                    outputFileNames);
            if (lookupTable == null) {
                throw new TIERSBatchException("Lookup Table is NULL");
            } else {
                return lookupTable;
            }
        } catch (Exception ex) {
            throw new TIERSBatchException("Error in Opening Files "
                    + ex.getMessage(), ex);
        }
    }

    /**
     * This method builds a HashMap containing logical file (only output) name
     * as key and a vector containing physical file name, record count and the
     * corresponding buffered writer/reader. This method is to be invoked by the
     * programs that deal with only output files
     * @param aOutLogicalFileNames
     * @return HashMap
     * @throws TIERSBatchException  
     */
    public HashMap processRequest(String[] aOutLogicalFileNames)
            throws TIERSBatchException {

        try {
            outputFileNames = getOutputFileNames(aOutLogicalFileNames);
        } catch (Exception ex) {
            throw new TIERSBatchException("Error in getting output File Names "
                    + ex.getMessage(), ex);
        }
        //Invoking openFiles method
        try {
            lookupTable = openFiles(aOutLogicalFileNames, outputFileNames);
            if (lookupTable == null) {
                throw new TIERSBatchException("Lookup Table is NULL");
            } else {
                return lookupTable;
            }
        } catch (Exception ex) {
            throw new TIERSBatchException("Error in opening in Files "
                    + ex.getMessage(), ex);
        }
    }

    /**
     * This method returns a record read from a given file. 
     * @param buffReader 
     * @return String
     * @throws TIERSBatchException  
     */
    public String readFromFile(java.io.BufferedReader buffReader)
            throws TIERSBatchException {
        try {
            String recordRead = exp.readFromFile(buffReader);
            return recordRead;
        } catch (Exception ex) {
            throw new TIERSBatchException("Error while reading from files "
                    + ex.getMessage(), ex);
        }

    }

    /**
     * This method updates the Discrepancy Quantity for a given file.
     * @param aJobId 
     * @param aLogicalFileName
     * @param aAsOfDate
     * @param aDiscrepancyQty
     * @return boolean
     * @throws TIERSBatchException  
     */
    public boolean setDiscrepancyQty(String aJobId, String aLogicalFileName,
            String aAsOfDate, long aDiscrepancyQty) throws TIERSBatchException {
        int runNo = 0;
        try {
            runNo = getAdjustedMaximumRunNo();
            if (isParallelRunProgram()) {
                bfcDAO.lockOutputFiles(getTIERSBatchControllerConnection(),
                        getJobId(), getAsOfDate());
            }
            bfcDAO.updateDiscrepancyQtyOfFileControlRecord(
                    getTIERSBatchControllerConnection(), aJobId,
                    aLogicalFileName, aAsOfDate, runNo, aDiscrepancyQty,
                    createUpdateUserId);
            if (isParallelRunProgram()) {
                bfcDAO.unlockOutputFiles(getTIERSBatchControllerConnection(),
                        getJobId(), getAsOfDate());
            }
            return true;
        } catch (Exception ex) {
            throw new TIERSBatchException(
                    "Error while setting Discrepancy Qty " + ex.getMessage(), ex);
        }
    }

    /**
     * This method updates the Discrepancy Quantity for a given file.
     * @param aJobId The identifier for the job
     * @param aLogicalFileName file name from the external source
     * @param aRunNum Has the run number of the particular run
     * @param aAsOfDate Has the as of date of the job
     * @param aDiscrepancyQty quantity
     * @return boolean returns true or false
     * @throws TIERSBatchException
     */
    public boolean setDiscrepancyQty(String aJobId, String aLogicalFileName,
            int aRunNum, String aAsOfDate, long aDiscrepancyQty)
            throws TIERSBatchException {
        try {
            if (isParallelRunProgram()) {
                bfcDAO.lockOutputFiles(getTIERSBatchControllerConnection(),
                        getJobId(), getAsOfDate());
            }
            bfcDAO.updateDiscrepancyQtyOfFileControlRecord(
                    getTIERSBatchControllerConnection(), aJobId,
                    aLogicalFileName, aAsOfDate, aRunNum, aDiscrepancyQty,
                    createUpdateUserId);
            if (isParallelRunProgram()) {
                bfcDAO.unlockOutputFiles(getTIERSBatchControllerConnection(),
                        getJobId(), getAsOfDate());
            }
            return true;
        } catch (Exception ex) {
            throw new TIERSBatchException("Error in updating Discrepancy Qty "
                    + ex.getMessage(), ex);
        }
    }

    /**
     * This method sets the Specific Header of the Exception Report.
     * @param aSpecificHeader spec. header 
     * @throws TIERSBatchException
     */
    public void setExceptionSpecificHeader(String aSpecificHeader)
            throws TIERSBatchException {
        try {
            crg.setExceptionSpecificHeader(aSpecificHeader);
        } catch (Exception ex) {
            throw new TIERSBatchException(
                    "Error in setting Exception specific Header "
                            + ex.getMessage(), ex);
        }
    }

    /**
     * This method updates the Record Count of a given file.
     * @param aLogicalFileName file name from the external source
     * @param aAsOfDate Has the as of date of the job
     * @param aRecordCount Has the record count of the particular run
     * @return boolean returns true or false
     * @throws TIERSBatchException
     */
    public boolean setOutputFileRecordCount(String aLogicalFileName,
            String aAsOfDate, long aRecordCount) throws TIERSBatchException {
        int runNo = 0;
        try {
            runNo = getAdjustedMaximumRunNo();
            if (isParallelRunProgram()) {
                bfcDAO.lockOutputFiles(getTIERSBatchControllerConnection(),
                        getJobId(), getAsOfDate());
            }
            bfcDAO.updateFileControlRecordCount(
                    getTIERSBatchControllerConnection(), jobId,
                    aLogicalFileName, aAsOfDate, runNo, aRecordCount,
                    createUpdateUserId);
            if (isParallelRunProgram()) {
                bfcDAO.unlockOutputFiles(getTIERSBatchControllerConnection(),
                        getJobId(), getAsOfDate());
            }
            return true;
        } catch (Exception ex) {
            throw new TIERSBatchException(
                    "Error in Updating File Control Record Count "
                            + ex.getMessage(), ex);
        }
    }

    /**
     *This method updates the Record Count of a given file.
     * @param aLogicalFileName file name from the external source
     * @param aRunNum Has the run number of the particular run
     * @param aAsOfDate Has the as of date of the job
     * @param aRecordCount Has the record count of the particular run
     * @return boolean returns true or false
     * @throws TIERSBatchException
     */
    public boolean setOutputFileRecordCount(String aLogicalFileName,
            int aRunNum, String aAsOfDate, long aRecordCount)
            throws TIERSBatchException {
        try {
            if (isParallelRunProgram()) {
                bfcDAO.lockOutputFiles(getTIERSBatchControllerConnection(),
                        getJobId(), getAsOfDate());
            }
            bfcDAO.updateFileControlRecordCount(
                    getTIERSBatchControllerConnection(), jobId,
                    aLogicalFileName, aAsOfDate, aRunNum, aRecordCount,
                    createUpdateUserId);
            if (isParallelRunProgram()) {
                bfcDAO.unlockOutputFiles(getTIERSBatchControllerConnection(),
                        getJobId(), getAsOfDate());
            }
            return true;
        } catch (Exception ex) {
            throw new TIERSBatchException(ex.getMessage(), ex);
        }
    }

    /**
     * This method updates the record of FW_BATCH_RUN_CONTROL Table
     * @param aStatus 
     * @return boolean
     * @throws TIERSBatchException
     */
    public boolean updateRunControlRecord(String aStatus)
            throws TIERSBatchException {
        try {
            if (isParallelRunProgram()) {
            	if (isLoadUtility){
            		return brcDAO.updateRunControlRecord(
                            getTIERSBatchControllerConnection(), jobId.substring(0,9)+"LDU",
                            getParallelRunId(), getAsOfDate(), aStatus,
                            createUpdateUserId);
            	}
            	else
            	{
                return brcDAO.updateRunControlRecord(
                        getTIERSBatchControllerConnection(), jobId,
                        getParallelRunId(), getAsOfDate(), aStatus,
                        createUpdateUserId);
            	}
            } else {
            	
            	if (isLoadUtility){
            		return brcDAO.updateRunControlRecord(
                            getTIERSBatchControllerConnection(), jobId.substring(0,9)+"LDU", getAsOfDate(),
                            aStatus, createUpdateUserId);
            	}
            	else
            	{
            		return brcDAO.updateRunControlRecord(
                            getTIERSBatchControllerConnection(), jobId, getAsOfDate(),
                            aStatus, createUpdateUserId);
            	}                
            }
        } catch (Exception ex) {
            throw new TIERSBatchException(
                    "Error in updating run control record to " + aStatus
                            + " : " + ex.getMessage(), ex);
        }
    }

    /**
     *This method writes the String to a specified file
     * @param aBuffWriter  
     * @param aStr 
     * @return boolean
     * @throws TIERSBatchException     
     */
    public boolean writeToFile(BufferedWriter aBuffWriter, String aStr)
            throws TIERSBatchException {
        try {
            return exp.writeToFile(aBuffWriter, aStr);
        } catch (Exception ex) {
            throw new TIERSBatchException("Error in writing into File "
                    + ex.getMessage(), ex);
        }

    }

    /**
     * This method returns the Vector conatining the details of the file
     * (Physiacl File Name, Record Count and Buffered Writer/Reader)
     * @param aLogicalFileName file name from the external source
     * @param aLookupTable 
     * @return Vector
     * @throws TIERSBatchException
     */
    public Vector getFileDetails(String aLogicalFileName, HashMap aLookupTable)
            throws TIERSBatchException {
        Vector fileDetails = null;
        try {
            fileDetails = (Vector) aLookupTable.get(aLogicalFileName);
        } catch (Exception ex) {
            throw new TIERSBatchException(
                    "Error in getting file details from HashMap"
                            + ex.getMessage(), ex);
        }

        return fileDetails;
    }

    /**
     * This method returns the Vector conatining the details of the file
     * (Physiacl File Name, Record Count and Buffered Writer/Reader)
     * @param aLogicalFileName file name from the external source
     * @param aLookupTable HashMap
     * @return ArrayList
     * @throws TIERSBatchException
     */
    public ArrayList getFileDetail(String aLogicalFileName, HashMap aLookupTable)
            throws TIERSBatchException {
        ArrayList fileDetails = null;
        try {
            fileDetails = (ArrayList) aLookupTable.get(aLogicalFileName);
        } catch (Exception ex) {
            throw new TIERSBatchException(
                    "Error in getting file details from HashMap"
                            + ex.getMessage(), ex);
        }

        return fileDetails;
    }

    /**
     * This method formats the date from a particular format 
     * to a particular format.
     * If target mask is NULL, date will be formatted 
     * using the default mask "MM/DD/YYYY".
     * @param aDateToFormat String
     * @param aFromDateMask String
     * @param aToDateMask String
     * @return String
     * @throws TIERSBatchException
     */
    public String formatDate(String aDateToFormat, String aFromDateMask,
            String aToDateMask) throws TIERSBatchException {
        try {
            return DataFormatter.formatDate(
                    getTIERSBatchControllerConnection(), aDateToFormat,
                    aFromDateMask, aToDateMask);
        } catch (Exception ex) {
            throw new TIERSBatchException("Error in formatting Date: "
                    + ex.getMessage(), ex);
        }
    }

    /**
     * This method returns the Run No of a given Job Id.
     * @return int 
     * @throws TIERSBatchException
     */
    public int getAdjustedMaximumRunNo() throws TIERSBatchException {

        try {
            if (!this.adjustedrunNoSet) {
                this.adjustedrunNo = brcDAO.getAdjustedMaximumRunNoInt(getTIERSBatchControllerConnection(), jobId, asOfDate,
                        overWriteFlag);
                this.adjustedrunNoSet = true;
            }
        } catch (Exception ex) {
            throw new TIERSBatchException(
                    "Error in getting Adjusted Maximum RunNum "
                            + ex.getMessage(), ex);
        } finally {
           
        }
        return this.adjustedrunNo;
    }

    /**
     * Gets maximum Run Num
     * @return int returns max. number
     * @throws TIERSBatchException
     */
	public int getMaximumRunNo() throws TIERSBatchException {
		int runNo = 0;
		try {
			runNo = brcDAO.getMaximumRunNoInt(
					getTIERSBatchControllerConnection(), jobId, getAsOfDate());
		} catch (Exception ex) {
			getLogger().log(
					FwConstants.LOGGING_CATEGORY_FRAMEWORK,
					ILog.ERROR,
					"Error in getting Maximum Run Num. Message: "
							+ ex.getMessage(), ex);
			throw new TIERSBatchException(
					"Error in getting Maximum Run Num. Message: "
							+ ex.getMessage(), ex);

		}

		return runNo;
	}
	
	public int writeExceptionRecord(String aExceptionCode, String aExceptionSummary, String aExceptionDetail, String aColumnType, boolean businessException, String errorCode, 
			String columnName, String columnValue, String definerCd, String recType, String legacyCaseValue, String segmentName, String tableName, 
			String triggerReasonCd, String triggerTypeCd, String fwRin)
				throws TIERSBatchException {
		int statusCode = 0;
		try {
			// Inserting into Batch Exceptions
			if (batchExcController == null) {
				batchExcController = new BatchExceptionController(getJobId(), getConnectionForWriteException(), thresholdValue);
			}
			recordNum = recordNum + 1;
			// This temp_JobID was created to handle the Load utility issue with
			// Run_Control table entry
			String finalJobId = jobId;
			if (isLoadUtility) {
				finalJobId = jobId.substring(0, 9) + "LDU";
			}
			int finalParallelRunNum = getCurrentRunNum();
			if(isParallelRunProgram()){
				finalParallelRunNum = getParallelRunNum();
			}
			
			statusCode = batchExcController.insertExceptionRecord(
					getConnectionForWriteException(), finalJobId, getAsOfDate(), getCurrentRunNum(), finalParallelRunNum, programName, aExceptionCode,
					aExceptionSummary, aExceptionDetail, createUpdateUserId, aColumnType, recordNum, businessException, errorCode, columnName,
					columnValue, definerCd, recType, legacyCaseValue, segmentName, tableName, triggerReasonCd, triggerTypeCd, fwRin);
			
			checkStatusException(statusCode, aExceptionCode);
		} catch (Exception ex) {
			getLogger().log(FwConstants.LOGGING_CATEGORY_FRAMEWORK,ILog.ERROR,"Error writing exception record. Message: "+ ex.getMessage(), ex);
			throw new TIERSBatchException("Error writing exception record. Message: "+ ex.getMessage(), ex);
		}
		return statusCode;
	}
	

    public int writeExceptionRecord(String aExceptionCode, String aExceptionSummary, String aExceptionDetail, String aColumnType, 
    	boolean aCountBusinessException, String errorCode, String columnName, String columnValue)
			throws TIERSBatchException {
		return writeExceptionRecord(aExceptionCode, aExceptionSummary, aExceptionDetail, aColumnType, aCountBusinessException, errorCode, columnName, columnValue,null, null, null, null, null, null, null, null);
	}
    
    /**
     * @param aExceptionCode exceptionCode to be processed
     * @param aExceptionSummary Has the summary of Exception
     * @param aExceptionDetail Has the the details of particular Exception
     * @param aCountBusinessException passes true or false
     * @return int returns count of number of records
     * @throws TIERSBatchException 
     **/
	public int writeExceptionRecord(String aExceptionCode,
			String aExceptionSummary, String aExceptionDetail,
			boolean aCountBusinessException) throws TIERSBatchException {
			return writeExceptionRecord(aExceptionCode, aExceptionSummary, aExceptionDetail, null, aCountBusinessException);
	}

	/**
	 * Writes Exception Record.
	 * 
	 * @param aExceptionCode
	 *            exceptionCode to be processed
	 * @param aExceptionSummary
	 *            Has the summary of Exception
	 * @param aExceptionDetail
	 *            Has the the details of particular Exception
	 * @param aColumnType
	 *            type to be processed
	 * @param aCountBusinessException
	 *            passes true or false
	 * @return int returns count of number of records
	 * @throws TIERSBatchException
	 */
	public int writeExceptionRecord(String aExceptionCode,
			String aExceptionSummary, String aExceptionDetail,
			String aColumnType, boolean aCountBusinessException)
			throws TIERSBatchException {
		return writeExceptionRecord(aExceptionCode, aExceptionSummary, aExceptionDetail, aColumnType, aCountBusinessException, null, null, null);

	}

    /**
     * New Write exception for Error Log Context. This method will also 
     * log exceptions in error log table.
     * @param aExceptionCode exceptionCode to be processed
     * @param aExceptionSummary Has the summary of Exception
     * @param aExceptionDetail Has the the details of particular Exception
     * @param aColumnType type to be processed
     * @param aCountBusinessException passes true or false 
     * @param context context to be processed
     * @param contextValue value of context to be processed
     * @return int returns count of number of records
     * @throws TIERSBatchException
     */
    public int writeExceptionRecord(String aExceptionCode,
            String aExceptionSummary, String aExceptionDetail,
            String aColumnType, boolean aCountBusinessException,String context,String contextValue)  throws TIERSBatchException {
    	String[] newContext = new String[1];
    	String[] newContextVal = new String[1];
    	newContext[0] = context;
    	newContextVal[0] = contextValue;
    	return writeExceptionRecord(aExceptionCode,aExceptionSummary,aExceptionDetail,aColumnType,aCountBusinessException,newContext,newContextVal);    
    }
    
    /**
     * New Write exception for Error Log Context. This method will 
     * also log exceptions in error log table with multiple contexts
     * @param aExceptionCode exceptionCode to be processed
     * @param aExceptionSummary Has the summary of Exception
     * @param aExceptionDetail Has the the details of particular Exception
     * @param aColumnType type to be processed
     * @param aCountBusinessException passes true or false
     * @param context context to be processed
     * @param contextValue value of context to be processed
     * @return int returns count of number of records
     * @throws TIERSBatchException
     */
    
    public int writeExceptionRecord(String aExceptionCode,
            String aExceptionSummary, String aExceptionDetail,
			String aColumnType, boolean aCountBusinessException,
			String[] context, String[] contextValue) throws TIERSBatchException {
		try {
			createErrorLogBean(aExceptionCode, aExceptionSummary, aExceptionDetail);
			createErrorLogDetailsBeans(context, contextValue);
			persistErrorLog();
		} catch (Exception ex) {
			getLogger().log(FwConstants.LOGGING_CATEGORY_FRAMEWORK, ILog.ERROR, "Error writing exception record. Message: " + ex.getMessage(), ex);
			throw new TIERSBatchException("Error writing exception record. Message: " + ex.getMessage(), ex);
		}
		return writeExceptionRecord(aExceptionCode, aExceptionSummary, aExceptionDetail, aColumnType, aCountBusinessException);
	}
    
    
    /**
     * THE METHOD BELOW IS USED BY DATASYNC TEAM
     * Writes Exception Record
     * @param aCountBusinessException passes true or false
     * @param fwBatchExceptionsCargo : holds additional values for the new columns added to FW_BATCH_EXCEPTION 
	 * New columns: COLUMN_NAME,COLUMN_VALUE,DEFINER_CD,ERROR_CD,REC_TYPE ,LEGACY_CASE_VALUE,SEGMENT_NAME,TABLE_NAME,TRIGGER_REASON_CD,TRIGGER_TYPE_CD
     * @return int returns count of number of records
     * @throws TIERSBatchException
     */
    public int writeExceptionRecord(boolean aCountBusinessException, FwBatchExceptionsCargo fwBatchExceptionsCargo) throws TIERSBatchException {
		return writeExceptionRecord(fwBatchExceptionsCargo.getExceptionCd(), fwBatchExceptionsCargo.getExceptionSummary(), fwBatchExceptionsCargo.getExceptionDetail(), fwBatchExceptionsCargo.getColumnType(), 
					aCountBusinessException, fwBatchExceptionsCargo.getErrorCode(), fwBatchExceptionsCargo.getColumnName(), fwBatchExceptionsCargo.getColumnValue(),
					fwBatchExceptionsCargo.getDefinerCd(), fwBatchExceptionsCargo.getRecType(),
					fwBatchExceptionsCargo.getLegacyCaseValue(), fwBatchExceptionsCargo.getSegmentName(), fwBatchExceptionsCargo.getTableName(), fwBatchExceptionsCargo.getTriggerReasonCd(),
					fwBatchExceptionsCargo.getTriggerTypeCd(), fwBatchExceptionsCargo.getFwRin());
	}
    
    /**
     * This method creates Error Log Bean
     * @param aExceptionCode exceptionCode to be processed
     * @param aExceptionSummary Has the summary of Exception
     * @param aExceptionDetail Has the the details of particular Exception
     */
    
    private void createErrorLogBean(String aExceptionCode,
            String aExceptionSummary, String aExceptionDetail) {
    	String refId = errorLogContext.getReferenceId();  	
    	errorLogBean.setReferenceId(refId);
    	errorLogBean.setExceptionNum(Long.toString(recordNum));
    	errorLogBean.setExceptionDate(FwCalendar.getInstance().getDate().getTime());
    	errorLogBean.setExceptionSeverity(aExceptionCode.substring(0,1));
    	errorLogBean.setExceptionSummary(aExceptionSummary);
    	errorLogBean.setExceptionDetails(aExceptionDetail);  
    }
    
    /**
     * This method creates Error Log Details for each and every contexts
     * @param context context to be processed
     * @param contextValue value of context to be processed
     */
    private void createErrorLogDetailsBeans(String[] context,String[] contextValue) {
    	int contextSize = context.length;
    	String refId = errorLogContext.getReferenceId();
    	String exNum = errorLogBean.getExceptionNum();
    	String contId = null;
    	String value = null;
    	for (int i=0;i<contextSize;i++) {
    		FwErrorLogDetailsBean eldb = new FwErrorLogDetailsBean();
    		contId = context[i];
    		value = contextValue[i];
    		if (contId != null && value != null) {
    			eldb.setReferenceId(refId);
    			eldb.setExceptionNum(Integer.parseInt(exNum));
    			eldb.setContextNum(i);
    			eldb.setContextType(contId);
    			eldb.setContextId(value);
    		}
    		errorLogDetailsBeanArr.add(eldb);
    	}    	
    }
    
    /**
     * This method persists error Logs.
     * @throws EJBException
     * @throws Exception
     */
    
    private void persistErrorLog() throws EJBException, Exception {/*
      
    	FwErrorLogBean[] logBean = {errorLogBean};
    	FwErrorLogDetailsBean[] logDetails = new FwErrorLogDetailsBean[errorLogDetailsBeanArr.size()];
    	errorLogDetailsBeanArr.toArray(logDetails);	
		
		try {
			FwErrorLogContextBO errorBO = new FwErrorLogContextBO(errorLogConnection);
			if (errorLogContextId != 0) {
				errorBO.persistErrorLog(logBean,logDetails,errorLogContextId);
			} else {
				errorLogContextId =  errorBO.persistErrorLog(errorLogContext,logBean,logDetails);			    
			}
			errorLogConnection.commit();
		} catch (Exception e) {
			errorLogConnection.rollback();			
		    System.out.println("Error while Persisting Error Log "+e);
		    e.printStackTrace();
		}
	*/}

    /**
     * Set Exception CommitSize: Please do not use this method 
     * until absolutely necessary. By default commitSize = 1
     * @param acommitSize int
     * @throws TIERSBatchException
     */
    public void setExceptionCommitSize(int acommitSize)
            throws TIERSBatchException {
        batchExcController.setExceptionCommitSize(acommitSize);
    }

    /**
     *This method returns the Run No of a given Job Id.
     * @param aJobId The identifier for the job
     * @return String returns the userid
     * @throws TIERSBatchException 
     */
    public static String getCreateUpdateUserId(String aJobId)
            throws TIERSBatchException {

        String createUpdateUserIdLocal = null;
        StringTokenizer stk = new StringTokenizer(aJobId, "-");
        StringBuffer sbf = new StringBuffer();
        while (stk.hasMoreTokens()) {
            sbf.append(stk.nextToken());
        }
        createUpdateUserIdLocal = sbf.toString();

        if (createUpdateUserIdLocal == null) {
            throw new TIERSBatchException("createUpdateUserId is NULL");
        }
        return createUpdateUserIdLocal;
    }

    /**
     * This method returns instance of batchFileController
     * @return BatchFileController returns instance of batchFileController
     * @throws TIERSBatchException
     */
    public BatchFileController getBatchFileControlHandle()
            throws TIERSBatchException {
        return bfcDAO;
    }

    /**
     * This method returns instance of fileAssember
     * @return FileAssembler returns instance of fileAssember
     * @throws TIERSBatchException
     */
    public FileAssembler getFileAssemblerHandle() throws TIERSBatchException {
        return fa;
    }

    /**
     * This method sort the files 
     * @param inputJobIds The identifiers for the jobIds
     * @param inpLogicalNamesDates input logicalNamesDates
     * @param outLogicalNames output LogicalNames
     * @return boolean returns true or false
     * @throws TIERSBatchException 
     */
    public boolean sortFiles(String[] inputJobIds,
            String[][] inpLogicalNamesDates, String[] outLogicalNames)
            throws TIERSBatchException {
        FileSorter fSorter = new FileSorter();
        boolean sortSuccessful = false;
        try {
            sortSuccessful = fSorter.sortFiles(jobId, inputJobIds,
                    inpLogicalNamesDates, outLogicalNames, env, this);

            return sortSuccessful;
        } catch (Exception ex) {
            throw new TIERSBatchException(ex.getMessage(), ex);
        }
    }

    /**
     * This method sort the files
     * @param aInputJobIds The identifiers for the jobIds
     * @param aInpLogicalNames input logical file Name
     * @param aOutLogicalNames output logical file Name
     * @return boolean returns true or false
     * @throws TIERSBatchException
     */
    public boolean sortFiles(String[] aInputJobIds, String[] aInpLogicalNames,
            String[] aOutLogicalNames) throws TIERSBatchException {
        FileSorter fSorter = new FileSorter();
        boolean sortSuccessful = false;
        String[][] inpLogicalFileNamesDates = new String[aInpLogicalNames.length][2];
        int inpLogicalFileNamesDatesLength = inpLogicalFileNamesDates.length;
        for (int i = 0; i < inpLogicalFileNamesDatesLength; i++) {
            inpLogicalFileNamesDates[i][0] = aInpLogicalNames[i];
            inpLogicalFileNamesDates[i][1] = formatDate(getAsOfDate(), "mm/dd/yyyy",
                    "mm-dd-yyyy");
        }

        try {
            sortSuccessful = fSorter.sortFiles(jobId, aInputJobIds,
                    inpLogicalFileNamesDates, aOutLogicalNames, env, this);
            return sortSuccessful;
        } catch (Exception ex) {
            throw new TIERSBatchException(ex.getMessage(), ex);
        }
    }

    /**
     * Schedule Jobs
     * @throws TIERSBatchException 
     */
    public void schedule() throws TIERSBatchException {
        bdsDAO.schedule(getTIERSBatchControllerConnection(), getAsOfDate());
    }

    /**
     * Schedule Jobs
     * @param eventID Id to be processed
     * @throws TIERSBatchException 
     */
    public void schedule(String eventID) throws TIERSBatchException {
        bdsDAO.schedule(getTIERSBatchControllerConnection(), getAsOfDate(),
                eventID, getChunkFactor());
    }
