Request:

http
Copy
Edit
GET /admin/users
Authorization: Bearer <user-token>
✅ Correct Handling:
401 Unauthorized – if token is missing or expired.

403 Forbidden – if token is valid but lacks required role (e.g., not admin).


 Idempotency in PUT vs. POST
Q:

"What’s the main reason PUT is considered idempotent, while POST is not? Can you give an example where this matters in practice?"

A:

PUT /users/10 will overwrite the same resource — calling it multiple times doesn’t change the outcome.

POST /users creates a new resource every time — it’s non-idempotent.

Why it matters: Retry logic. If a request is retried due to timeout, PUT is safe to retry, POST may duplicate.


5. Handling Concurrency
Q:

"Two users update the same resource at nearly the same time. How do you prevent one user’s changes from overwriting the other’s?"

A:

Use ETag headers or a version field.

On PUT, require client to send:

h
Copy
Edit
If-Match: "etag-value"
If ETag doesn't match server state, return 409 Conflict.



@Component
public class A {
    public A() {
        System.out.println("A created");
    }
}

@Component
public class B {
    private final A a;

    public B(A a) {
        this.a = a;
        System.out.println("B created");
    }
}
Question: What will be printed during Spring Boot app startup?

Expected Output:

css
Copy
Edit
A created
B created
Explanation:
Spring uses constructor injection for B. So it creates A first, injects it into B, and then creates B. The output reflects the correct order of dependency resolution.


 Question 3: Bean Scope - Singleton vs Prototype
java
Copy
Edit
@Component
@Scope("prototype")
public class D {
    public D() {
        System.out.println("New D created");
    }
}

@RestController
public class DemoController {
    @Autowired
    private ApplicationContext context;

    @GetMapping("/test")
    public String test() {
        context.getBean(D.class);
        context.getBean(D.class);
        return "Done";
    }
}
Question: What is the output in the console when hitting /test?

Expected Output:

sql
Copy
Edit
New D created
New D created
Explanation:

D is a prototype bean, so Spring creates a new instance every time it’s requested from the context.

Therefore, two instances are created when calling /test.


Question 1: Understanding GROUP BY with WHERE and HAVING
sql
Copy
Edit
CREATE TABLE orders (
    id INT,
    customer VARCHAR(50),
    amount DECIMAL(10, 2)
);

INSERT INTO orders VALUES
(1, 'Alice', 100.00),
(2, 'Bob', 200.00),
(3, 'Alice', 150.00),
(4, 'Bob', 50.00),
(5, 'Charlie', 300.00);
Question:
Write a query to return customers whose total order amount > 200.

Expected Query:

sql
Copy
Edit
SELECT customer, SUM(amount) AS total_amount
FROM orders
GROUP BY customer
HAVING SUM(amount) > 200;
Expected Output:

diff
Copy
Edit
customer | total_amount
---------|--------------
Alice    | 250.00
Charlie  | 300.00
Explanation:

WHERE filters rows before grouping.

HAVING filters groups after aggregation.

✅ Question 2: Subquery Filtering
sql
Copy
Edit
-- Table: employees
CREATE TABLE employees (
    id INT,
    name VARCHAR(50),
    department_id INT,
    salary INT
);

-- Table: departments
CREATE TABLE departments (
    id INT,
    name VARCHAR(50)
);

INSERT INTO departments VALUES (1, 'HR'), (2, 'Engineering');
INSERT INTO employees VALUES
(1, 'Alice', 1, 5000),
(2, 'Bob', 2, 8000),
(3, 'Carol', 2, 9500);
Question:
Write a query to find employees who earn more than the average salary in their own department.

Expected Query:

sql
Copy
Edit
SELECT e.name, e.salary, e.department_id
FROM employees e
WHERE e.salary > (
    SELECT AVG(salary)
    FROM employees
    WHERE department_id = e.department_id
);
Expected Output:

pgsql
Copy
Edit
name  | salary | department_id
------|--------|---------------
Carol | 9500   | 2
Explanation:

Correlated subquery compares each employee's salary to the average in their department.

✅ Question 3: NULL Logic Trap
sql
Copy
Edit
CREATE TABLE accounts (
    id INT,
    name VARCHAR(50),
    email VARCHAR(50)
);

INSERT INTO accounts VALUES
(1, 'Alice', 'alice@example.com'),
(2, 'Bob', NULL),
(3, 'Charlie', NULL);
Question:
What will this query return?

sql
Copy
Edit
SELECT * FROM accounts
WHERE email != 'alice@example.com';
Expected Output:

pgsql
Copy
Edit
(No rows)
Explanation:

In SQL, NULL != 'value' is not true, it's unknown, so those rows are excluded.

Must use IS NOT NULL if you want to include those.

Corrected Query:

sql
Copy
Edit
SELECT * FROM accounts
WHERE email IS NULL OR email != 'alice@example.com';
✅ Question 4: Window Function – RANK() vs DENSE_RANK()
sql
Copy
Edit
CREATE TABLE scores (
    player VARCHAR(50),
    score INT
);

INSERT INTO scores VALUES
('Alice', 100),
('Bob', 200),
('Carol', 200),
('David', 150);
Question:
Show the rank of each player ordered by score (highest first). Use both RANK() and DENSE_RANK() and explain the difference.

Expected Query:

sql
Copy
Edit
SELECT player, score,
       RANK() OVER (ORDER BY score DESC) AS rnk,
       DENSE_RANK() OVER (ORDER BY score DESC) AS drnk
FROM scores;
Expected Output:

diff
Copy
Edit
player | score | rnk | drnk
-------|-------|-----|-----
Bob    | 200   | 1   | 1
Carol  | 200   | 1   | 1
David  | 150   | 3   | 2
Alice  | 100   | 4   | 3
Explanation:

RANK() leaves gaps.

DENSE_RANK() does not.

✅ Question 5: DELETE with JOIN
sql
Copy
Edit
CREATE TABLE users (
    id INT,
    name VARCHAR(50)
);

CREATE TABLE user_logs (
    id INT,
    user_id INT,
    log TEXT
);

INSERT INTO users VALUES (1, 'Alice'), (2, 'Bob');
INSERT INTO user_logs VALUES
(1, 1, 'Login'),
(2, 2, 'Logout'),
(3, 1, 'Purchase');
Question:
Write a query to delete all logs for users that no longer exist.

Expected Query (MySQL):

sql
Copy
Edit
DELETE ul
FROM user_logs ul
LEFT JOIN users u ON ul.user_id = u.id
WHERE u.id IS NULL;
Expected Result:
Deletes logs where user_id does not match any user in users.