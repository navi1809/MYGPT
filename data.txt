1)
class Parent {
static void print() {
System.out.println("Parent");
}
}
class Child extends Parent {
static void print() {
System.out.println("Child");
}
public static void main(String[] args) {
Parent obj = new Child();
obj.print();
}
}

Answer:

Parent

- Static methods are not overridden, they are hidden.

2)
public class Test5 {
public static void main(String[] args) {
int i = 0;
i = i++ + ++i;
System.out.println(i);
}
}

Answer:

2

- Post-increment uses `0`, pre-increment becomes `2`: `i = 0 + 2`.

3)

public class MapTest {
public static void main(String[] args) {
Map<String, String> map = new HashMap<>();
map.put(null, "One");
map.put(null, "Two");
System.out.println(map.size());
System.out.println(map.get(null));
}
}

Answer:

1
Two

- `HashMap` allows one `null` key, and the second `put` replaces the first.

4) Question: Is HashMap thread-safe? If not, how can you make it thread-safe?
Answer:
HashMap is not thread-safe.
You can make it thread-safe by using Collections.synchronizedMap() or by using ConcurrentHashMap:

Map<String, String> synchronizedMap = Collections.synchronizedMap(new HashMap<>());
Map<String, String> concurrentMap = new ConcurrentHashMap<>();


5) Question: What happens if you try to use null as a key in other Map implementations like TreeMap or Hashtable?

Answer:
TreeMap: Throws a NullPointerException because it uses natural ordering or a comparator, and null cannot be compared.
Hashtable: Does not allow null keys and throws a NullPointerException.


4)
public class StringTest {
public static void main(String[] args) {
String s = "abc";
s.concat("def");
System.out.println(s);
}
}

Answer:

abc

- Strings are immutable. `concat` returns a new string, which is not used.



6) @RestController
public class HelloController {

@GetMapping("/hello")
public String hello() {
 return "Hello, World!";
}
}


{
"message" : Hello, World!"
}
How would you write unit test for above?

Answer:
@SpringBootTest
@AutoConfigureMockMvc
public class HelloControllerTest {

    @Autowired
    private MockMvc mockMvc;

    @Test
    public void testHello() throws Exception {
        mockMvc.perform(get("/hello"))
               .andExpect(status().isOk())
               .andExpect(content().string("Hello, World!"));
    }
}


7) Question: How can you secure the /hello endpoint so that only authenticated users can access it?

Answer: You can use Spring Security to secure the endpoint. For example

@GetMapping("/hello")
@PreAuthorize("isAuthenticated()")
public String hello() {
    return "Hello, Authenticated User!";
}


8) Question: How can you return a JSON response instead of a plain string?

Answer: You can return an object, and Spring Boot will automatically convert it to JSON:
@GetMapping("/hello")
public Map<String, String> hello() {
    return Map.of("message", "Hello, World!");
}


7)
What’s wrong with this repository?

public interface UserRepo extends JpaRepository<User, Long> {
User findByEmail(String email);
List<User> findByAge(int age);
void deleteByName(String name);
}

Answer:
- `void deleteByName(String name);` is valid only if return type is `long` or `void`, but it's better to use `@Modifying`.


Question: How does Spring Data JPA derive queries from method names like findByEmail and findByAge?

Answer: Spring Data JPA uses method name conventions to derive queries. It parses the method name (e.g., findByEmail) and generates a query based on the entity's field names.
Question: What happens if the field name in the method (e.g., email) does not exist in the User entity?

Answer: Spring will throw an IllegalArgumentException at runtime, indicating that the property does not exist.



Question: What is the difference between @Modifying and @Query annotations in Spring Data JPA?

Answer:
@Query is used to define custom JPQL or SQL queries.
@Modifying is used to indicate that a query modifies the database (e.g., INSERT, UPDATE, DELETE).
Question: What happens if you use @Modifying without @Transactional?

Answer: The operation may fail with a TransactionRequiredException because modifying queries require a transactional context.
Question: What is the default propagation behavior of the @Transactional annotation?

Answer: The default propagation behavior is REQUIRED, which means the method will join an existing transaction or create a new one if none exists.


Question: What is the difference between @Modifying and @Query annotations in Spring Data JPA?

Answer:
@Query is used to define custom JPQL or SQL queries.
@Modifying is used to indicate that a query modifies the database (e.g., INSERT, UPDATE, DELETE).
Question: What happens if you use @Modifying without @Transactional?

Answer: The operation may fail with a TransactionRequiredException because modifying queries require a transactional context.


9)
What happens if you configure two data sources but don’t mark any as `@Primary` or use `@Qualifier`?

Answer:
Spring will throw:

No qualifying bean of type 'DataSource' available: expected single matching bean but found 2


To fix it, either mark one with `@Primary` or use `@Qualifier` where needed.



11)

GET /admin/users

Q) When i will get 401 Unauthorized vs 403 Forbidden ?

A) 
401 Unauthorized – if token is missing or expired.

403 Forbidden – if token is valid but lacks required role (e.g., not admin).


12) Question: Implement a custom exception handler in Spring Boot to handle 401 Unauthorized and 403 Forbidden errors.

@ControllerAdvice
public class CustomExceptionHandler {

    @ExceptionHandler(ResponseStatusException.class)
    public ResponseEntity<Map<String, String>> handleResponseStatusException(ResponseStatusException ex) {
        Map<String, String> error = new HashMap<>();
        error.put("error", ex.getReason());
        error.put("status", String.valueOf(ex.getStatus().value()));
        return new ResponseEntity<>(error, ex.getStatus());
    }
}


13)Write an integration test for the /admin/users endpoint.
@Test
public void testAdminUsersEndpoint_Security() {
    HttpHeaders headers = new HttpHeaders();
    headers.set("Authorization", "Bearer invalidToken");

    HttpEntity<String> entity = new HttpEntity<>(headers);
    ResponseEntity<String> response = restTemplate.exchange("/admin/users", HttpMethod.GET, entity, String.class);

    assertEquals(HttpStatus.UNAUTHORIZED, response.getStatusCode());
}

12) 

Idempotency in PUT vs. POST
Q:

"What’s the main reason PUT is considered idempotent, while POST is not? Can you give an example where this matters in practice?"

A:

PUT /users/10 will overwrite the same resource — calling it multiple times doesn’t change the outcome.

POST /users creates a new resource every time — it’s non-idempotent.

Why it matters: Retry logic. If a request is retried due to timeout, PUT is safe to retry, POST may duplicate.


13)

Handling Concurrency in Rest API
Q:

"Two users update the same resource at nearly the same time. How do you prevent one user’s changes from overwriting the other’s?"

A:

Use ETag headers or a version field.

On PUT, require client to send:

If-Match: "etag-value"
If ETag doesn't match server state, return 409 Conflict.

14)

@Component
public class A {
    public A() {
        System.out.println("A created");
    }
}

@Component
public class B {
    private final A a;

    public B(A a) {
        this.a = a;
        System.out.println("B created");
    }
}
Question: What will be printed during Spring Boot app startup?

Expected Output:

A created
B created
Explanation:
Spring uses constructor injection for B. So it creates A first, injects it into B, and then creates B. The output reflects the correct order of dependency resolution.

15)

Bean Scope - Singleton vs Prototype

@Component
@Scope("prototype")
public class D {
    public D() {
        System.out.println("New D created");
    }
}

@RestController
public class DemoController {
    @Autowired
    private ApplicationContext context;

    @GetMapping("/test")
    public String test() {
        context.getBean(D.class);
        context.getBean(D.class);
        return "Done";
    }
}
Question: What is the output in the console when hitting /test?

Expected Output:

sql
Copy
Edit
New D created
New D created
Explanation:

D is a prototype bean, so Spring creates a new instance every time it’s requested from the context.

Therefore, two instances are created when calling /test.

11)

@Transactional
public void updateUserEmail(Long id) {
User u = userRepository.findById(id).get();
u.setEmail("new@example.com");
}

no save method
Q: Will the email be updated in DB?

Answer:
✅ Yes.
JPA performs dirty checking — any change to managed entities inside a transaction is automatically flushed to DB.


Understanding GROUP BY with WHERE and HAVING

CREATE TABLE orders (
    id INT,
    customer VARCHAR(50),
    amount DECIMAL(10, 2)
);

INSERT INTO orders VALUES
(1, 'Alice', 100.00),
(2, 'Bob', 200.00),
(3, 'Alice', 150.00),
(4, 'Bob', 50.00),
(5, 'Charlie', 100.00);

Question:
Write a query to return customers whose total order amount > 200.

Expected Query:

SELECT customer, SUM(amount) AS total_amount
FROM orders
GROUP BY customer
HAVING SUM(amount) > 200;
Expected Output:


customer | total_amount
---------|--------------
Alice    | 250.00
Charlie  | 300.00
Explanation:

WHERE filters rows before grouping.

HAVING filters groups after aggregation.

✅ Question 2: Subquery Filtering

CREATE TABLE employees (
    id INT,
    name VARCHAR(50),
    department_id INT,
    salary INT
);

CREATE TABLE departments (
    id INT,
    name VARCHAR(50)
);

INSERT INTO departments VALUES (1, 'HR'), (2, 'Engineering');
INSERT INTO employees VALUES
(1, 'Alice', 1, 5000),
(2, 'Bob', 2, 8000),
(3, 'Carol', 2, 9500);
Question:
Write a query to find employees who earn more than the average salary in their own department.

Expected Query:

SELECT e.name, e.salary, e.department_id
FROM employees e
WHERE e.salary > (
    SELECT AVG(salary)
    FROM employees
    WHERE department_id = e.department_id
);
Expected Output:

salary | department_id
------|--------|---------------
Carol | 9500   | 2
Explanation:

Correlated subquery compares each employee's salary to the average in their department.

✅ Question 3: NULL Logic Trap

CREATE TABLE accounts (
    id INT,
    name VARCHAR(50),
    email VARCHAR(50)
);

INSERT INTO accounts VALUES
(1, 'Alice', 'alice@example.com'),
(2, 'Bob', NULL),
(3, 'Charlie', NULL);
Question:
What will this query return?

SELECT * FROM accounts
WHERE email != 'alice@example.com';
Expected Output:

pgsql
Copy
Edit
(No rows)
Explanation:

In SQL, NULL != 'value' is not true, it's unknown, so those rows are excluded.

Must use IS NOT NULL if you want to include those.

Corrected Query:

sql
Copy
Edit
SELECT * FROM accounts
WHERE email IS NULL OR email != 'alice@example.com';
✅ Question 4: Window Function – RANK() vs DENSE_RANK()
sql
Copy
Edit
CREATE TABLE scores (
    player VARCHAR(50),
    score INT
);

INSERT INTO scores VALUES
('Alice', 100),
('Bob', 200),
('Carol', 200),
('David', 150);
Question:
Show the rank of each player ordered by score (highest first). Use both RANK() and DENSE_RANK() and explain the difference.

Expected Query:

sql
Copy
Edit
SELECT player, score,
       RANK() OVER (ORDER BY score DESC) AS rnk,
       DENSE_RANK() OVER (ORDER BY score DESC) AS drnk
FROM scores;
Expected Output:

diff
Copy
Edit
player | score | rnk | drnk
-------|-------|-----|-----
Bob    | 200   | 1   | 1
Carol  | 200   | 1   | 1
David  | 150   | 3   | 2
Alice  | 100   | 4   | 3
Explanation:

RANK() leaves gaps.

DENSE_RANK() does not.

✅ Question 5: DELETE with JOIN
sql
Copy
Edit
CREATE TABLE users (
    id INT,
    name VARCHAR(50)
);

CREATE TABLE user_logs (
    id INT,
    user_id INT,
    log TEXT
);

INSERT INTO users VALUES (1, 'Alice'), (2, 'Bob');
INSERT INTO user_logs VALUES
(1, 1, 'Login'),
(2, 2, 'Logout'),
(3, 1, 'Purchase');
Question:
Write a query to delete all logs for users that no longer exist.

Expected Query (MySQL):

sql
Copy
Edit
DELETE ul
FROM user_logs ul
LEFT JOIN users u ON ul.user_id = u.id
WHERE u.id IS NULL;
Expected Result:
Deletes logs where user_id does not match any user in use