package gov.nv.dwss.crystalreports.statistics.programhistory.tasklet;

import java.sql.Connection;
import java.sql.Timestamp;
import java.time.LocalDateTime;
import java.util.ArrayList;
import java.util.List;

import javax.sql.DataSource;

import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;
import org.springframework.batch.core.StepContribution;
import org.springframework.batch.core.scope.context.ChunkContext;
import org.springframework.batch.core.step.tasklet.Tasklet;
import org.springframework.batch.repeat.RepeatStatus;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.jdbc.datasource.DataSourceUtils;
import org.springframework.stereotype.Component;

import gov.nv.dwss.crystalreports.statistics.common.model.CommonData;
import gov.nv.dwss.crystalreports.statistics.common.model.PceRecord;
import gov.nv.dwss.crystalreports.statistics.constants.StatisticsConstants;
import gov.nv.dwss.crystalreports.statistics.programhistory.dao.ProgramHistoryExtractDao;
import gov.nv.dwss.domain.dao.sor.ReportMonthlyCaseHistorySorDao;
import gov.nv.dwss.domain.record.SorRecord;
import gov.nv.dwss.domain.record.sor.ReportMonthlyCaseHistorySorRecord;
import gov.nv.dwss.fw.batch.common.AbstractBatchStepComponent;
import gov.nv.dwss.fw.batch.constants.FWConstants;
import gov.nv.dwss.fw.batch.context.SystemInfoParam;
import gov.nv.dwss.fw.batch.enums.BatchExceptionType;
import gov.nv.dwss.fw.batch.model.SkippedRecord;
import gov.nv.dwss.fw.batch.util.ExceptionUtil;
import gov.nv.dwss.fw.batch.util.ObjectUtils;
import gov.nv.dwss.switcher.DatabaseSwitcher;

import static gov.nv.dwss.fw.batch.constants.FWConstants.BLANK;
import static gov.nv.dwss.fw.batch.constants.FWConstants.N;

@Component
public class ProgramHistoryInsertTasklet extends AbstractBatchStepComponent implements Tasklet {

	private static final Logger LOG = LogManager.getLogger(ProgramHistoryInsertTasklet.class);

	@Autowired
	private DataSource sorDataSource;
	
	@Autowired
	DatabaseSwitcher databaseSwitch;

	@Value("${db.nswd.schema}")
    private String nswdSchemaName;
	
	@Autowired
	ProgramHistoryExtractDao monthlyProgramCaseHistoryExtractDao;
	
	@Autowired
	ReportMonthlyCaseHistorySorDao reportMonthlyCaseHistorySorDao;
	
	@Override
	public RepeatStatus execute(StepContribution contribution, ChunkContext chunkContext) throws Exception {
		LOG.info("calling ProgramHistoryInsertTasklet for pceRecord count :: {}", CommonData.getProgramCaseList().size());
		
		List<PceRecord> list = CommonData.getProgramCaseList();
		List<SorRecord> recordList = createSorRecords(list);
		performDatabaseOperations(recordList);
		LOG.info("calling ProgramHistoryInsertTasklet for final record count :: {}", recordList.size());
		return RepeatStatus.FINISHED;
	}

	private List<SorRecord> createSorRecords(List<PceRecord> pceRecords) {
		List<SorRecord> recordList = new ArrayList<>();
		int sequenceNumber = 1;
		for (PceRecord pceRecord : pceRecords) {
			recordList.add(createSorRecord(pceRecord, sequenceNumber++));
		}
		return recordList;
	}

	private SorRecord createSorRecord(PceRecord pceRecord, int sequenceNumber) {
		ReportMonthlyCaseHistorySorRecord sorRecord = new ReportMonthlyCaseHistorySorRecord();
		sorRecord.setRunDate(ObjectUtils.convertToDate(SystemInfoParam.getAsOfDate()));
		sorRecord.setReportSequenceNumber(sequenceNumber);
		sorRecord.setAidCode(pceRecord.getPceAidCd());
		sorRecord.setApplicationDate(pceRecord.getPceApplDt());
		sorRecord.setApprovalIndicator(pceRecord.getPceAprvlInd());
		sorRecord.setBenefitAmount(getOrDefault(pceRecord.getPceBnftAmt(), FWConstants.DEFAULT_DECIMAL));
		sorRecord.setBenefitMonth(pceRecord.getPceBnftMnth());
		sorRecord.setBenefitReductionAmount(getOrDefault(pceRecord.getPceBnftRdctnAmt(), FWConstants.DEFAULT_DECIMAL));
		sorRecord.setBenefitYear(pceRecord.getPceBnftYr());
		sorRecord.setCaseLoadId(pceRecord.getPceCasldId());
		sorRecord.setCaseStatus(pceRecord.getPceCaseSts());
		sorRecord.setClosureReasonCode(pceRecord.getPceClsreRsnCd());
		sorRecord.setConfirseIndicator(pceRecord.getPceConfrsInd());
		sorRecord.setEligCode(pceRecord.getPceEligCd());
		sorRecord.setEntitlementAmount(getOrDefault(pceRecord.getPceEntlmAmt(), FWConstants.DEFAULT_DECIMAL));
		sorRecord.setExpeditedSnapReasonCode(pceRecord.getPceExpdFsRsnCd());
		sorRecord.setHohUpi(pceRecord.getPceHohUpi());
		sorRecord.setHomelessIndicator(pceRecord.getPceHmlsInd());
		sorRecord.setIci(pceRecord.getPceIci());
		sorRecord.setInitialApprovalDate(pceRecord.getPceInitAprvlDt());
		sorRecord.setLastRecordForMonth(pceRecord.getPceLastRecForMnth());
		sorRecord.setMonthlyReportingIndicator(pceRecord.getPceMthlyRptrInd());
		sorRecord.setMultipleClosureReasonIndicator(getOrDefault(pceRecord.getPceMultClsreInd(), BLANK));
		sorRecord.setNextRedeterminationDate(pceRecord.getPceNextRedetDt());
		sorRecord.setNomadsUserId(getOrDefault(pceRecord.getPceWrkrId(), BLANK));
		sorRecord.setNoOfChildRecipient(pceRecord.getPceNoOfChldRcpnt());
		sorRecord.setNoOfRecipient(pceRecord.getPceNoOfRcpnt());
		sorRecord.setOfficeCode(pceRecord.getPceOfcCd());
		sorRecord.setSupervisoryUnit(pceRecord.getPceSprvsUnit());
		sorRecord.setFunctionalAreaCode(pceRecord.getPceFuncAreaCd());
		sorRecord.setWorkerType(pceRecord.getPceWrkrType());
		sorRecord.setPositionNumber(Integer.valueOf(pceRecord.getPcePsnNmb()));
		sorRecord.setProgramCaseStatus(pceRecord.getPcePrgmCaseSts());
		sorRecord.setProgramCaseType(pceRecord.getPcePrgmCaseType());
		sorRecord.setReappCount(FWConstants.ZERO);
		sorRecord.setReappIndicator(pceRecord.getPceReappInd());
		sorRecord.setRedeterminationCompleteMonth(pceRecord.getPceRedetCmplThisMnth());
		sorRecord.setRedeterminationIndicator(pceRecord.getPceRedetInd());
		sorRecord.setReinstateDate(pceRecord.getPceReisntDt());
		sorRecord.setReinstateIndicator(pceRecord.getPceReinstInd());
		sorRecord.setReopenedIndicator(pceRecord.getPceReopnInd());
		sorRecord.setSnapSuffix(pceRecord.getPceAssistCd());
		sorRecord.setStatusEffectiveDate(pceRecord.getPcePrgmStsEffDt());
		sorRecord.setWorkerName(getOrDefault(pceRecord.getPceWrkrNm(), BLANK));
		sorRecord.setActionType(getOrDefault(pceRecord.getActnType(), BLANK));
		if (pceRecord.getPceActApplDt() != null) {
			sorRecord.setActionTimestamp(getActionTimestamp(pceRecord.getPceActApplDt().atStartOfDay()));
		}else {
			sorRecord.setActionTimestamp(new Timestamp(0));
		}
		sorRecord.setVersionNumber(pceRecord.getPceVerNmb());
		sorRecord.setStatusCode(N);
		return sorRecord;
	}

	private <T> T getOrDefault(T value, T defaultValue) {
		return value != null ? value : defaultValue;
	}

	private Timestamp getActionTimestamp(LocalDateTime actionDate) {
		return actionDate != null ? Timestamp.valueOf(actionDate) : new Timestamp(0);
	}

	private void performDatabaseOperations(List<SorRecord> recordList) throws Exception {
		Connection connection = DataSourceUtils.getConnection(sorDataSource);
		try {
			databaseSwitch.switchDataSourceAndSchema(reportMonthlyCaseHistorySorDao, nswdSchemaName, sorDataSource);
			this.monthlyProgramCaseHistoryExtractDao.deleteProgramHistoryCases();
			this.reportMonthlyCaseHistorySorDao.batchInsert(recordList);
			connection.commit();
		} catch (Exception e) {
			LOG.error(e);
			final String applicationMessage = "Error occurred while writing records to DB";
			connection.rollback();
			final SkippedRecord skippedRecord = new SkippedRecord("programHistoryRecord");
			throw ExceptionUtil.batchSkipRecordException(BatchExceptionType.SQL_EXCEPTION, applicationMessage, null,
					null, StatisticsConstants.PROGRAM_HISTORY_BATCH, e, skippedRecord);
		} finally {
			DataSourceUtils.releaseConnection(connection, sorDataSource);
		}
	}
}

-----------------------
package gov.nv.dwss.crystalreports.statistics.programhistory.tasklet;

import gov.nv.dwss.crystalreports.statistics.common.dao.MonthlyCaseHistoryExtendedDao;
import gov.nv.dwss.crystalreports.statistics.common.model.FamCaseStatsOfficeRecord;
import gov.nv.dwss.crystalreports.statistics.constants.StatisticsConstants;
import gov.nv.dwss.crystalreports.statistics.programhistory.model.FamCaseStatsWorkingStorage;
import gov.nv.dwss.domain.dao.sor.ReportMonthlyCaseHistorySorDao;
import gov.nv.dwss.domain.record.SorRecord;
import gov.nv.dwss.domain.record.sor.ReportMonthlyCaseHistorySorRecord;
import gov.nv.dwss.fw.batch.context.SystemInfoParam;
import gov.nv.dwss.fw.batch.enums.BatchExceptionType;
import gov.nv.dwss.fw.batch.model.SkippedRecord;
import gov.nv.dwss.fw.batch.util.ExceptionUtil;
import gov.nv.dwss.switcher.DatabaseSwitcher;
import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;
import org.springframework.batch.core.StepContribution;
import org.springframework.batch.core.scope.context.ChunkContext;
import org.springframework.batch.core.step.tasklet.Tasklet;
import org.springframework.batch.repeat.RepeatStatus;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.annotation.Qualifier;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.jdbc.datasource.DataSourceUtils;
import org.springframework.stereotype.Component;
import org.springframework.util.CollectionUtils;

import javax.annotation.PostConstruct;
import javax.sql.DataSource;
import java.sql.Connection;
import java.sql.Timestamp;
import java.util.ArrayList;
import java.util.Comparator;
import java.util.Date;
import java.util.List;

import static gov.nv.dwss.crystalreports.foodstampcharacteristicstudy.util.DateUtil.getTimeStamp;
import static gov.nv.dwss.fw.batch.constants.FWConstants.LOW_DATE_STR;
import static gov.nv.dwss.fw.batch.constants.FWConstants.MA;
import static gov.nv.dwss.fw.batch.constants.FWConstants.Y;
import static gov.nv.dwss.fw.batch.util.ObjectUtils.convertToDate;
import static java.util.stream.Collectors.toList;

@Component
public class ProgramHistoryValidateTasklet implements Tasklet {

    private static final Logger LOG = LogManager.getLogger(ProgramHistoryValidateTasklet.class);

    private static final int PAGE_SIZE = 5000;
    Date lowDate;
    Timestamp lowDateTimestamp;

    @Autowired ReportMonthlyCaseHistorySorDao reportMonthlyCaseHistorySorDao;
    @Autowired MonthlyCaseHistoryExtendedDao monthlyCaseHistoryDao;
    @Autowired @Qualifier(value = "nswdDataSource") DataSource nswdDataSource;
    @Autowired DatabaseSwitcher databaseSwitch;
    @Value("${db.nswd.schema}") String nswdSchemaName;

    @PostConstruct
    public void init() {
        lowDate = convertToDate(LOW_DATE_STR);
        lowDateTimestamp = getTimeStamp(LOW_DATE_STR);
    }

    @Override
    public RepeatStatus execute(StepContribution contribution, ChunkContext chunkContext) throws Exception {
        List<FamCaseStatsOfficeRecord> famCaseStatsOfcRecord;
        List<ReportMonthlyCaseHistorySorRecord> pceRecords;
        FamCaseStatsWorkingStorage workingStorage = new FamCaseStatsWorkingStorage();
        List<ReportMonthlyCaseHistorySorRecord> newPceRecords = new ArrayList<>();

        try {
            famCaseStatsOfcRecord = monthlyCaseHistoryDao.getAllOfcCasldIdAndAidCds();
            pceRecords = fetchPceRecordsFromDb();
            pceRecords.sort(Comparator.comparing(ReportMonthlyCaseHistorySorRecord::getOfficeCode)
                    .thenComparing(ReportMonthlyCaseHistorySorRecord::getCaseLoadId)
                    .thenComparing(ReportMonthlyCaseHistorySorRecord::getAidCode));
        } catch (Exception e) {
            LOG.error("Error fetching FamCaseStatsOfficeRecord/ProgramCaseHistory list: ", e);
            return RepeatStatus.FINISHED;
        }

        try {
            if (!CollectionUtils.isEmpty(famCaseStatsOfcRecord)) {
                for (FamCaseStatsOfficeRecord or : famCaseStatsOfcRecord) {
                    LOG.info("{}", or);
                }
                // Setup working storage with first FamCase
                FamCaseStatsOfficeRecord famCaseRec1 = famCaseStatsOfcRecord.get(0);
                updateWorkingStorageWithFamCase(famCaseRec1, workingStorage);

                int i = 0; // FamCase index
                while (i < famCaseStatsOfcRecord.size()) {
                    FamCaseStatsOfficeRecord famCaseRec = famCaseStatsOfcRecord.get(i);
                    if (!CollectionUtils.isEmpty(pceRecords)) {
                        for (ReportMonthlyCaseHistorySorRecord pceRecord : pceRecords) {
                            try {
                                boolean scanned = false;
                                if (!pceRecord.getOfficeCode().equals(workingStorage.getPreviousOfcCd())) {
                                    updateWorkingStorageWithPceRecord(pceRecord, workingStorage);

                                    if (workingStorage.getPceRecords().compareTo(workingStorage.getFamCaseRecords()) > 0) {
                                        ReportMonthlyCaseHistorySorRecord copyOfPceRecord = mapToNewPceRecord(famCaseRec);
                                        if (!famCaseRec.getOfcCd().isEmpty() && !famCaseRec.getCasldId().isEmpty()) {
                                            newPceRecords.add(copyOfPceRecord);
                                        }
                                        scanned = scanNextFamCase(++i, famCaseStatsOfcRecord, workingStorage, true);
                                        famCaseRec = scanned ? famCaseStatsOfcRecord.get(i) : famCaseRec;
                                    }

                                    if (workingStorage.getPceRecords().compareTo(workingStorage.getFamCaseRecords()) == 0) {
                                        scanned = scanNextFamCase(++i, famCaseStatsOfcRecord, workingStorage, false);
                                        famCaseRec = scanned ? famCaseStatsOfcRecord.get(i) : famCaseRec;
                                    }

                                    workingStorage.setPreviousOfcCd(workingStorage.getFamCaseOfcCd());
                                    workingStorage.setPreviousCasldId(workingStorage.getFamCaseCasldId());
                                    workingStorage.setPreviousAidCd(workingStorage.getFamCaseAidCd());

                                    if (!scanned && i >= famCaseStatsOfcRecord.size()) break;

                                } else if (!pceRecord.getCaseLoadId().equals(workingStorage.getPreviousCasldId())) {
                                    updateWorkingStorageWithPceRecord(pceRecord, workingStorage);

                                    if (workingStorage.getPceRecords().compareTo(workingStorage.getFamCaseRecords()) > 0) {
                                        ReportMonthlyCaseHistorySorRecord copyOfPceRecord = mapToNewPceRecord(famCaseRec);
                                        if (!famCaseRec.getOfcCd().isEmpty() && !famCaseRec.getCasldId().isEmpty()) {
                                            newPceRecords.add(copyOfPceRecord);
                                        }
                                        scanned = scanNextFamCase(++i, famCaseStatsOfcRecord, workingStorage, true);
                                        famCaseRec = scanned ? famCaseStatsOfcRecord.get(i) : famCaseRec;
                                    }

                                    if (workingStorage.getPceRecords().compareTo(workingStorage.getFamCaseRecords()) == 0) {
                                        scanned = scanNextFamCase(++i, famCaseStatsOfcRecord, workingStorage, false);
                                        famCaseRec = scanned ? famCaseStatsOfcRecord.get(i) : famCaseRec;
                                    }

                                    workingStorage.setPreviousCasldId(workingStorage.getFamCaseCasldId());
                                    workingStorage.setPreviousAidCd(workingStorage.getFamCaseAidCd());

                                    if (!scanned && i >= famCaseStatsOfcRecord.size()) break;

                                } else if (!pceRecord.getAidCode().equals(workingStorage.getPreviousAidCd())) {
                                    updateWorkingStorageWithPceRecord(pceRecord, workingStorage);

                                    if (workingStorage.getPceRecords().compareTo(workingStorage.getFamCaseRecords()) > 0) {
                                        ReportMonthlyCaseHistorySorRecord copyOfPceRecord = mapToNewPceRecord(famCaseRec);
                                        if (!famCaseRec.getOfcCd().isEmpty() && !famCaseRec.getCasldId().isEmpty()) {
                                            newPceRecords.add(copyOfPceRecord);
                                        }
                                        scanned = scanNextFamCase(++i, famCaseStatsOfcRecord, workingStorage, true);
                                        famCaseRec = scanned ? famCaseStatsOfcRecord.get(i) : famCaseRec;
                                    }

                                    if (workingStorage.getPceRecords().compareTo(workingStorage.getFamCaseRecords()) == 0) {
                                        scanned = scanNextFamCase(++i, famCaseStatsOfcRecord, workingStorage, false);
                                        famCaseRec = scanned ? famCaseStatsOfcRecord.get(i) : famCaseRec;
                                    }

                                    workingStorage.setPreviousAidCd(workingStorage.getFamCaseAidCd());

                                    if (!scanned && i >= famCaseStatsOfcRecord.size()) break;

                                }
                            } catch (Exception ex) {
                                LOG.error("Error during FamCaseRecord/PceRecord processing. famCaseRec={}, pceRecord={}", famCaseRec, pceRecord, ex);
                                // continue with next record
                            }
                        }
                    }
                    i++; // move to next FamCase for next while iteration if not already advanced
                }
            }
            logNewProgramCaseHistories(newPceRecords);
            performDatabaseOperations(newPceRecords);
        } catch (Exception e) {
            LOG.error("Error processing famCaseStats/pceRecords : ", e);
        }



        return RepeatStatus.FINISHED;
    }

    /** Updates FamCase values in working storage */
    private void updateWorkingStorageWithFamCase(FamCaseStatsOfficeRecord famCase, FamCaseStatsWorkingStorage storage) {
        storage.setFamCaseOfcCd(famCase.getOfcCd());
        storage.setFamCaseCasldId(famCase.getCasldId());
        storage.setFamCaseAidCd(famCase.getAidCd());
        storage.setFamCaseRecords(famCase.getOfcCd() + famCase.getCasldId() + famCase.getAidCd());
    }

    /** Updates PceRecord values in working storage */
    private void updateWorkingStorageWithPceRecord(ReportMonthlyCaseHistorySorRecord pceRecord, FamCaseStatsWorkingStorage storage) {
        storage.setPceOfcCd(pceRecord.getOfficeCode());
        storage.setPceCasldId(pceRecord.getCaseLoadId());
        storage.setPceAidCd(pceRecord.getAidCode());
        storage.setPceRecords(pceRecord.getOfficeCode() + pceRecord.getCaseLoadId() + pceRecord.getAidCode());
    }

    /** Safely advances to next FamCase and updates working storage if isFamStatUpdate, returns true if advanced */
    private boolean scanNextFamCase(
            int i, List<FamCaseStatsOfficeRecord> famCaseList, FamCaseStatsWorkingStorage storage, boolean isFamStatUpdate) {
        if (i < famCaseList.size()) {
            FamCaseStatsOfficeRecord nextFamCase = famCaseList.get(i);
            if (isFamStatUpdate) updateWorkingStorageWithFamCase(nextFamCase, storage);
            return true;
        }
        return false;
    }

    private ReportMonthlyCaseHistorySorRecord mapToNewPceRecord(FamCaseStatsOfficeRecord famCaseRec) {
        ReportMonthlyCaseHistorySorRecord pceRecord = new ReportMonthlyCaseHistorySorRecord();
        pceRecord.setRunDate(convertToDate(SystemInfoParam.getAsOfDate()));
        pceRecord.setOfficeCode(famCaseRec.getOfcCd());
        pceRecord.setCaseLoadId(famCaseRec.getCasldId());
        pceRecord.setAidCode(famCaseRec.getAidCd());
        pceRecord.setProgramCaseType(MA);
        pceRecord.setActionTimestamp(lowDateTimestamp);
        pceRecord.setApplicationDate(lowDate);
        pceRecord.setStatusEffectiveDate(lowDate);
        pceRecord.setStatusCode(Y);
        return pceRecord;
    }

    private List<ReportMonthlyCaseHistorySorRecord> fetchPceRecordsFromDb() {

        int totalCount = monthlyCaseHistoryDao.countProgramCaseHistoryForFamCaseStats();
        LOG.info("Total ProgramCaseHistory records to fetch: {}", totalCount);

        List<ReportMonthlyCaseHistorySorRecord> pceRecords = new ArrayList<>();

        int pageIndex = 0;
        while (pceRecords.size() < totalCount) {
            int startIndex = pageIndex * PAGE_SIZE + 1;
            int endIndex = Math.min((pageIndex + 1) * PAGE_SIZE, totalCount);

            List<ReportMonthlyCaseHistorySorRecord> chunk =
                    monthlyCaseHistoryDao.getProgramCaseHistoryForFamCaseStats(startIndex, endIndex);
            LOG.info("Fetched rows {}-{} ({} records)", startIndex, endIndex, chunk.size());

            pceRecords.addAll(chunk);

            if (chunk.size() < PAGE_SIZE) { // Less than requested page size: this was the final page
                break;
            }
            pageIndex++;
        }
        LOG.info("Total ProgramCaseHistory records loaded: {}", pceRecords.size());

        return pceRecords;
    }

    private void logNewProgramCaseHistories(List<ReportMonthlyCaseHistorySorRecord> pceRecords) {
        LOG.info("After Validation New ProgramCaseHistories :{}", pceRecords.size());
        for (ReportMonthlyCaseHistorySorRecord pceRecord : pceRecords) {
            LOG.info("ofcCd={}, casld:{}, aidCd:{}, ici={}",
                    pceRecord.getOfficeCode(), pceRecord.getCaseLoadId(), pceRecord.getAidCode(), pceRecord.getIci());
        }
    }

    private void performDatabaseOperations(List<ReportMonthlyCaseHistorySorRecord> pceRecords) throws Exception {
        int lastSeqNmb = monthlyCaseHistoryDao.getMaxSequenceNmbOfPceRecord();
        for (ReportMonthlyCaseHistorySorRecord pceRecord : pceRecords) {
            pceRecord.setReportSequenceNumber(++lastSeqNmb);
        }

        List<SorRecord> recordList = pceRecords.stream().map((d -> (SorRecord) d)).collect(toList());
        Connection connection = DataSourceUtils.getConnection(nswdDataSource);
        try {
            databaseSwitch.switchDataSourceAndSchema(reportMonthlyCaseHistorySorDao, nswdSchemaName, nswdDataSource);
            this.reportMonthlyCaseHistorySorDao.batchInsert(recordList);
            connection.commit();
        } catch (Exception e) {
            LOG.error(e);
            final String applicationMessage = "Error occurred while writing FAM ProgramCaseHistory records to DB";
            connection.rollback();
            final SkippedRecord skippedRecord = new SkippedRecord("newProgramCaseHistoryRecord");
            throw ExceptionUtil.batchSkipRecordException(BatchExceptionType.SQL_EXCEPTION, applicationMessage, null,
                    null, StatisticsConstants.PROGRAM_HISTORY_BATCH, e, skippedRecord);
        } finally {
            DataSourceUtils.releaseConnection(connection, nswdDataSource);
        }
    }
}
---------------------------
package gov.nv.dwss.crystalreports.statistics.programhistory.writer;

import java.sql.SQLException;
import java.text.SimpleDateFormat;
import java.util.Date;
import java.util.List;
import java.util.stream.Collectors;

import org.apache.commons.lang3.StringUtils;
import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;
import org.springframework.batch.item.ExecutionContext;
import org.springframework.batch.item.ItemWriter;
import org.springframework.batch.item.file.FlatFileItemWriter;
import org.springframework.batch.item.file.transform.PassThroughLineAggregator;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.core.io.FileSystemResource;
import org.springframework.stereotype.Component;

import gov.nv.dwss.crystalreports.statistics.common.model.CommonData;
import gov.nv.dwss.crystalreports.statistics.common.model.PceRecord;
import gov.nv.dwss.crystalreports.statistics.constants.StatisticsConstants;
import gov.nv.dwss.fw.batch.common.AbstractBatchStepComponent;
import gov.nv.dwss.fw.batch.enums.BatchExceptionType;
import gov.nv.dwss.fw.batch.exception.BatchBusinessException;
import gov.nv.dwss.fw.batch.exceptions.listener.FileCleanupListener;
import gov.nv.dwss.fw.batch.util.ExceptionUtil;

@Component
public class ProgramHistoryWriter extends AbstractBatchStepComponent implements ItemWriter<List<PceRecord>> {

	private static final Logger LOG = LogManager.getLogger(ProgramHistoryWriter.class);
	
	@Value("${programHistoryOutputFileLocation}")
	private String outputFileLocation;
	
	@Value("${appendTimestampToFile}")
	String appendTimestampToFile;
	
	@Value("${fileFormat}")
	String fileFormat;
	
	@Value("${generateOutput}")
	boolean generateOutput;
	
	@Autowired
	FileCleanupListener fileCleanupListener;
	
	@Override
	public void write(List<? extends List<PceRecord>> items) throws Exception {
		LOG.info("calling execute for before pceRecord count :: {}", items.size());
		List<PceRecord> collect = items.stream().flatMap(List::stream).collect(Collectors.toList());
		CommonData.getProgramCaseList().addAll(collect);
		
		LOG.info("calling execute for after pceRecord count :: {}", CommonData.getProgramCaseList().size());
		
		if(generateOutput) {
			synchronized (CommonData.getProgramCaseList()) {
				writer(CommonData.getProgramCaseList());
			}
		}
	}
	
	private void writer(List<PceRecord> items) throws SQLException, BatchBusinessException {
		String icis = StringUtils.join(items.stream().map(PceRecord::getPceIci).collect(Collectors.toList()), ",");
		String fileLocation = outputFileLocation;
		if (StatisticsConstants.TRUE.equalsIgnoreCase(appendTimestampToFile)) {
			fileLocation += "_" + new SimpleDateFormat("yyyyMMddHHmmss").format(new Date());
		}
		FileSystemResource fileSystemResource = new FileSystemResource(fileLocation + fileFormat);
		FlatFileItemWriter<String> itemWriter = new FlatFileItemWriter<>();
		try {
			itemWriter.setResource(fileSystemResource);
			writeToFile(icis, items, itemWriter);

			LOG.debug("Detail records written");
		} catch (Exception ex) {
			LOG.error("Rolling back transaction for ProgramHistory batch for -> {}", items.size());
			String applicationMessage = String.format("Error occurred when writing records for icis %s", icis);
			if (itemWriter != null)
				fileCleanupListener.addWriter(itemWriter, fileSystemResource);
			throw ExceptionUtil.batchBusinessException(BatchExceptionType.SQL_EXCEPTION, applicationMessage, null, null,
					StatisticsConstants.PROGRAM_HISTORY_BATCH, ex);
		}

	}
	
	private void writeToFile(String icis, List<PceRecord> detailRecordList, FlatFileItemWriter<String> itemWriter)
			throws Exception {
		LOG.debug("Writing detailRecord for -> {}", icis);
		itemWriter.setLineAggregator(new PassThroughLineAggregator<String>());
		itemWriter.open(new ExecutionContext());
		itemWriter.afterPropertiesSet();
		itemWriter.write(detailRecordList.stream().map(PceRecord::toString).collect(Collectors.toList()));
		itemWriter.close();
	}

}